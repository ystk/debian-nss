diff -Nru nss-3.26/nss/external_tests/ssl_gtest/ssl_auth_unittest.cc nss-3.26.2/nss/external_tests/ssl_gtest/ssl_auth_unittest.cc
--- nss-3.26/nss/external_tests/ssl_gtest/ssl_auth_unittest.cc	2016-08-05 17:43:39.000000000 +0200
+++ nss-3.26.2/nss/external_tests/ssl_gtest/ssl_auth_unittest.cc	2016-10-10 16:54:09.000000000 +0200
@@ -22,6 +22,38 @@
 
 namespace nss_test {
 
+class TlsInspectorCertificateRequestSigAlgSetter : public TlsHandshakeFilter {
+ public:
+  TlsInspectorCertificateRequestSigAlgSetter(SSLSignatureAndHashAlg sig_alg)
+    : sig_alg_(sig_alg) {}
+
+  virtual PacketFilter::Action FilterHandshake(
+      const HandshakeHeader& header,
+      const DataBuffer& input, DataBuffer* output) {
+    if (header.handshake_type() != kTlsHandshakeCertificateRequest) {
+      return KEEP;
+    }
+
+    TlsParser parser(input);
+    *output = input;
+
+    // Skip certificate types.
+    parser.SkipVariable(1);
+
+    // Skip sig algs length.
+    parser.Skip(2);
+
+    // Write signature algorithm.
+    output->Write(parser.consumed(), sig_alg_.hashAlg, 1);
+    output->Write(parser.consumed() + 1, sig_alg_.sigAlg, 1);
+
+    return CHANGE;
+  }
+
+ private:
+  SSLSignatureAndHashAlg sig_alg_;
+};
+
 TEST_P(TlsConnectGeneric, ClientAuth) {
   client_->SetupClientAuth();
   server_->RequestClientAuth(true);
@@ -337,4 +369,41 @@
   Receive(10);
 }
 
+TEST_P(TlsConnectTls12, ClientAuthNoMatchingSigAlgs) {
+  Reset(TlsAgent::kServerEcdsa);
+  server_->RequestClientAuth(false);
+  client_->SetupClientAuth();
+
+  server_->EnableCiphersByAuthType(ssl_auth_ecdh_ecdsa);
+  server_->SetSignatureAlgorithms(SignatureEcdsaSha256,
+                                  PR_ARRAY_SIZE(SignatureEcdsaSha256));
+
+  Connect();
+  CheckKeys(ssl_kea_ecdh, ssl_auth_ecdsa);
+  EXPECT_TRUE(!SSL_PeerCertificate(server_->ssl_fd()));
+}
+
+TEST_P(TlsConnectTls12, CertificateRequestMd5) {
+  const SSLSignatureAndHashAlg md5_sig_alg = {ssl_hash_md5, ssl_sign_rsa};
+
+  const SSLSignatureAndHashAlg serverAlgorithms[] = {
+    {ssl_hash_sha1, ssl_sign_rsa},
+    {ssl_hash_sha256, ssl_sign_rsa}
+  };
+
+  client_->SetupClientAuth();
+  server_->RequestClientAuth(true);
+  server_->SetPacketFilter(new TlsInspectorCertificateRequestSigAlgSetter
+                           (md5_sig_alg));
+  server_->SetSignatureAlgorithms(serverAlgorithms,
+                                  PR_ARRAY_SIZE(serverAlgorithms));
+
+  client_->EnableSingleCipher(TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384);
+  server_->EnableSingleCipher(TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384);
+
+  ConnectExpectFail();
+  ASSERT_EQ(SEC_ERROR_BAD_SIGNATURE, server_->error_code());
+  ASSERT_EQ(SSL_ERROR_DECRYPT_ERROR_ALERT, client_->error_code());
+}
+
 }
diff -Nru nss-3.26/nss/external_tests/ssl_gtest/tls_parser.h nss-3.26.2/nss/external_tests/ssl_gtest/tls_parser.h
--- nss-3.26/nss/external_tests/ssl_gtest/tls_parser.h	2016-08-05 17:43:39.000000000 +0200
+++ nss-3.26.2/nss/external_tests/ssl_gtest/tls_parser.h	2016-10-10 16:54:09.000000000 +0200
@@ -29,6 +29,7 @@
 const uint8_t kTlsHandshakeEncryptedExtensions = 8;
 const uint8_t kTlsHandshakeCertificate = 11;
 const uint8_t kTlsHandshakeServerKeyExchange = 12;
+const uint8_t kTlsHandshakeCertificateRequest = 13;
 const uint8_t kTlsHandshakeCertificateVerify = 15;
 const uint8_t kTlsHandshakeClientKeyExchange = 16;
 const uint8_t kTlsHandshakeFinished = 20;
diff -Nru nss-3.26/nss/.hg_archival.txt nss-3.26.2/nss/.hg_archival.txt
--- nss-3.26/nss/.hg_archival.txt	2016-08-05 17:43:39.000000000 +0200
+++ nss-3.26.2/nss/.hg_archival.txt	2016-10-10 16:54:09.000000000 +0200
@@ -1,4 +1,4 @@
 repo: 9949429068caa6bb8827a8ceeaa7c605d722f47f
-node: f118cfd3948a9198bff6db23a300073897fb59c0
+node: 5bb734f18d10e207cdfb222dbdb8be56dfdd0f64
 branch: NSS_3_26_BRANCH
-tag: NSS_3_26_RTM
+tag: NSS_3_26_2_RTM
diff -Nru nss-3.26/nss/lib/nss/nss.h nss-3.26.2/nss/lib/nss/nss.h
--- nss-3.26/nss/lib/nss/nss.h	2016-08-05 17:43:39.000000000 +0200
+++ nss-3.26.2/nss/lib/nss/nss.h	2016-10-10 16:54:09.000000000 +0200
@@ -22,10 +22,10 @@
  * The format of the version string should be
  *     "<major version>.<minor version>[.<patch level>[.<build number>]][ <ECC>][ <Beta>]"
  */
-#define NSS_VERSION  "3.26" _NSS_CUSTOMIZED
+#define NSS_VERSION  "3.26.2" _NSS_CUSTOMIZED
 #define NSS_VMAJOR   3
 #define NSS_VMINOR   26
-#define NSS_VPATCH   0
+#define NSS_VPATCH   2
 #define NSS_VBUILD   0
 #define NSS_BETA     PR_FALSE
 
diff -Nru nss-3.26/nss/lib/softoken/softkver.h nss-3.26.2/nss/lib/softoken/softkver.h
--- nss-3.26/nss/lib/softoken/softkver.h	2016-08-05 17:43:39.000000000 +0200
+++ nss-3.26.2/nss/lib/softoken/softkver.h	2016-10-10 16:54:09.000000000 +0200
@@ -25,10 +25,10 @@
  * The format of the version string should be
  *     "<major version>.<minor version>[.<patch level>[.<build number>]][ <ECC>][ <Beta>]"
  */
-#define SOFTOKEN_VERSION  "3.26" SOFTOKEN_ECC_STRING
+#define SOFTOKEN_VERSION  "3.26.2" SOFTOKEN_ECC_STRING
 #define SOFTOKEN_VMAJOR   3
 #define SOFTOKEN_VMINOR   26
-#define SOFTOKEN_VPATCH   0
+#define SOFTOKEN_VPATCH   2
 #define SOFTOKEN_VBUILD   0
 #define SOFTOKEN_BETA     PR_FALSE
 
diff -Nru nss-3.26/nss/lib/ssl/ssl3con.c nss-3.26.2/nss/lib/ssl/ssl3con.c
--- nss-3.26/nss/lib/ssl/ssl3con.c	2016-08-05 17:43:39.000000000 +0200
+++ nss-3.26.2/nss/lib/ssl/ssl3con.c	2016-10-10 16:54:09.000000000 +0200
@@ -7881,7 +7881,7 @@
     return rv;
 }
 
-static void
+static SECStatus
 ssl3_DecideTls12CertVerifyHash(sslSocket *ss, const SECItem *algorithms);
 
 typedef struct dnameNode {
@@ -8112,7 +8112,10 @@
             }
             if (ss->ssl3.hs.hashType == handshake_hash_record ||
                 ss->ssl3.hs.hashType == handshake_hash_single) {
-                ssl3_DecideTls12CertVerifyHash(ss, algorithms);
+                rv = ssl3_DecideTls12CertVerifyHash(ss, algorithms);
+                if (rv != SECSuccess) {
+                    goto send_no_certificate;
+                }
             }
             break; /* not an error */
 
@@ -10187,7 +10190,7 @@
     return SECFailure;
 }
 
-static void
+static SECStatus
 ssl3_DecideTls12CertVerifyHash(sslSocket *ss, const SECItem *algorithms)
 {
     SECStatus rv;
@@ -10201,7 +10204,7 @@
     /* Determine the key's signature algorithm and whether it prefers SHA-1. */
     rv = ssl3_ExtractClientKeyInfo(ss, &sigAlg, &preferSha1);
     if (rv != SECSuccess) {
-        return;
+        return SECFailure;
     }
 
     /* Determine the server's hash support for that signature algorithm. */
@@ -10210,6 +10213,9 @@
             SSLHashType hashAlg = algorithms->data[i];
             SECOidTag hashOID;
             PRUint32 policy;
+            if (hashAlg == ssl_hash_md5) {
+                continue; /* No MD5 signature support. */
+            }
             if (hashAlg == ssl_hash_sha1 &&
                 ss->ssl3.pwSpec->version >= SSL_LIBRARY_VERSION_TLS_1_3) {
                 /* TLS 1.3 explicitly forbids using SHA-1 with certificate_verify. */
@@ -10239,6 +10245,13 @@
     } else {
         ss->ssl3.hs.tls12CertVerifyHash = otherHashAlg;
     }
+
+    /* We didn't find a sigAlg matching the client cert's key type. */
+    if (ss->ssl3.hs.tls12CertVerifyHash == ssl_hash_none) {
+        return SECFailure;
+    }
+
+    return SECSuccess;
 }
 
 static SECStatus
@@ -12983,6 +12996,13 @@
     return DUPLICATE_MSB_TO_ALL_8(c);
 }
 
+/* ssl_constantTimeSelect return a if mask is 0xFF and b if mask is 0x00 */
+static unsigned char
+ssl_constantTimeSelect(unsigned char mask, unsigned char a, unsigned char b)
+{
+    return (mask & a) | (~mask & b);
+}
+
 static SECStatus
 ssl_RemoveSSLv3CBCPadding(sslBuffer *plaintext,
                           unsigned int blockSize,
@@ -13086,22 +13106,54 @@
     /* scanStart contains the number of bytes that we can ignore because
      * the MAC's position can only vary by 255 bytes. */
     unsigned scanStart = 0;
-    unsigned i, j, divSpoiler;
+    unsigned i, j;
     unsigned char rotateOffset;
 
-    if (originalLength > macSize + 255 + 1)
+    if (originalLength > macSize + 255 + 1) {
         scanStart = originalLength - (macSize + 255 + 1);
+    }
 
-    /* divSpoiler contains a multiple of macSize that is used to cause the
-     * modulo operation to be constant time. Without this, the time varies
-     * based on the amount of padding when running on Intel chips at least.
-     *
-     * The aim of right-shifting macSize is so that the compiler doesn't
-     * figure out that it can remove divSpoiler as that would require it
-     * to prove that macSize is always even, which I hope is beyond it. */
-    divSpoiler = macSize >> 1;
-    divSpoiler <<= (sizeof(divSpoiler) - 1) * 8;
-    rotateOffset = (divSpoiler + macStart - scanStart) % macSize;
+    /* We want to compute
+     * rotateOffset = (macStart - scanStart) % macSize
+     * But the time to compute this varies based on the amount of padding. Thus
+     * we explicitely handle all mac sizes with (hopefully) constant time modulo
+     * using Barrett reduction:
+     *  q := (rotateOffset * m) >> k
+     *  rotateOffset -= q * n
+     *  if (n <= rotateOffset) rotateOffset -= n
+     */
+    rotateOffset = macStart - scanStart;
+    /* rotateOffset < 255 + 1 + 48 = 304 */
+    if (macSize == 16) {
+        rotateOffset &= 15;
+    } else if (macSize == 20) {
+        /*
+         * Correctness: rotateOffset * ( 1/20 - 25/2^9 ) < 1
+         *              with rotateOffset <= 853
+         */
+        unsigned q = (rotateOffset * 25) >> 9; /* m = 25, k = 9 */
+        rotateOffset -= q * 20;
+        rotateOffset -= ssl_constantTimeSelect(ssl_ConstantTimeGE(rotateOffset, 20),
+                                               20, 0);
+    } else if (macSize == 32) {
+        rotateOffset &= 31;
+    } else if (macSize == 48) {
+        /*
+         * Correctness: rotateOffset * ( 1/48 - 10/2^9 ) < 1
+         *              with rotateOffset < 768
+         */
+        unsigned q = (rotateOffset * 10) >> 9; /* m = 25, k = 9 */
+        rotateOffset -= q * 48;
+        rotateOffset -= ssl_constantTimeSelect(ssl_ConstantTimeGE(rotateOffset, 48),
+                                               48, 0);
+    } else {
+        /*
+         * SHA384 (macSize == 48) is the largest we support. We should never
+         * get here.
+         */
+        PORT_Assert(0);
+        rotateOffset = rotateOffset % macSize;
+    }
 
     memset(rotatedMac, 0, macSize);
     for (i = scanStart; i < originalLength;) {
@@ -13117,12 +13169,16 @@
     /* Now rotate the MAC. If we knew that the MAC fit into a CPU cache line
      * we could line-align |rotatedMac| and rotate in place. */
     memset(out, 0, macSize);
+    rotateOffset = macSize - rotateOffset;
+    rotateOffset = ssl_constantTimeSelect(ssl_ConstantTimeGE(rotateOffset, macSize),
+                                          0, rotateOffset);
     for (i = 0; i < macSize; i++) {
-        unsigned char offset =
-            (divSpoiler + macSize - rotateOffset + i) % macSize;
         for (j = 0; j < macSize; j++) {
-            out[j] |= rotatedMac[i] & ssl_ConstantTimeEQ8(j, offset);
+            out[j] |= rotatedMac[i] & ssl_ConstantTimeEQ8(j, rotateOffset);
         }
+        rotateOffset++;
+        rotateOffset = ssl_constantTimeSelect(ssl_ConstantTimeGE(rotateOffset, macSize),
+                                              0, rotateOffset);
     }
 }
 
diff -Nru nss-3.26/nss/lib/util/nssutil.h nss-3.26.2/nss/lib/util/nssutil.h
--- nss-3.26/nss/lib/util/nssutil.h	2016-08-05 17:43:39.000000000 +0200
+++ nss-3.26.2/nss/lib/util/nssutil.h	2016-10-10 16:54:09.000000000 +0200
@@ -19,10 +19,10 @@
  * The format of the version string should be
  *     "<major version>.<minor version>[.<patch level>[.<build number>]][ <Beta>]"
  */
-#define NSSUTIL_VERSION  "3.26"
+#define NSSUTIL_VERSION  "3.26.2"
 #define NSSUTIL_VMAJOR   3
 #define NSSUTIL_VMINOR   26
-#define NSSUTIL_VPATCH   0
+#define NSSUTIL_VPATCH   2
 #define NSSUTIL_VBUILD   0
 #define NSSUTIL_BETA     PR_FALSE
 
