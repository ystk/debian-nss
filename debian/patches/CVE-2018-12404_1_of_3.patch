# HG changeset patch
# User Franziskus Kiefer <franziskuskiefer@gmail.com>
# Date 1540551022 -7200
#      Fri Oct 26 12:50:22 2018 +0200
# Branch NSS_3_36_BRANCH
# Node ID 93b536c98e60fe27e4cbf859e746c0929905ec23
# Parent  e00f455d90e5ed34038a1b74c2d53093ba19233f
Bug 1485864 - improve RSA key exchange handling, r=mt

Differential Revision: https://phabricator.services.mozilla.com//D9914

Origin: backport, https://hg.mozilla.org/projects/nss/rev/93b536c98e60
[rcs: Backported to jessie]
--- nss-jessie.git.orig/nss/lib/ssl/ssl3con.c
+++ nss-jessie.git/nss/lib/ssl/ssl3con.c
@@ -10695,6 +10695,23 @@
     return pms;
 }
 
+static void
+ssl3_CSwapPK11SymKey(PK11SymKey **x, PK11SymKey **y, PRBool c)
+{
+    uintptr_t mask = (uintptr_t)c;
+    unsigned int i;
+    for (i = 1; i < sizeof(uintptr_t) * 8; i <<= 1) {
+        mask |= mask << i;
+    }
+    uintptr_t x_ptr = (uintptr_t)*x;
+    uintptr_t y_ptr = (uintptr_t)*y;
+    uintptr_t tmp = (x_ptr ^ y_ptr) & mask;
+    x_ptr = x_ptr ^ tmp;
+    y_ptr = y_ptr ^ tmp;
+    *x = (PK11SymKey *)x_ptr;
+    *y = (PK11SymKey *)y_ptr;
+}
+
 /* Note: The Bleichenbacher attack on PKCS#1 necessitates that we NEVER
  * return any indication of failure of the Client Key Exchange message,
  * where that failure is caused by the content of the client's message.
@@ -10802,13 +10819,9 @@
     } else
 #endif
     {
-        PK11SymKey *tmpPms[2] = { NULL, NULL };
-        PK11SlotInfo *slot;
-        int useFauxPms = 0;
-#define currentPms tmpPms[!useFauxPms]
-#define unusedPms tmpPms[useFauxPms]
-#define realPms tmpPms[1]
-#define fauxPms tmpPms[0]
+        PK11SymKey *pms = NULL;
+        PK11SymKey *fauxPms = NULL;
+        PK11SlotInfo *slot = NULL;
 
 #ifndef NO_PKCS11_BYPASS
     double_bypass:
@@ -10868,29 +10881,27 @@
          *  the unwrap.  Rather, it is the mechanism with which the
          *      unwrapped pms will be used.
          */
-        realPms = PK11_PubUnwrapSymKey(serverKeyPair->privKey, &enc_pms,
-                                       CKM_SSL3_MASTER_KEY_DERIVE, CKA_DERIVE, 0);
+        pms = PK11_PubUnwrapSymKey(serverKeyPair->privKey, &enc_pms,
+                                   CKM_SSL3_MASTER_KEY_DERIVE, CKA_DERIVE, 0);
         /* Temporarily use the PMS if unwrapping the real PMS fails. */
-        useFauxPms |= (realPms == NULL);
+        ssl3_CSwapPK11SymKey(&pms, &fauxPms, pms == NULL);
 
         /* Attempt to derive the MS from the PMS. This is the only way to
          * check the version field in the RSA PMS. If this fails, we
          * then use the faux PMS in place of the PMS. Note that this
          * operation should never fail if we are using the faux PMS
          * since it is correctly formatted. */
-        rv = ssl3_ComputeMasterSecret(ss, currentPms, NULL);
+        rv = ssl3_ComputeMasterSecret(ss, pms, NULL);
 
-        /* If we succeeded, then select the true PMS and discard the
-         * FPMS. Else, select the FPMS and select the true PMS */
-        useFauxPms |= (rv != SECSuccess);
-
-        if (unusedPms) {
-            PK11_FreeSymKey(unusedPms);
-        }
+        /* If we succeeded, then select the true PMS, else select the FPMS. */
+        ssl3_CSwapPK11SymKey(&pms, &fauxPms, (rv != SECSuccess) & (fauxPms != NULL));
 
         /* This step will derive the MS from the PMS, among other things. */
-        rv = ssl3_InitPendingCipherSpec(ss, currentPms);
-        PK11_FreeSymKey(currentPms);
+        rv = ssl3_InitPendingCipherSpec(ss, pms);
+
+        /* Clear both PMS. */
+        PK11_FreeSymKey(pms);
+        PK11_FreeSymKey(fauxPms);
     }
 
     if (rv != SECSuccess) {
@@ -10898,11 +10909,6 @@
         return SECFailure; /* error code set by ssl3_InitPendingCipherSpec */
     }
 
-#undef currentPms
-#undef unusedPms
-#undef realPms
-#undef fauxPms
-
     return SECSuccess;
 }
 
