From ac27d49a80473a96895101ae73a1270dac79cf87 Mon Sep 17 00:00:00 2001
From: Franziskus Kiefer <franziskuskiefer@gmail.com>
Date: Mon, 29 Aug 2016 11:25:38 +0200
Subject: Bug 1246619 - freebl clang-format, r=kaie

--HG--
extra : rebase_source : 113d4f386f611434caec7023f2f64e9fd0753c8a
extra : histedit_source : cccc55e775beab4e3d996a547e782e67bec077a5%2Ccd29f165a57e02d280d4db7bcc8e37f46b9a028b

index 2cbd08523..9324d306b 100644
--- a/nss/lib/freebl/dsa.c
+++ b/nss/lib/freebl/dsa.c
@@ -21,12 +21,12 @@
 #include "secmpi.h"
 #include "pqg.h"
 
- /* XXX to be replaced by define in blapit.h */
+/* XXX to be replaced by define in blapit.h */
 #define NSS_FREEBL_DSA_DEFAULT_CHUNKSIZE 2048
 
 /*
- * FIPS 186-2 requires result from random output to be reduced mod q when 
- * generating random numbers for DSA. 
+ * FIPS 186-2 requires result from random output to be reduced mod q when
+ * generating random numbers for DSA.
  *
  * Input: w, 2*qLen bytes
  *        q, qLen bytes
@@ -34,7 +34,7 @@
  */
 static SECStatus
 fips186Change_ReduceModQForDSA(const PRUint8 *w, const PRUint8 *q,
-                               unsigned int qLen, PRUint8 * xj)
+                               unsigned int qLen, PRUint8 *xj)
 {
     mp_int W, Q, Xj;
     mp_err err;
@@ -44,41 +44,42 @@ fips186Change_ReduceModQForDSA(const PRUint8 *w, const PRUint8 *q,
     MP_DIGITS(&W) = 0;
     MP_DIGITS(&Q) = 0;
     MP_DIGITS(&Xj) = 0;
-    CHECK_MPI_OK( mp_init(&W) );
-    CHECK_MPI_OK( mp_init(&Q) );
-    CHECK_MPI_OK( mp_init(&Xj) );
+    CHECK_MPI_OK(mp_init(&W));
+    CHECK_MPI_OK(mp_init(&Q));
+    CHECK_MPI_OK(mp_init(&Xj));
     /*
      * Convert input arguments into MPI integers.
      */
-    CHECK_MPI_OK( mp_read_unsigned_octets(&W, w, 2*qLen) );
-    CHECK_MPI_OK( mp_read_unsigned_octets(&Q, q, qLen) );
+    CHECK_MPI_OK(mp_read_unsigned_octets(&W, w, 2 * qLen));
+    CHECK_MPI_OK(mp_read_unsigned_octets(&Q, q, qLen));
 
     /*
      * Algorithm 1 of FIPS 186-2 Change Notice 1, Step 3.3
      *
      * xj = (w0 || w1) mod q
      */
-    CHECK_MPI_OK( mp_mod(&W, &Q, &Xj) );
-    CHECK_MPI_OK( mp_to_fixlen_octets(&Xj, xj, qLen) );
+    CHECK_MPI_OK(mp_mod(&W, &Q, &Xj));
+    CHECK_MPI_OK(mp_to_fixlen_octets(&Xj, xj, qLen));
 cleanup:
     mp_clear(&W);
     mp_clear(&Q);
     mp_clear(&Xj);
     if (err) {
-	MP_TO_SEC_ERROR(err);
-	rv = SECFailure;
+        MP_TO_SEC_ERROR(err);
+        rv = SECFailure;
     }
     return rv;
 }
 
 /*
- * FIPS 186-2 requires result from random output to be reduced mod q when 
- * generating random numbers for DSA. 
+ * FIPS 186-2 requires result from random output to be reduced mod q when
+ * generating random numbers for DSA.
  */
 SECStatus
 FIPS186Change_ReduceModQForDSA(const unsigned char *w,
                                const unsigned char *q,
-                               unsigned char *xj) {
+                               unsigned char *xj)
+{
     return fips186Change_ReduceModQForDSA(w, q, DSA1_SUBPRIME_LEN, xj);
 }
 
@@ -112,13 +113,13 @@ FIPS186Change_GenerateX(PRUint8 *XKEY, const PRUint8 *XSEEDj,
 ** Generate some random bytes, using the global random number generator
 ** object.  In DSA mode, so there is a q.
 */
-static SECStatus 
-dsa_GenerateGlobalRandomBytes(const SECItem * qItem, PRUint8 * dest,
-                              unsigned int * destLen, unsigned int maxDestLen)
+static SECStatus
+dsa_GenerateGlobalRandomBytes(const SECItem *qItem, PRUint8 *dest,
+                              unsigned int *destLen, unsigned int maxDestLen)
 {
     SECStatus rv;
     SECItem w;
-    const PRUint8 * q = qItem->data;
+    const PRUint8 *q = qItem->data;
     unsigned int qLen = qItem->len;
 
     if (*q == 0) {
@@ -132,7 +133,7 @@ dsa_GenerateGlobalRandomBytes(const SECItem * qItem, PRUint8 * dest,
         return SECFailure;
     }
     w.data = NULL; /* otherwise SECITEM_AllocItem asserts */
-    if (!SECITEM_AllocItem(NULL, &w, 2*qLen)) {
+    if (!SECITEM_AllocItem(NULL, &w, 2 * qLen)) {
         return SECFailure;
     }
     *destLen = qLen;
@@ -146,13 +147,14 @@ dsa_GenerateGlobalRandomBytes(const SECItem * qItem, PRUint8 * dest,
     return rv;
 }
 
-static void translate_mpi_error(mp_err err)
+static void
+translate_mpi_error(mp_err err)
 {
     MP_TO_SEC_ERROR(err);
 }
 
-static SECStatus 
-dsa_NewKeyExtended(const PQGParams *params, const SECItem * seed,
+static SECStatus
+dsa_NewKeyExtended(const PQGParams *params, const SECItem *seed,
                    DSAPrivateKey **privKey)
 {
     mp_int p, g;
@@ -162,20 +164,20 @@ dsa_NewKeyExtended(const PQGParams *params, const SECItem * seed,
     DSAPrivateKey *key;
     /* Check args. */
     if (!params || !privKey || !seed || !seed->data) {
-	PORT_SetError(SEC_ERROR_INVALID_ARGS);
-	return SECFailure;
+        PORT_SetError(SEC_ERROR_INVALID_ARGS);
+        return SECFailure;
     }
     /* Initialize an arena for the DSA key. */
     arena = PORT_NewArena(NSS_FREEBL_DSA_DEFAULT_CHUNKSIZE);
     if (!arena) {
-	PORT_SetError(SEC_ERROR_NO_MEMORY);
-	return SECFailure;
+        PORT_SetError(SEC_ERROR_NO_MEMORY);
+        return SECFailure;
     }
     key = (DSAPrivateKey *)PORT_ArenaZAlloc(arena, sizeof(DSAPrivateKey));
     if (!key) {
-	PORT_SetError(SEC_ERROR_NO_MEMORY);
-	PORT_FreeArena(arena, PR_TRUE);
-	return SECFailure;
+        PORT_SetError(SEC_ERROR_NO_MEMORY);
+        PORT_FreeArena(arena, PR_TRUE);
+        return SECFailure;
     }
     key->params.arena = arena;
     /* Initialize MPI integers. */
@@ -183,25 +185,25 @@ dsa_NewKeyExtended(const PQGParams *params, const SECItem * seed,
     MP_DIGITS(&g) = 0;
     MP_DIGITS(&x) = 0;
     MP_DIGITS(&y) = 0;
-    CHECK_MPI_OK( mp_init(&p) );
-    CHECK_MPI_OK( mp_init(&g) );
-    CHECK_MPI_OK( mp_init(&x) );
-    CHECK_MPI_OK( mp_init(&y) );
+    CHECK_MPI_OK(mp_init(&p));
+    CHECK_MPI_OK(mp_init(&g));
+    CHECK_MPI_OK(mp_init(&x));
+    CHECK_MPI_OK(mp_init(&y));
     /* Copy over the PQG params */
-    CHECK_MPI_OK( SECITEM_CopyItem(arena, &key->params.prime,
-                                          &params->prime) );
-    CHECK_MPI_OK( SECITEM_CopyItem(arena, &key->params.subPrime,
-                                          &params->subPrime) );
-    CHECK_MPI_OK( SECITEM_CopyItem(arena, &key->params.base, &params->base) );
+    CHECK_MPI_OK(SECITEM_CopyItem(arena, &key->params.prime,
+                                  &params->prime));
+    CHECK_MPI_OK(SECITEM_CopyItem(arena, &key->params.subPrime,
+                                  &params->subPrime));
+    CHECK_MPI_OK(SECITEM_CopyItem(arena, &key->params.base, &params->base));
     /* Convert stored p, g, and received x into MPI integers. */
     SECITEM_TO_MPINT(params->prime, &p);
-    SECITEM_TO_MPINT(params->base,  &g);
+    SECITEM_TO_MPINT(params->base, &g);
     OCTETS_TO_MPINT(seed->data, &x, seed->len);
     /* Store x in private key */
     SECITEM_AllocItem(arena, &key->privateValue, seed->len);
     PORT_Memcpy(key->privateValue.data, seed->data, seed->len);
     /* Compute public key y = g**x mod p */
-    CHECK_MPI_OK( mp_exptmod(&g, &x, &p, &y) );
+    CHECK_MPI_OK(mp_exptmod(&g, &x, &p, &y));
     /* Store y in public key */
     MPINT_TO_SECITEM(&y, &key->publicValue, arena);
     *privKey = key;
@@ -212,16 +214,16 @@ cleanup:
     mp_clear(&x);
     mp_clear(&y);
     if (key)
-	PORT_FreeArena(key->params.arena, PR_TRUE);
+        PORT_FreeArena(key->params.arena, PR_TRUE);
     if (err) {
-	translate_mpi_error(err);
-	return SECFailure;
+        translate_mpi_error(err);
+        return SECFailure;
     }
     return SECSuccess;
 }
 
 SECStatus
-DSA_NewRandom(PLArenaPool * arena, const SECItem * q, SECItem * seed)
+DSA_NewRandom(PLArenaPool *arena, const SECItem *q, SECItem *seed)
 {
     int retries = 10;
     unsigned int i;
@@ -238,30 +240,31 @@ DSA_NewRandom(PLArenaPool * arena, const SECItem * q, SECItem * seed)
     }
 
     do {
-	/* Generate seed bytes for x according to FIPS 186-1 appendix 3 */
+        /* Generate seed bytes for x according to FIPS 186-1 appendix 3 */
         if (dsa_GenerateGlobalRandomBytes(q, seed->data, &seed->len,
                                           seed->len)) {
             goto loser;
         }
-	/* Disallow values of 0 and 1 for x. */
-	good = PR_FALSE;
-	for (i = 0; i < seed->len-1; i++) {
-	    if (seed->data[i] != 0) {
-		good = PR_TRUE;
-		break;
-	    }
-	}
-	if (!good && seed->data[i] > 1) {
-	    good = PR_TRUE;
-	}
+        /* Disallow values of 0 and 1 for x. */
+        good = PR_FALSE;
+        for (i = 0; i < seed->len - 1; i++) {
+            if (seed->data[i] != 0) {
+                good = PR_TRUE;
+                break;
+            }
+        }
+        if (!good && seed->data[i] > 1) {
+            good = PR_TRUE;
+        }
     } while (!good && --retries > 0);
 
     if (!good) {
-	PORT_SetError(SEC_ERROR_NEED_RANDOM);
-loser:	if (arena != NULL) {
+        PORT_SetError(SEC_ERROR_NEED_RANDOM);
+    loser:
+        if (arena != NULL) {
             SECITEM_FreeItem(seed, PR_FALSE);
         }
-	return SECFailure;
+        return SECFailure;
     }
 
     return SECSuccess;
@@ -269,11 +272,11 @@ loser:	if (arena != NULL) {
 
 /*
 ** Generate and return a new DSA public and private key pair,
-**	both of which are encoded into a single DSAPrivateKey struct.
-**	"params" is a pointer to the PQG parameters for the domain
-**	Uses a random seed.
+**  both of which are encoded into a single DSAPrivateKey struct.
+**  "params" is a pointer to the PQG parameters for the domain
+**  Uses a random seed.
 */
-SECStatus 
+SECStatus
 DSA_NewKey(const PQGParams *params, DSAPrivateKey **privKey)
 {
     SECItem seed;
@@ -281,7 +284,7 @@ DSA_NewKey(const PQGParams *params, DSAPrivateKey **privKey)
 
     rv = PQG_Check(params);
     if (rv != SECSuccess) {
-	return rv;
+        return rv;
     }
     seed.data = NULL;
 
@@ -299,26 +302,26 @@ DSA_NewKey(const PQGParams *params, DSAPrivateKey **privKey)
 }
 
 /* For FIPS compliance testing. Seed must be exactly the size of subPrime  */
-SECStatus 
-DSA_NewKeyFromSeed(const PQGParams *params, 
+SECStatus
+DSA_NewKeyFromSeed(const PQGParams *params,
                    const unsigned char *seed,
                    DSAPrivateKey **privKey)
 {
     SECItem seedItem;
-    seedItem.data = (unsigned char*) seed;
+    seedItem.data = (unsigned char *)seed;
     seedItem.len = PQG_GetLength(&params->subPrime);
     return dsa_NewKeyExtended(params, &seedItem, privKey);
 }
 
-static SECStatus 
+static SECStatus
 dsa_SignDigest(DSAPrivateKey *key, SECItem *signature, const SECItem *digest,
                const unsigned char *kb)
 {
-    mp_int p, q, g;  /* PQG parameters */
-    mp_int x, k;     /* private key & pseudo-random integer */
-    mp_int r, s;     /* tuple (r, s) is signature) */
-    mp_int t;        /* holding tmp values */
-    mp_err err   = MP_OKAY;
+    mp_int p, q, g; /* PQG parameters */
+    mp_int x, k;    /* private key & pseudo-random integer */
+    mp_int r, s;    /* tuple (r, s) is signature) */
+    mp_int t;       /* holding tmp values */
+    mp_err err = MP_OKAY;
     SECStatus rv = SECSuccess;
     unsigned int dsa_subprime_len, dsa_signature_len, offset;
     SECItem localDigest;
@@ -328,28 +331,27 @@ dsa_SignDigest(DSAPrivateKey *key, SECItem *signature, const SECItem *digest,
     /* FIPS-compliance dictates that digest is a SHA hash. */
     /* Check args. */
     if (!key || !signature || !digest) {
-	PORT_SetError(SEC_ERROR_INVALID_ARGS);
-	return SECFailure;
+        PORT_SetError(SEC_ERROR_INVALID_ARGS);
+        return SECFailure;
     }
 
     dsa_subprime_len = PQG_GetLength(&key->params.subPrime);
-    dsa_signature_len = dsa_subprime_len*2;
+    dsa_signature_len = dsa_subprime_len * 2;
     if ((signature->len < dsa_signature_len) ||
-	(digest->len > HASH_LENGTH_MAX)  ||
-	(digest->len < SHA1_LENGTH)) {
-	PORT_SetError(SEC_ERROR_INVALID_ARGS);
-	return SECFailure;
+        (digest->len > HASH_LENGTH_MAX) ||
+        (digest->len < SHA1_LENGTH)) {
+        PORT_SetError(SEC_ERROR_INVALID_ARGS);
+        return SECFailure;
     }
 
-    /* DSA accepts digests not equal to dsa_subprime_len, if the 
-     * digests are greater, then they are truncated to the size of 
+    /* DSA accepts digests not equal to dsa_subprime_len, if the
+     * digests are greater, then they are truncated to the size of
      * dsa_subprime_len, using the left most bits. If they are less
      * then they are padded on the left.*/
     PORT_Memset(localDigestData, 0, dsa_subprime_len);
-    offset = (digest->len < dsa_subprime_len) ? 
-			(dsa_subprime_len - digest->len) : 0;
-    PORT_Memcpy(localDigestData+offset, digest->data, 
-		dsa_subprime_len - offset);
+    offset = (digest->len < dsa_subprime_len) ? (dsa_subprime_len - digest->len) : 0;
+    PORT_Memcpy(localDigestData + offset, digest->data,
+                dsa_subprime_len - offset);
     localDigest.data = localDigestData;
     localDigest.len = dsa_subprime_len;
 
@@ -362,30 +364,30 @@ dsa_SignDigest(DSAPrivateKey *key, SECItem *signature, const SECItem *digest,
     MP_DIGITS(&r) = 0;
     MP_DIGITS(&s) = 0;
     MP_DIGITS(&t) = 0;
-    CHECK_MPI_OK( mp_init(&p) );
-    CHECK_MPI_OK( mp_init(&q) );
-    CHECK_MPI_OK( mp_init(&g) );
-    CHECK_MPI_OK( mp_init(&x) );
-    CHECK_MPI_OK( mp_init(&k) );
-    CHECK_MPI_OK( mp_init(&r) );
-    CHECK_MPI_OK( mp_init(&s) );
-    CHECK_MPI_OK( mp_init(&t) );
+    CHECK_MPI_OK(mp_init(&p));
+    CHECK_MPI_OK(mp_init(&q));
+    CHECK_MPI_OK(mp_init(&g));
+    CHECK_MPI_OK(mp_init(&x));
+    CHECK_MPI_OK(mp_init(&k));
+    CHECK_MPI_OK(mp_init(&r));
+    CHECK_MPI_OK(mp_init(&s));
+    CHECK_MPI_OK(mp_init(&t));
     /*
     ** Convert stored PQG and private key into MPI integers.
     */
-    SECITEM_TO_MPINT(key->params.prime,    &p);
+    SECITEM_TO_MPINT(key->params.prime, &p);
     SECITEM_TO_MPINT(key->params.subPrime, &q);
-    SECITEM_TO_MPINT(key->params.base,     &g);
-    SECITEM_TO_MPINT(key->privateValue,    &x);
+    SECITEM_TO_MPINT(key->params.base, &g);
+    SECITEM_TO_MPINT(key->privateValue, &x);
     OCTETS_TO_MPINT(kb, &k, dsa_subprime_len);
     /*
     ** FIPS 186-1, Section 5, Step 1
     **
     ** r = (g**k mod p) mod q
     */
-    CHECK_MPI_OK( mp_exptmod(&g, &k, &p, &r) ); /* r = g**k mod p */
-    CHECK_MPI_OK(     mp_mod(&r, &q, &r) );     /* r = r mod q    */
-    /*                                  
+    CHECK_MPI_OK(mp_exptmod(&g, &k, &p, &r)); /* r = g**k mod p */
+    CHECK_MPI_OK(mp_mod(&r, &q, &r));         /* r = r mod q    */
+    /*
     ** FIPS 186-1, Section 5, Step 2
     **
     ** s = (k**-1 * (HASH(M) + x*r)) mod q
@@ -395,22 +397,22 @@ dsa_SignDigest(DSAPrivateKey *key, SECItem *signature, const SECItem *digest,
         rv = SECFailure;
         goto cleanup;
     }
-    SECITEM_TO_MPINT(t2, &t); /* t <-$ Zq */
-    CHECK_MPI_OK( mp_mulmod(&k, &t, &q, &k) );  /* k = k * t mod q */
-    CHECK_MPI_OK( mp_invmod(&k, &q, &k) );      /* k = k**-1 mod q */
-    CHECK_MPI_OK( mp_mulmod(&k, &t, &q, &k) );  /* k = k * t mod q */
-    SECITEM_TO_MPINT(localDigest, &s);          /* s = HASH(M)     */
-    CHECK_MPI_OK( mp_mulmod(&x, &r, &q, &x) );  /* x = x * r mod q */
-    CHECK_MPI_OK( mp_addmod(&s, &x, &q, &s) );  /* s = s + x mod q */
-    CHECK_MPI_OK( mp_mulmod(&s, &k, &q, &s) );  /* s = s * k mod q */
+    SECITEM_TO_MPINT(t2, &t);                /* t <-$ Zq */
+    CHECK_MPI_OK(mp_mulmod(&k, &t, &q, &k)); /* k = k * t mod q */
+    CHECK_MPI_OK(mp_invmod(&k, &q, &k));     /* k = k**-1 mod q */
+    CHECK_MPI_OK(mp_mulmod(&k, &t, &q, &k)); /* k = k * t mod q */
+    SECITEM_TO_MPINT(localDigest, &s);       /* s = HASH(M)     */
+    CHECK_MPI_OK(mp_mulmod(&x, &r, &q, &x)); /* x = x * r mod q */
+    CHECK_MPI_OK(mp_addmod(&s, &x, &q, &s)); /* s = s + x mod q */
+    CHECK_MPI_OK(mp_mulmod(&s, &k, &q, &s)); /* s = s * k mod q */
     /*
     ** verify r != 0 and s != 0
     ** mentioned as optional in FIPS 186-1.
     */
     if (mp_cmp_z(&r) == 0 || mp_cmp_z(&s) == 0) {
-	PORT_SetError(SEC_ERROR_NEED_RANDOM);
-	rv = SECFailure;
-	goto cleanup;
+        PORT_SetError(SEC_ERROR_NEED_RANDOM);
+        rv = SECFailure;
+        goto cleanup;
     }
     /*
     ** Step 4
@@ -418,10 +420,12 @@ dsa_SignDigest(DSAPrivateKey *key, SECItem *signature, const SECItem *digest,
     ** Signature is tuple (r, s)
     */
     err = mp_to_fixlen_octets(&r, signature->data, dsa_subprime_len);
-    if (err < 0) goto cleanup; 
-    err = mp_to_fixlen_octets(&s, signature->data + dsa_subprime_len, 
-                                  dsa_subprime_len);
-    if (err < 0) goto cleanup; 
+    if (err < 0)
+        goto cleanup;
+    err = mp_to_fixlen_octets(&s, signature->data + dsa_subprime_len,
+                              dsa_subprime_len);
+    if (err < 0)
+        goto cleanup;
     err = MP_OKAY;
     signature->len = dsa_signature_len;
 cleanup:
@@ -436,8 +440,8 @@ cleanup:
     mp_clear(&t);
     SECITEM_FreeItem(&t2, PR_FALSE);
     if (err) {
-	translate_mpi_error(err);
-	rv = SECFailure;
+        translate_mpi_error(err);
+        rv = SECFailure;
     }
     return rv;
 }
@@ -448,53 +452,53 @@ cleanup:
 ** On output, signature->len == size of signature in buffer.
 ** Uses a random seed.
 */
-SECStatus 
+SECStatus
 DSA_SignDigest(DSAPrivateKey *key, SECItem *signature, const SECItem *digest)
 {
     SECStatus rv;
-    int       retries = 10;
+    int retries = 10;
     unsigned char kSeed[DSA_MAX_SUBPRIME_LEN];
     unsigned int kSeedLen = 0;
     unsigned int i;
     unsigned int dsa_subprime_len = PQG_GetLength(&key->params.subPrime);
-    PRBool    good;
+    PRBool good;
 
     PORT_SetError(0);
     do {
-	rv = dsa_GenerateGlobalRandomBytes(&key->params.subPrime,
+        rv = dsa_GenerateGlobalRandomBytes(&key->params.subPrime,
                                            kSeed, &kSeedLen, sizeof kSeed);
-	if (rv != SECSuccess) 
-	    break;
+        if (rv != SECSuccess)
+            break;
         if (kSeedLen != dsa_subprime_len) {
             PORT_SetError(SEC_ERROR_INVALID_ARGS);
             rv = SECFailure;
             break;
         }
-	/* Disallow a value of 0 for k. */
-	good = PR_FALSE;
-	for (i = 0; i < kSeedLen; i++) {
-	    if (kSeed[i] != 0) {
-		good = PR_TRUE;
-		break;
-	    }
-	}
-	if (!good) {
-	    PORT_SetError(SEC_ERROR_NEED_RANDOM);
-	    rv = SECFailure;
-	    continue;
-	}
-	rv = dsa_SignDigest(key, signature, digest, kSeed);
+        /* Disallow a value of 0 for k. */
+        good = PR_FALSE;
+        for (i = 0; i < kSeedLen; i++) {
+            if (kSeed[i] != 0) {
+                good = PR_TRUE;
+                break;
+            }
+        }
+        if (!good) {
+            PORT_SetError(SEC_ERROR_NEED_RANDOM);
+            rv = SECFailure;
+            continue;
+        }
+        rv = dsa_SignDigest(key, signature, digest, kSeed);
     } while (rv != SECSuccess && PORT_GetError() == SEC_ERROR_NEED_RANDOM &&
-	     --retries > 0);
+             --retries > 0);
     return rv;
 }
 
 /* For FIPS compliance testing. Seed must be exactly 20 bytes. */
-SECStatus 
-DSA_SignDigestWithSeed(DSAPrivateKey * key,
-                       SECItem *       signature,
-                       const SECItem * digest,
-                       const unsigned char * seed)
+SECStatus
+DSA_SignDigestWithSeed(DSAPrivateKey *key,
+                       SECItem *signature,
+                       const SECItem *digest,
+                       const unsigned char *seed)
 {
     SECStatus rv;
     rv = dsa_SignDigest(key, signature, digest, seed);
@@ -505,8 +509,8 @@ DSA_SignDigestWithSeed(DSAPrivateKey * key,
 ** On input,  signature->len == size of buffer to hold signature.
 **            digest->len    == size of digest.
 */
-SECStatus 
-DSA_VerifyDigest(DSAPublicKey *key, const SECItem *signature, 
+SECStatus
+DSA_VerifyDigest(DSAPublicKey *key, const SECItem *signature,
                  const SECItem *digest)
 {
     /* FIPS-compliance dictates that digest is a SHA hash. */
@@ -521,60 +525,59 @@ DSA_VerifyDigest(DSAPublicKey *key, const SECItem *signature,
     SECStatus verified = SECFailure;
 
     /* Check args. */
-    if (!key || !signature || !digest ) {
-	PORT_SetError(SEC_ERROR_INVALID_ARGS);
-	return SECFailure;
+    if (!key || !signature || !digest) {
+        PORT_SetError(SEC_ERROR_INVALID_ARGS);
+        return SECFailure;
     }
 
     dsa_subprime_len = PQG_GetLength(&key->params.subPrime);
-    dsa_signature_len = dsa_subprime_len*2;
+    dsa_signature_len = dsa_subprime_len * 2;
     if ((signature->len != dsa_signature_len) ||
-	(digest->len > HASH_LENGTH_MAX)  ||
-	(digest->len < SHA1_LENGTH)) {
-	PORT_SetError(SEC_ERROR_INVALID_ARGS);
-	return SECFailure;
+        (digest->len > HASH_LENGTH_MAX) ||
+        (digest->len < SHA1_LENGTH)) {
+        PORT_SetError(SEC_ERROR_INVALID_ARGS);
+        return SECFailure;
     }
 
-    /* DSA accepts digests not equal to dsa_subprime_len, if the 
-     * digests are greater, than they are truncated to the size of 
+    /* DSA accepts digests not equal to dsa_subprime_len, if the
+     * digests are greater, than they are truncated to the size of
      * dsa_subprime_len, using the left most bits. If they are less
      * then they are padded on the left.*/
     PORT_Memset(localDigestData, 0, dsa_subprime_len);
-    offset = (digest->len < dsa_subprime_len) ? 
-			(dsa_subprime_len - digest->len) : 0;
-    PORT_Memcpy(localDigestData+offset, digest->data, 
-		dsa_subprime_len - offset);
+    offset = (digest->len < dsa_subprime_len) ? (dsa_subprime_len - digest->len) : 0;
+    PORT_Memcpy(localDigestData + offset, digest->data,
+                dsa_subprime_len - offset);
     localDigest.data = localDigestData;
     localDigest.len = dsa_subprime_len;
 
     /* Initialize MPI integers. */
-    MP_DIGITS(&p)  = 0;
-    MP_DIGITS(&q)  = 0;
-    MP_DIGITS(&g)  = 0;
-    MP_DIGITS(&y)  = 0;
+    MP_DIGITS(&p) = 0;
+    MP_DIGITS(&q) = 0;
+    MP_DIGITS(&g) = 0;
+    MP_DIGITS(&y) = 0;
     MP_DIGITS(&r_) = 0;
     MP_DIGITS(&s_) = 0;
     MP_DIGITS(&u1) = 0;
     MP_DIGITS(&u2) = 0;
-    MP_DIGITS(&v)  = 0;
-    MP_DIGITS(&w)  = 0;
-    CHECK_MPI_OK( mp_init(&p)  );
-    CHECK_MPI_OK( mp_init(&q)  );
-    CHECK_MPI_OK( mp_init(&g)  );
-    CHECK_MPI_OK( mp_init(&y)  );
-    CHECK_MPI_OK( mp_init(&r_) );
-    CHECK_MPI_OK( mp_init(&s_) );
-    CHECK_MPI_OK( mp_init(&u1) );
-    CHECK_MPI_OK( mp_init(&u2) );
-    CHECK_MPI_OK( mp_init(&v)  );
-    CHECK_MPI_OK( mp_init(&w)  );
+    MP_DIGITS(&v) = 0;
+    MP_DIGITS(&w) = 0;
+    CHECK_MPI_OK(mp_init(&p));
+    CHECK_MPI_OK(mp_init(&q));
+    CHECK_MPI_OK(mp_init(&g));
+    CHECK_MPI_OK(mp_init(&y));
+    CHECK_MPI_OK(mp_init(&r_));
+    CHECK_MPI_OK(mp_init(&s_));
+    CHECK_MPI_OK(mp_init(&u1));
+    CHECK_MPI_OK(mp_init(&u2));
+    CHECK_MPI_OK(mp_init(&v));
+    CHECK_MPI_OK(mp_init(&w));
     /*
     ** Convert stored PQG and public key into MPI integers.
     */
-    SECITEM_TO_MPINT(key->params.prime,    &p);
+    SECITEM_TO_MPINT(key->params.prime, &p);
     SECITEM_TO_MPINT(key->params.subPrime, &q);
-    SECITEM_TO_MPINT(key->params.base,     &g);
-    SECITEM_TO_MPINT(key->publicValue,     &y);
+    SECITEM_TO_MPINT(key->params.base, &g);
+    SECITEM_TO_MPINT(key->publicValue, &y);
     /*
     ** Convert received signature (r', s') into MPI integers.
     */
@@ -585,46 +588,46 @@ DSA_VerifyDigest(DSAPublicKey *key, const SECItem *signature,
     */
     if (mp_cmp_z(&r_) <= 0 || mp_cmp_z(&s_) <= 0 ||
         mp_cmp(&r_, &q) >= 0 || mp_cmp(&s_, &q) >= 0) {
-	/* err is zero here. */
-	PORT_SetError(SEC_ERROR_BAD_SIGNATURE);
-	goto cleanup; /* will return verified == SECFailure */
+        /* err is zero here. */
+        PORT_SetError(SEC_ERROR_BAD_SIGNATURE);
+        goto cleanup; /* will return verified == SECFailure */
     }
     /*
     ** FIPS 186-1, Section 6, Step 1
     **
     ** w = (s')**-1 mod q
     */
-    CHECK_MPI_OK( mp_invmod(&s_, &q, &w) );      /* w = (s')**-1 mod q */
+    CHECK_MPI_OK(mp_invmod(&s_, &q, &w)); /* w = (s')**-1 mod q */
     /*
     ** FIPS 186-1, Section 6, Step 2
     **
     ** u1 = ((Hash(M')) * w) mod q
     */
-    SECITEM_TO_MPINT(localDigest, &u1);              /* u1 = HASH(M')     */
-    CHECK_MPI_OK( mp_mulmod(&u1, &w, &q, &u1) ); /* u1 = u1 * w mod q */
+    SECITEM_TO_MPINT(localDigest, &u1);        /* u1 = HASH(M')     */
+    CHECK_MPI_OK(mp_mulmod(&u1, &w, &q, &u1)); /* u1 = u1 * w mod q */
     /*
     ** FIPS 186-1, Section 6, Step 3
     **
     ** u2 = ((r') * w) mod q
     */
-    CHECK_MPI_OK( mp_mulmod(&r_, &w, &q, &u2) );
+    CHECK_MPI_OK(mp_mulmod(&r_, &w, &q, &u2));
     /*
     ** FIPS 186-1, Section 6, Step 4
     **
     ** v = ((g**u1 * y**u2) mod p) mod q
     */
-    CHECK_MPI_OK( mp_exptmod(&g, &u1, &p, &g) ); /* g = g**u1 mod p */
-    CHECK_MPI_OK( mp_exptmod(&y, &u2, &p, &y) ); /* y = y**u2 mod p */
-    CHECK_MPI_OK(  mp_mulmod(&g, &y, &p, &v)  ); /* v = g * y mod p */
-    CHECK_MPI_OK(     mp_mod(&v, &q, &v)      ); /* v = v mod q     */
+    CHECK_MPI_OK(mp_exptmod(&g, &u1, &p, &g)); /* g = g**u1 mod p */
+    CHECK_MPI_OK(mp_exptmod(&y, &u2, &p, &y)); /* y = y**u2 mod p */
+    CHECK_MPI_OK(mp_mulmod(&g, &y, &p, &v));   /* v = g * y mod p */
+    CHECK_MPI_OK(mp_mod(&v, &q, &v));          /* v = v mod q     */
     /*
     ** Verification:  v == r'
     */
     if (mp_cmp(&v, &r_)) {
-	PORT_SetError(SEC_ERROR_BAD_SIGNATURE);
-	verified = SECFailure; /* Signature failed to verify. */
+        PORT_SetError(SEC_ERROR_BAD_SIGNATURE);
+        verified = SECFailure; /* Signature failed to verify. */
     } else {
-	verified = SECSuccess; /* Signature verified. */
+        verified = SECSuccess; /* Signature verified. */
     }
 cleanup:
     mp_clear(&p);
@@ -638,7 +641,7 @@ cleanup:
     mp_clear(&v);
     mp_clear(&w);
     if (err) {
-	translate_mpi_error(err);
+        translate_mpi_error(err);
     }
     return verified;
 }
index 18afce29c..ebe28aef5 100644
--- a/nss/lib/freebl/ec.c
+++ b/nss/lib/freebl/ec.c
@@ -6,7 +6,6 @@
 #include "stubs.h"
 #endif
 
-
 #include "blapi.h"
 #include "prerr.h"
 #include "secerr.h"
@@ -18,7 +17,7 @@
 
 #ifndef NSS_DISABLE_ECC
 
-/* 
+/*
  * Returns true if pointP is the point at infinity, false otherwise
  */
 PRBool
@@ -27,19 +26,20 @@ ec_point_at_infinity(SECItem *pointP)
     unsigned int i;
 
     for (i = 1; i < pointP->len; i++) {
-	if (pointP->data[i] != 0x00) return PR_FALSE;
+        if (pointP->data[i] != 0x00)
+            return PR_FALSE;
     }
 
     return PR_TRUE;
 }
 
-/* 
+/*
  * Computes scalar point multiplication pointQ = k1 * G + k2 * pointP for
  * the curve whose parameters are encoded in params with base point G.
  */
-SECStatus 
+SECStatus
 ec_points_mul(const ECParams *params, const mp_int *k1, const mp_int *k2,
-             const SECItem *pointP, SECItem *pointQ)
+              const SECItem *pointP, SECItem *pointQ)
 {
     mp_int Px, Py, Qx, Qy;
     mp_int Gx, Gy, order, irreducible, a, b;
@@ -53,96 +53,96 @@ ec_points_mul(const ECParams *params, const mp_int *k1, const mp_int *k2,
     char mpstr[256];
 
     printf("ec_points_mul: params [len=%d]:", params->DEREncoding.len);
-    for (i = 0; i < params->DEREncoding.len; i++) 
-	    printf("%02x:", params->DEREncoding.data[i]);
+    for (i = 0; i < params->DEREncoding.len; i++)
+        printf("%02x:", params->DEREncoding.data[i]);
     printf("\n");
 
-	if (k1 != NULL) {
-		mp_tohex((mp_int*)k1, mpstr);
-		printf("ec_points_mul: scalar k1: %s\n", mpstr);
-		mp_todecimal((mp_int*)k1, mpstr);
-		printf("ec_points_mul: scalar k1: %s (dec)\n", mpstr);
-	}
-
-	if (k2 != NULL) {
-		mp_tohex((mp_int*)k2, mpstr);
-		printf("ec_points_mul: scalar k2: %s\n", mpstr);
-		mp_todecimal((mp_int*)k2, mpstr);
-		printf("ec_points_mul: scalar k2: %s (dec)\n", mpstr);
-	}
-
-	if (pointP != NULL) {
-		printf("ec_points_mul: pointP [len=%d]:", pointP->len);
-		for (i = 0; i < pointP->len; i++) 
-			printf("%02x:", pointP->data[i]);
-		printf("\n");
-	}
+    if (k1 != NULL) {
+        mp_tohex((mp_int *)k1, mpstr);
+        printf("ec_points_mul: scalar k1: %s\n", mpstr);
+        mp_todecimal((mp_int *)k1, mpstr);
+        printf("ec_points_mul: scalar k1: %s (dec)\n", mpstr);
+    }
+
+    if (k2 != NULL) {
+        mp_tohex((mp_int *)k2, mpstr);
+        printf("ec_points_mul: scalar k2: %s\n", mpstr);
+        mp_todecimal((mp_int *)k2, mpstr);
+        printf("ec_points_mul: scalar k2: %s (dec)\n", mpstr);
+    }
+
+    if (pointP != NULL) {
+        printf("ec_points_mul: pointP [len=%d]:", pointP->len);
+        for (i = 0; i < pointP->len; i++)
+            printf("%02x:", pointP->data[i]);
+        printf("\n");
+    }
 #endif
 
-	/* NOTE: We only support uncompressed points for now */
-	len = (params->fieldID.size + 7) >> 3;
-	if (pointP != NULL) {
-		if ((pointP->data[0] != EC_POINT_FORM_UNCOMPRESSED) ||
-			(pointP->len != (2 * len + 1))) {
-			PORT_SetError(SEC_ERROR_UNSUPPORTED_EC_POINT_FORM);
-			return SECFailure;
-		};
-	}
-
-	MP_DIGITS(&Px) = 0;
-	MP_DIGITS(&Py) = 0;
-	MP_DIGITS(&Qx) = 0;
-	MP_DIGITS(&Qy) = 0;
-	MP_DIGITS(&Gx) = 0;
-	MP_DIGITS(&Gy) = 0;
-	MP_DIGITS(&order) = 0;
-	MP_DIGITS(&irreducible) = 0;
-	MP_DIGITS(&a) = 0;
-	MP_DIGITS(&b) = 0;
-	CHECK_MPI_OK( mp_init(&Px) );
-	CHECK_MPI_OK( mp_init(&Py) );
-	CHECK_MPI_OK( mp_init(&Qx) );
-	CHECK_MPI_OK( mp_init(&Qy) );
-	CHECK_MPI_OK( mp_init(&Gx) );
-	CHECK_MPI_OK( mp_init(&Gy) );
-	CHECK_MPI_OK( mp_init(&order) );
-	CHECK_MPI_OK( mp_init(&irreducible) );
-	CHECK_MPI_OK( mp_init(&a) );
-	CHECK_MPI_OK( mp_init(&b) );
-
-	if ((k2 != NULL) && (pointP != NULL)) {
-		/* Initialize Px and Py */
-		CHECK_MPI_OK( mp_read_unsigned_octets(&Px, pointP->data + 1, (mp_size) len) );
-		CHECK_MPI_OK( mp_read_unsigned_octets(&Py, pointP->data + 1 + len, (mp_size) len) );
-	}
-
-	/* construct from named params, if possible */
-	if (params->name != ECCurve_noName) {
-		group = ECGroup_fromName(params->name);
-	}
-
-	if (group == NULL)
-		goto cleanup;
-
-	if ((k2 != NULL) && (pointP != NULL)) {
-		CHECK_MPI_OK( ECPoints_mul(group, k1, k2, &Px, &Py, &Qx, &Qy) );
-	} else {
-		CHECK_MPI_OK( ECPoints_mul(group, k1, NULL, NULL, NULL, &Qx, &Qy) );
+    /* NOTE: We only support uncompressed points for now */
+    len = (params->fieldID.size + 7) >> 3;
+    if (pointP != NULL) {
+        if ((pointP->data[0] != EC_POINT_FORM_UNCOMPRESSED) ||
+            (pointP->len != (2 * len + 1))) {
+            PORT_SetError(SEC_ERROR_UNSUPPORTED_EC_POINT_FORM);
+            return SECFailure;
+        };
+    }
+
+    MP_DIGITS(&Px) = 0;
+    MP_DIGITS(&Py) = 0;
+    MP_DIGITS(&Qx) = 0;
+    MP_DIGITS(&Qy) = 0;
+    MP_DIGITS(&Gx) = 0;
+    MP_DIGITS(&Gy) = 0;
+    MP_DIGITS(&order) = 0;
+    MP_DIGITS(&irreducible) = 0;
+    MP_DIGITS(&a) = 0;
+    MP_DIGITS(&b) = 0;
+    CHECK_MPI_OK(mp_init(&Px));
+    CHECK_MPI_OK(mp_init(&Py));
+    CHECK_MPI_OK(mp_init(&Qx));
+    CHECK_MPI_OK(mp_init(&Qy));
+    CHECK_MPI_OK(mp_init(&Gx));
+    CHECK_MPI_OK(mp_init(&Gy));
+    CHECK_MPI_OK(mp_init(&order));
+    CHECK_MPI_OK(mp_init(&irreducible));
+    CHECK_MPI_OK(mp_init(&a));
+    CHECK_MPI_OK(mp_init(&b));
+
+    if ((k2 != NULL) && (pointP != NULL)) {
+        /* Initialize Px and Py */
+        CHECK_MPI_OK(mp_read_unsigned_octets(&Px, pointP->data + 1, (mp_size)len));
+        CHECK_MPI_OK(mp_read_unsigned_octets(&Py, pointP->data + 1 + len, (mp_size)len));
+    }
+
+    /* construct from named params, if possible */
+    if (params->name != ECCurve_noName) {
+        group = ECGroup_fromName(params->name);
+    }
+
+    if (group == NULL)
+        goto cleanup;
+
+    if ((k2 != NULL) && (pointP != NULL)) {
+        CHECK_MPI_OK(ECPoints_mul(group, k1, k2, &Px, &Py, &Qx, &Qy));
+    } else {
+        CHECK_MPI_OK(ECPoints_mul(group, k1, NULL, NULL, NULL, &Qx, &Qy));
     }
 
     /* Construct the SECItem representation of point Q */
     pointQ->data[0] = EC_POINT_FORM_UNCOMPRESSED;
-    CHECK_MPI_OK( mp_to_fixlen_octets(&Qx, pointQ->data + 1,
-	                              (mp_size) len) );
-    CHECK_MPI_OK( mp_to_fixlen_octets(&Qy, pointQ->data + 1 + len,
-	                              (mp_size) len) );
+    CHECK_MPI_OK(mp_to_fixlen_octets(&Qx, pointQ->data + 1,
+                                     (mp_size)len));
+    CHECK_MPI_OK(mp_to_fixlen_octets(&Qy, pointQ->data + 1 + len,
+                                     (mp_size)len));
 
     rv = SECSuccess;
 
 #if EC_DEBUG
     printf("ec_points_mul: pointQ [len=%d]:", pointQ->len);
-    for (i = 0; i < pointQ->len; i++) 
-	    printf("%02x:", pointQ->data[i]);
+    for (i = 0; i < pointQ->len; i++)
+        printf("%02x:", pointQ->data[i]);
     printf("\n");
 #endif
 
@@ -159,8 +159,8 @@ cleanup:
     mp_clear(&a);
     mp_clear(&b);
     if (err) {
-	MP_TO_SEC_ERROR(err);
-	rv = SECFailure;
+        MP_TO_SEC_ERROR(err);
+        rv = SECFailure;
     }
 
     return rv;
@@ -168,12 +168,12 @@ cleanup:
 #endif /* NSS_DISABLE_ECC */
 
 /* Generates a new EC key pair. The private key is a supplied
- * value and the public key is the result of performing a scalar 
+ * value and the public key is the result of performing a scalar
  * point multiplication of that value with the curve's base point.
  */
-SECStatus 
-ec_NewKey(ECParams *ecParams, ECPrivateKey **privKey, 
-    const unsigned char *privKeyBytes, int privKeyLen)
+SECStatus
+ec_NewKey(ECParams *ecParams, ECPrivateKey **privKey,
+          const unsigned char *privKeyBytes, int privKeyLen)
 {
     SECStatus rv = SECFailure;
 #ifndef NSS_DISABLE_ECC
@@ -215,79 +215,79 @@ ec_NewKey(ECParams *ecParams, ECPrivateKey **privKey,
     key->ecParams.fieldID.size = ecParams->fieldID.size;
     key->ecParams.fieldID.type = ecParams->fieldID.type;
     if (ecParams->fieldID.type == ec_field_GFp) {
-	CHECK_SEC_OK(SECITEM_CopyItem(arena, &key->ecParams.fieldID.u.prime,
-	    &ecParams->fieldID.u.prime));
+        CHECK_SEC_OK(SECITEM_CopyItem(arena, &key->ecParams.fieldID.u.prime,
+                                      &ecParams->fieldID.u.prime));
     } else {
-	CHECK_SEC_OK(SECITEM_CopyItem(arena, &key->ecParams.fieldID.u.poly,
-	    &ecParams->fieldID.u.poly));
+        CHECK_SEC_OK(SECITEM_CopyItem(arena, &key->ecParams.fieldID.u.poly,
+                                      &ecParams->fieldID.u.poly));
     }
     key->ecParams.fieldID.k1 = ecParams->fieldID.k1;
     key->ecParams.fieldID.k2 = ecParams->fieldID.k2;
     key->ecParams.fieldID.k3 = ecParams->fieldID.k3;
     CHECK_SEC_OK(SECITEM_CopyItem(arena, &key->ecParams.curve.a,
-	&ecParams->curve.a));
+                                  &ecParams->curve.a));
     CHECK_SEC_OK(SECITEM_CopyItem(arena, &key->ecParams.curve.b,
-	&ecParams->curve.b));
+                                  &ecParams->curve.b));
     CHECK_SEC_OK(SECITEM_CopyItem(arena, &key->ecParams.curve.seed,
-	&ecParams->curve.seed));
+                                  &ecParams->curve.seed));
     CHECK_SEC_OK(SECITEM_CopyItem(arena, &key->ecParams.base,
-	&ecParams->base));
+                                  &ecParams->base));
     CHECK_SEC_OK(SECITEM_CopyItem(arena, &key->ecParams.order,
-	&ecParams->order));
+                                  &ecParams->order));
     key->ecParams.cofactor = ecParams->cofactor;
     CHECK_SEC_OK(SECITEM_CopyItem(arena, &key->ecParams.DEREncoding,
-	&ecParams->DEREncoding));
+                                  &ecParams->DEREncoding));
     key->ecParams.name = ecParams->name;
     CHECK_SEC_OK(SECITEM_CopyItem(arena, &key->ecParams.curveOID,
-	&ecParams->curveOID));
+                                  &ecParams->curveOID));
 
     len = (ecParams->fieldID.size + 7) >> 3;
-    SECITEM_AllocItem(arena, &key->publicValue, 2*len + 1);
+    SECITEM_AllocItem(arena, &key->publicValue, 2 * len + 1);
     len = ecParams->order.len;
     SECITEM_AllocItem(arena, &key->privateValue, len);
 
     /* Copy private key */
     if (privKeyLen >= len) {
-	memcpy(key->privateValue.data, privKeyBytes, len);
+        memcpy(key->privateValue.data, privKeyBytes, len);
     } else {
-	memset(key->privateValue.data, 0, (len - privKeyLen));
-	memcpy(key->privateValue.data + (len - privKeyLen), privKeyBytes, privKeyLen);
+        memset(key->privateValue.data, 0, (len - privKeyLen));
+        memcpy(key->privateValue.data + (len - privKeyLen), privKeyBytes, privKeyLen);
     }
 
     /* Compute corresponding public key */
-    CHECK_MPI_OK( mp_init(&k) );
-    CHECK_MPI_OK( mp_read_unsigned_octets(&k, key->privateValue.data, 
-	(mp_size) len) );
+    CHECK_MPI_OK(mp_init(&k));
+    CHECK_MPI_OK(mp_read_unsigned_octets(&k, key->privateValue.data,
+                                         (mp_size)len));
 
     rv = ec_points_mul(ecParams, &k, NULL, NULL, &(key->publicValue));
-    if (rv != SECSuccess) goto cleanup;
+    if (rv != SECSuccess)
+        goto cleanup;
     *privKey = key;
 
 cleanup:
     mp_clear(&k);
     if (rv)
-	PORT_FreeArena(arena, PR_TRUE);
+        PORT_FreeArena(arena, PR_TRUE);
 
 #if EC_DEBUG
-    printf("ec_NewKey returning %s\n", 
-	(rv == SECSuccess) ? "success" : "failure");
+    printf("ec_NewKey returning %s\n",
+           (rv == SECSuccess) ? "success" : "failure");
 #endif
 #else
     PORT_SetError(SEC_ERROR_UNSUPPORTED_KEYALG);
 #endif /* NSS_DISABLE_ECC */
 
     return rv;
-
 }
 
 /* Generates a new EC key pair. The private key is a supplied
- * random value (in seed) and the public key is the result of 
- * performing a scalar point multiplication of that value with 
+ * random value (in seed) and the public key is the result of
+ * performing a scalar point multiplication of that value with
  * the curve's base point.
  */
-SECStatus 
-EC_NewKeyFromSeed(ECParams *ecParams, ECPrivateKey **privKey, 
-    const unsigned char *seed, int seedlen)
+SECStatus
+EC_NewKeyFromSeed(ECParams *ecParams, ECPrivateKey **privKey,
+                  const unsigned char *seed, int seedlen)
 {
     SECStatus rv = SECFailure;
 #ifndef NSS_DISABLE_ECC
@@ -322,35 +322,36 @@ ec_GenerateRandomPrivateKey(const unsigned char *order, int len)
     MP_DIGITS(&privKeyVal) = 0;
     MP_DIGITS(&order_1) = 0;
     MP_DIGITS(&one) = 0;
-    CHECK_MPI_OK( mp_init(&privKeyVal) );
-    CHECK_MPI_OK( mp_init(&order_1) );
-    CHECK_MPI_OK( mp_init(&one) );
+    CHECK_MPI_OK(mp_init(&privKeyVal));
+    CHECK_MPI_OK(mp_init(&order_1));
+    CHECK_MPI_OK(mp_init(&one));
 
     /* Generates 2*len random bytes using the global random bit generator
      * (which implements Algorithm 1 of FIPS 186-2 Change Notice 1) then
      * reduces modulo the group order.
      */
-    if ((privKeyBytes = PORT_Alloc(2*len)) == NULL) goto cleanup;
-    CHECK_SEC_OK( RNG_GenerateGlobalRandomBytes(privKeyBytes, 2*len) );
-    CHECK_MPI_OK( mp_read_unsigned_octets(&privKeyVal, privKeyBytes, 2*len) );
-    CHECK_MPI_OK( mp_read_unsigned_octets(&order_1, order, len) );
-    CHECK_MPI_OK( mp_set_int(&one, 1) );
-    CHECK_MPI_OK( mp_sub(&order_1, &one, &order_1) );
-    CHECK_MPI_OK( mp_mod(&privKeyVal, &order_1, &privKeyVal) );
-    CHECK_MPI_OK( mp_add(&privKeyVal, &one, &privKeyVal) );
-    CHECK_MPI_OK( mp_to_fixlen_octets(&privKeyVal, privKeyBytes, len) );
-    memset(privKeyBytes+len, 0, len);
+    if ((privKeyBytes = PORT_Alloc(2 * len)) == NULL)
+        goto cleanup;
+    CHECK_SEC_OK(RNG_GenerateGlobalRandomBytes(privKeyBytes, 2 * len));
+    CHECK_MPI_OK(mp_read_unsigned_octets(&privKeyVal, privKeyBytes, 2 * len));
+    CHECK_MPI_OK(mp_read_unsigned_octets(&order_1, order, len));
+    CHECK_MPI_OK(mp_set_int(&one, 1));
+    CHECK_MPI_OK(mp_sub(&order_1, &one, &order_1));
+    CHECK_MPI_OK(mp_mod(&privKeyVal, &order_1, &privKeyVal));
+    CHECK_MPI_OK(mp_add(&privKeyVal, &one, &privKeyVal));
+    CHECK_MPI_OK(mp_to_fixlen_octets(&privKeyVal, privKeyBytes, len));
+    memset(privKeyBytes + len, 0, len);
 cleanup:
     mp_clear(&privKeyVal);
     mp_clear(&order_1);
     mp_clear(&one);
     if (err < MP_OKAY) {
-	MP_TO_SEC_ERROR(err);
-	rv = SECFailure;
+        MP_TO_SEC_ERROR(err);
+        rv = SECFailure;
     }
     if (rv != SECSuccess && privKeyBytes) {
-	PORT_ZFree(privKeyBytes,2*len);
-	privKeyBytes = NULL;
+        PORT_ZFree(privKeyBytes, 2 * len);
+        privKeyBytes = NULL;
     }
     return privKeyBytes;
 }
@@ -360,7 +361,7 @@ cleanup:
  * the public key is the result of performing a scalar point multiplication
  * of that value with the curve's base point.
  */
-SECStatus 
+SECStatus
 EC_NewKey(ECParams *ecParams, ECPrivateKey **privKey)
 {
     SECStatus rv = SECFailure;
@@ -472,8 +474,8 @@ cleanup:
     mp_clear(&Px);
     mp_clear(&Py);
     if (err) {
-	MP_TO_SEC_ERROR(err);
-	rv = SECFailure;
+        MP_TO_SEC_ERROR(err);
+        rv = SECFailure;
     }
     return rv;
 #else
@@ -482,7 +484,7 @@ cleanup:
 #endif /* NSS_DISABLE_ECC */
 }
 
-/* 
+/*
 ** Performs an ECDH key derivation by computing the scalar point
 ** multiplication of privateValue and publicValue (with or without the
 ** cofactor) and returns the x-coordinate of the resulting elliptic
@@ -492,17 +494,17 @@ cleanup:
 ** produced. It is the caller's responsibility to free the allocated
 ** buffer containing the derived secret.
 */
-SECStatus 
-ECDH_Derive(SECItem  *publicValue, 
+SECStatus
+ECDH_Derive(SECItem *publicValue,
             ECParams *ecParams,
-            SECItem  *privateValue,
-            PRBool    withCofactor,
-            SECItem  *derivedSecret)
+            SECItem *privateValue,
+            PRBool withCofactor,
+            SECItem *derivedSecret)
 {
     SECStatus rv = SECFailure;
 #ifndef NSS_DISABLE_ECC
     unsigned int len = 0;
-    SECItem pointQ = {siBuffer, NULL, 0};
+    SECItem pointQ = { siBuffer, NULL, 0 };
     mp_int k; /* to hold the private value */
     mp_int cofactor;
     mp_err err = MP_OKAY;
@@ -521,34 +523,35 @@ ECDH_Derive(SECItem  *publicValue,
      * this produces predictable results.
      */
     if (ec_point_at_infinity(publicValue)) {
-	PORT_SetError(SEC_ERROR_BAD_KEY);
-	return SECFailure;
+        PORT_SetError(SEC_ERROR_BAD_KEY);
+        return SECFailure;
     }
 
     MP_DIGITS(&k) = 0;
     memset(derivedSecret, 0, sizeof *derivedSecret);
-    len = (ecParams->fieldID.size + 7) >> 3;  
-    pointQ.len = 2*len + 1;
-    if ((pointQ.data = PORT_Alloc(2*len + 1)) == NULL) goto cleanup;
+    len = (ecParams->fieldID.size + 7) >> 3;
+    pointQ.len = 2 * len + 1;
+    if ((pointQ.data = PORT_Alloc(2 * len + 1)) == NULL)
+        goto cleanup;
 
-    CHECK_MPI_OK( mp_init(&k) );
-    CHECK_MPI_OK( mp_read_unsigned_octets(&k, privateValue->data, 
-	                                  (mp_size) privateValue->len) );
+    CHECK_MPI_OK(mp_init(&k));
+    CHECK_MPI_OK(mp_read_unsigned_octets(&k, privateValue->data,
+                                         (mp_size)privateValue->len));
 
     if (withCofactor && (ecParams->cofactor != 1)) {
-	    /* multiply k with the cofactor */
-	    MP_DIGITS(&cofactor) = 0;
-	    CHECK_MPI_OK( mp_init(&cofactor) );
-	    mp_set(&cofactor, ecParams->cofactor);
-	    CHECK_MPI_OK( mp_mul(&k, &cofactor, &k) );
+        /* multiply k with the cofactor */
+        MP_DIGITS(&cofactor) = 0;
+        CHECK_MPI_OK(mp_init(&cofactor));
+        mp_set(&cofactor, ecParams->cofactor);
+        CHECK_MPI_OK(mp_mul(&k, &cofactor, &k));
     }
 
     /* Multiply our private key and peer's public point */
     if (ec_points_mul(ecParams, NULL, &k, publicValue, &pointQ) != SECSuccess)
-	goto cleanup;
+        goto cleanup;
     if (ec_point_at_infinity(&pointQ)) {
-	PORT_SetError(SEC_ERROR_BAD_KEY);  /* XXX better error code? */
-	goto cleanup;
+        PORT_SetError(SEC_ERROR_BAD_KEY); /* XXX better error code? */
+        goto cleanup;
     }
 
     /* Allocate memory for the derived secret and copy
@@ -561,8 +564,8 @@ ECDH_Derive(SECItem  *publicValue,
 
 #if EC_DEBUG
     printf("derived_secret:\n");
-    for (i = 0; i < derivedSecret->len; i++) 
-	printf("%02x:", derivedSecret->data[i]);
+    for (i = 0; i < derivedSecret->len; i++)
+        printf("%02x:", derivedSecret->data[i]);
     printf("\n");
 #endif
 
@@ -570,11 +573,11 @@ cleanup:
     mp_clear(&k);
 
     if (err) {
-	MP_TO_SEC_ERROR(err);
+        MP_TO_SEC_ERROR(err);
     }
 
     if (pointQ.data) {
-	PORT_ZFree(pointQ.data, 2*len + 1);
+        PORT_ZFree(pointQ.data, 2 * len + 1);
     }
 #else
     PORT_SetError(SEC_ERROR_UNSUPPORTED_KEYALG);
@@ -587,23 +590,23 @@ cleanup:
  * on the digest using the given key and the random value kb (used in
  * computing s).
  */
-SECStatus 
-ECDSA_SignDigestWithSeed(ECPrivateKey *key, SECItem *signature, 
-    const SECItem *digest, const unsigned char *kb, const int kblen)
+SECStatus
+ECDSA_SignDigestWithSeed(ECPrivateKey *key, SECItem *signature,
+                         const SECItem *digest, const unsigned char *kb, const int kblen)
 {
     SECStatus rv = SECFailure;
 #ifndef NSS_DISABLE_ECC
     mp_int x1;
-    mp_int d, k;     /* private key, random integer */
-    mp_int r, s;     /* tuple (r, s) is the signature */
-    mp_int t;        /* holding tmp values */
+    mp_int d, k; /* private key, random integer */
+    mp_int r, s; /* tuple (r, s) is the signature */
+    mp_int t;    /* holding tmp values */
     mp_int n;
     mp_err err = MP_OKAY;
     ECParams *ecParams = NULL;
-    SECItem kGpoint = { siBuffer, NULL, 0};
-    int flen = 0;    /* length in bytes of the field size */
-    unsigned olen;   /* length in bytes of the base point order */
-    unsigned obits;  /* length in bits  of the base point order */
+    SECItem kGpoint = { siBuffer, NULL, 0 };
+    int flen = 0;   /* length in bytes of the field size */
+    unsigned olen;  /* length in bytes of the base point order */
+    unsigned obits; /* length in bits  of the base point order */
     unsigned char *t2 = NULL;
 
 #if EC_DEBUG
@@ -622,46 +625,45 @@ ECDSA_SignDigestWithSeed(ECPrivateKey *key, SECItem *signature,
 
     /* Check args */
     if (!key || !signature || !digest || !kb || (kblen < 0)) {
-	PORT_SetError(SEC_ERROR_INVALID_ARGS);
-	goto cleanup;
+        PORT_SetError(SEC_ERROR_INVALID_ARGS);
+        goto cleanup;
     }
 
     ecParams = &(key->ecParams);
     flen = (ecParams->fieldID.size + 7) >> 3;
-    olen = ecParams->order.len;  
+    olen = ecParams->order.len;
     if (signature->data == NULL) {
-	/* a call to get the signature length only */
-	goto finish;
+        /* a call to get the signature length only */
+        goto finish;
     }
-    if (signature->len < 2*olen) {
-	PORT_SetError(SEC_ERROR_OUTPUT_LEN);
-	goto cleanup;
+    if (signature->len < 2 * olen) {
+        PORT_SetError(SEC_ERROR_OUTPUT_LEN);
+        goto cleanup;
     }
 
+    CHECK_MPI_OK(mp_init(&x1));
+    CHECK_MPI_OK(mp_init(&d));
+    CHECK_MPI_OK(mp_init(&k));
+    CHECK_MPI_OK(mp_init(&r));
+    CHECK_MPI_OK(mp_init(&s));
+    CHECK_MPI_OK(mp_init(&n));
+    CHECK_MPI_OK(mp_init(&t));
 
-    CHECK_MPI_OK( mp_init(&x1) );
-    CHECK_MPI_OK( mp_init(&d) );
-    CHECK_MPI_OK( mp_init(&k) );
-    CHECK_MPI_OK( mp_init(&r) );
-    CHECK_MPI_OK( mp_init(&s) );
-    CHECK_MPI_OK( mp_init(&n) );
-    CHECK_MPI_OK( mp_init(&t) );
-
-    SECITEM_TO_MPINT( ecParams->order, &n );
-    SECITEM_TO_MPINT( key->privateValue, &d );
+    SECITEM_TO_MPINT(ecParams->order, &n);
+    SECITEM_TO_MPINT(key->privateValue, &d);
 
-    CHECK_MPI_OK( mp_read_unsigned_octets(&k, kb, kblen) );
+    CHECK_MPI_OK(mp_read_unsigned_octets(&k, kb, kblen));
     /* Make sure k is in the interval [1, n-1] */
     if ((mp_cmp_z(&k) <= 0) || (mp_cmp(&k, &n) >= 0)) {
 #if EC_DEBUG
         printf("k is outside [1, n-1]\n");
         mp_tohex(&k, mpstr);
-	printf("k : %s \n", mpstr);
+        printf("k : %s \n", mpstr);
         mp_tohex(&n, mpstr);
-	printf("n : %s \n", mpstr);
+        printf("n : %s \n", mpstr);
 #endif
-	PORT_SetError(SEC_ERROR_NEED_RANDOM);
-	goto cleanup;
+        PORT_SetError(SEC_ERROR_NEED_RANDOM);
+        goto cleanup;
     }
 
     /*
@@ -680,61 +682,60 @@ ECDSA_SignDigestWithSeed(ECPrivateKey *key, SECItem *signature,
     ** final value has exactly one more bit than n.  Thus, we
     ** always end up with a value that exactly one more bit than n.
     */
-    CHECK_MPI_OK( mp_add(&k, &n, &k) );
+    CHECK_MPI_OK(mp_add(&k, &n, &k));
     if (mpl_significant_bits(&k) <= mpl_significant_bits(&n)) {
-	CHECK_MPI_OK( mp_add(&k, &n, &k) );
+        CHECK_MPI_OK(mp_add(&k, &n, &k));
     }
 
-    /* 
+    /*
     ** ANSI X9.62, Section 5.3.2, Step 2
     **
     ** Compute kG
     */
-    kGpoint.len = 2*flen + 1;
-    kGpoint.data = PORT_Alloc(2*flen + 1);
+    kGpoint.len = 2 * flen + 1;
+    kGpoint.data = PORT_Alloc(2 * flen + 1);
     if ((kGpoint.data == NULL) ||
-	(ec_points_mul(ecParams, &k, NULL, NULL, &kGpoint)
-	    != SECSuccess))
-	goto cleanup;
+        (ec_points_mul(ecParams, &k, NULL, NULL, &kGpoint) != SECSuccess))
+        goto cleanup;
 
-    /* 
+    /*
     ** ANSI X9.62, Section 5.3.3, Step 1
     **
     ** Extract the x co-ordinate of kG into x1
     */
-    CHECK_MPI_OK( mp_read_unsigned_octets(&x1, kGpoint.data + 1, 
-	                                  (mp_size) flen) );
+    CHECK_MPI_OK(mp_read_unsigned_octets(&x1, kGpoint.data + 1,
+                                         (mp_size)flen));
 
-    /* 
+    /*
     ** ANSI X9.62, Section 5.3.3, Step 2
     **
     ** r = x1 mod n  NOTE: n is the order of the curve
     */
-    CHECK_MPI_OK( mp_mod(&x1, &n, &r) );
+    CHECK_MPI_OK(mp_mod(&x1, &n, &r));
 
     /*
     ** ANSI X9.62, Section 5.3.3, Step 3
     **
-    ** verify r != 0 
+    ** verify r != 0
     */
     if (mp_cmp_z(&r) == 0) {
-	PORT_SetError(SEC_ERROR_NEED_RANDOM);
-	goto cleanup;
+        PORT_SetError(SEC_ERROR_NEED_RANDOM);
+        goto cleanup;
     }
 
-    /*                                  
+    /*
     ** ANSI X9.62, Section 5.3.3, Step 4
     **
-    ** s = (k**-1 * (HASH(M) + d*r)) mod n 
+    ** s = (k**-1 * (HASH(M) + d*r)) mod n
     */
-    SECITEM_TO_MPINT(*digest, &s);        /* s = HASH(M)     */
+    SECITEM_TO_MPINT(*digest, &s); /* s = HASH(M)     */
 
     /* In the definition of EC signing, digests are truncated
-     * to the length of n in bits. 
+     * to the length of n in bits.
      * (see SEC 1 "Elliptic Curve Digit Signature Algorithm" section 4.1.*/
-    CHECK_MPI_OK( (obits = mpl_significant_bits(&n)) );
-    if (digest->len*8 > obits) {
-	mpl_rsh(&s,&s,digest->len*8 - obits);
+    CHECK_MPI_OK((obits = mpl_significant_bits(&n)));
+    if (digest->len * 8 > obits) {
+        mpl_rsh(&s, &s, digest->len * 8 - obits);
     }
 
 #if EC_DEBUG
@@ -752,22 +753,22 @@ ECDSA_SignDigestWithSeed(ECPrivateKey *key, SECItem *signature,
     printf("r : %s\n", mpstr);
 #endif
 
-    if ((t2 = PORT_Alloc(2*ecParams->order.len)) == NULL) {
+    if ((t2 = PORT_Alloc(2 * ecParams->order.len)) == NULL) {
         rv = SECFailure;
         goto cleanup;
     }
-    if (RNG_GenerateGlobalRandomBytes(t2, 2*ecParams->order.len) != SECSuccess) {
+    if (RNG_GenerateGlobalRandomBytes(t2, 2 * ecParams->order.len) != SECSuccess) {
         PORT_SetError(SEC_ERROR_NEED_RANDOM);
         rv = SECFailure;
         goto cleanup;
     }
-    CHECK_MPI_OK( mp_read_unsigned_octets(&t, t2, 2*ecParams->order.len) ); /* t <-$ Zn */
-    CHECK_MPI_OK( mp_mulmod(&k, &t, &n, &k) ); /* k = k * t mod n */
-    CHECK_MPI_OK( mp_invmod(&k, &n, &k) );     /* k = k**-1 mod n */
-    CHECK_MPI_OK( mp_mulmod(&k, &t, &n, &k) ); /* k = k * t mod n */
-    CHECK_MPI_OK( mp_mulmod(&d, &r, &n, &d) ); /* d = d * r mod n */
-    CHECK_MPI_OK( mp_addmod(&s, &d, &n, &s) ); /* s = s + d mod n */
-    CHECK_MPI_OK( mp_mulmod(&s, &k, &n, &s) ); /* s = s * k mod n */
+    CHECK_MPI_OK(mp_read_unsigned_octets(&t, t2, 2 * ecParams->order.len)); /* t <-$ Zn */
+    CHECK_MPI_OK(mp_mulmod(&k, &t, &n, &k));                                /* k = k * t mod n */
+    CHECK_MPI_OK(mp_invmod(&k, &n, &k));                                    /* k = k**-1 mod n */
+    CHECK_MPI_OK(mp_mulmod(&k, &t, &n, &k));                                /* k = k * t mod n */
+    CHECK_MPI_OK(mp_mulmod(&d, &r, &n, &d));                                /* d = d * r mod n */
+    CHECK_MPI_OK(mp_addmod(&s, &d, &n, &s));                                /* s = s + d mod n */
+    CHECK_MPI_OK(mp_mulmod(&s, &k, &n, &s));                                /* s = s * k mod n */
 
 #if EC_DEBUG
     mp_todecimal(&s, mpstr);
@@ -782,18 +783,18 @@ ECDSA_SignDigestWithSeed(ECPrivateKey *key, SECItem *signature,
     ** verify s != 0
     */
     if (mp_cmp_z(&s) == 0) {
-	PORT_SetError(SEC_ERROR_NEED_RANDOM);
-	goto cleanup;
+        PORT_SetError(SEC_ERROR_NEED_RANDOM);
+        goto cleanup;
     }
 
-   /*
+    /*
     **
     ** Signature is tuple (r, s)
     */
-    CHECK_MPI_OK( mp_to_fixlen_octets(&r, signature->data, olen) );
-    CHECK_MPI_OK( mp_to_fixlen_octets(&s, signature->data + olen, olen) );
+    CHECK_MPI_OK(mp_to_fixlen_octets(&r, signature->data, olen));
+    CHECK_MPI_OK(mp_to_fixlen_octets(&s, signature->data + olen, olen));
 finish:
-    signature->len = 2*olen;
+    signature->len = 2 * olen;
 
     rv = SECSuccess;
     err = MP_OKAY;
@@ -811,58 +812,59 @@ cleanup:
     }
 
     if (kGpoint.data) {
-	PORT_ZFree(kGpoint.data, 2*flen + 1);
+        PORT_ZFree(kGpoint.data, 2 * flen + 1);
     }
 
     if (err) {
-	MP_TO_SEC_ERROR(err);
-	rv = SECFailure;
+        MP_TO_SEC_ERROR(err);
+        rv = SECFailure;
     }
 
 #if EC_DEBUG
     printf("ECDSA signing with seed %s\n",
-	(rv == SECSuccess) ? "succeeded" : "failed");
+           (rv == SECSuccess) ? "succeeded" : "failed");
 #endif
 #else
     PORT_SetError(SEC_ERROR_UNSUPPORTED_KEYALG);
 #endif /* NSS_DISABLE_ECC */
 
-   return rv;
+    return rv;
 }
 
 /*
-** Computes the ECDSA signature on the digest using the given key 
+** Computes the ECDSA signature on the digest using the given key
 ** and a random seed.
 */
-SECStatus 
+SECStatus
 ECDSA_SignDigest(ECPrivateKey *key, SECItem *signature, const SECItem *digest)
 {
     SECStatus rv = SECFailure;
 #ifndef NSS_DISABLE_ECC
     int len;
-    unsigned char *kBytes= NULL;
+    unsigned char *kBytes = NULL;
 
     if (!key) {
-	PORT_SetError(SEC_ERROR_INVALID_ARGS);
-	return SECFailure;
+        PORT_SetError(SEC_ERROR_INVALID_ARGS);
+        return SECFailure;
     }
 
     /* Generate random value k */
     len = key->ecParams.order.len;
     kBytes = ec_GenerateRandomPrivateKey(key->ecParams.order.data, len);
-    if (kBytes == NULL) goto cleanup;
+    if (kBytes == NULL)
+        goto cleanup;
 
     /* Generate ECDSA signature with the specified k value */
     rv = ECDSA_SignDigestWithSeed(key, signature, digest, kBytes, len);
 
-cleanup:    
+cleanup:
     if (kBytes) {
-	PORT_ZFree(kBytes, len);
+        PORT_ZFree(kBytes, len);
     }
 
 #if EC_DEBUG
     printf("ECDSA signing %s\n",
-	(rv == SECSuccess) ? "succeeded" : "failed");
+           (rv == SECSuccess) ? "succeeded" : "failed");
 #endif
 #else
     PORT_SetError(SEC_ERROR_UNSUPPORTED_KEYALG);
@@ -879,14 +881,14 @@ cleanup:
 ** of this function is undefined.  In cases where a public key might
 ** not be valid, use EC_ValidatePublicKey to check.
 */
-SECStatus 
-ECDSA_VerifyDigest(ECPublicKey *key, const SECItem *signature, 
-                 const SECItem *digest)
+SECStatus
+ECDSA_VerifyDigest(ECPublicKey *key, const SECItem *signature,
+                   const SECItem *digest)
 {
     SECStatus rv = SECFailure;
 #ifndef NSS_DISABLE_ECC
-    mp_int r_, s_;           /* tuple (r', s') is received signature) */
-    mp_int c, u1, u2, v;     /* intermediate values used in verification */
+    mp_int r_, s_;       /* tuple (r', s') is received signature) */
+    mp_int c, u1, u2, v; /* intermediate values used in verification */
     mp_int x1;
     mp_int n;
     mp_err err = MP_OKAY;
@@ -910,45 +912,45 @@ ECDSA_VerifyDigest(ECPublicKey *key, const SECItem *signature,
     MP_DIGITS(&u1) = 0;
     MP_DIGITS(&u2) = 0;
     MP_DIGITS(&x1) = 0;
-    MP_DIGITS(&v)  = 0;
-    MP_DIGITS(&n)  = 0;
+    MP_DIGITS(&v) = 0;
+    MP_DIGITS(&n) = 0;
 
     /* Check args */
     if (!key || !signature || !digest) {
-	PORT_SetError(SEC_ERROR_INVALID_ARGS);
-	goto cleanup;
+        PORT_SetError(SEC_ERROR_INVALID_ARGS);
+        goto cleanup;
     }
 
     ecParams = &(key->ecParams);
-    flen = (ecParams->fieldID.size + 7) >> 3;  
-    olen = ecParams->order.len;  
-    if (signature->len == 0 || signature->len%2 != 0 ||
-	signature->len > 2*olen) {
-	PORT_SetError(SEC_ERROR_INPUT_LEN);
-	goto cleanup;
+    flen = (ecParams->fieldID.size + 7) >> 3;
+    olen = ecParams->order.len;
+    if (signature->len == 0 || signature->len % 2 != 0 ||
+        signature->len > 2 * olen) {
+        PORT_SetError(SEC_ERROR_INPUT_LEN);
+        goto cleanup;
     }
-    slen = signature->len/2;
+    slen = signature->len / 2;
 
-    SECITEM_AllocItem(NULL, &pointC, 2*flen + 1);
+    SECITEM_AllocItem(NULL, &pointC, 2 * flen + 1);
     if (pointC.data == NULL)
-	goto cleanup;
+        goto cleanup;
 
-    CHECK_MPI_OK( mp_init(&r_) );
-    CHECK_MPI_OK( mp_init(&s_) );
-    CHECK_MPI_OK( mp_init(&c)  );
-    CHECK_MPI_OK( mp_init(&u1) );
-    CHECK_MPI_OK( mp_init(&u2) );
-    CHECK_MPI_OK( mp_init(&x1)  );
-    CHECK_MPI_OK( mp_init(&v)  );
-    CHECK_MPI_OK( mp_init(&n)  );
+    CHECK_MPI_OK(mp_init(&r_));
+    CHECK_MPI_OK(mp_init(&s_));
+    CHECK_MPI_OK(mp_init(&c));
+    CHECK_MPI_OK(mp_init(&u1));
+    CHECK_MPI_OK(mp_init(&u2));
+    CHECK_MPI_OK(mp_init(&x1));
+    CHECK_MPI_OK(mp_init(&v));
+    CHECK_MPI_OK(mp_init(&n));
 
     /*
     ** Convert received signature (r', s') into MPI integers.
     */
-    CHECK_MPI_OK( mp_read_unsigned_octets(&r_, signature->data, slen) );
-    CHECK_MPI_OK( mp_read_unsigned_octets(&s_, signature->data + slen, slen) );
-                                          
-    /* 
+    CHECK_MPI_OK(mp_read_unsigned_octets(&r_, signature->data, slen));
+    CHECK_MPI_OK(mp_read_unsigned_octets(&s_, signature->data + slen, slen));
+
+    /*
     ** ANSI X9.62, Section 5.4.2, Steps 1 and 2
     **
     ** Verify that 0 < r' < n and 0 < s' < n
@@ -956,8 +958,8 @@ ECDSA_VerifyDigest(ECPublicKey *key, const SECItem *signature,
     SECITEM_TO_MPINT(ecParams->order, &n);
     if (mp_cmp_z(&r_) <= 0 || mp_cmp_z(&s_) <= 0 ||
         mp_cmp(&r_, &n) >= 0 || mp_cmp(&s_, &n) >= 0) {
-	PORT_SetError(SEC_ERROR_BAD_SIGNATURE);
-	goto cleanup; /* will return rv == SECFailure */
+        PORT_SetError(SEC_ERROR_BAD_SIGNATURE);
+        goto cleanup; /* will return rv == SECFailure */
     }
 
     /*
@@ -965,21 +967,21 @@ ECDSA_VerifyDigest(ECPublicKey *key, const SECItem *signature,
     **
     ** c = (s')**-1 mod n
     */
-    CHECK_MPI_OK( mp_invmod(&s_, &n, &c) );      /* c = (s')**-1 mod n */
+    CHECK_MPI_OK(mp_invmod(&s_, &n, &c)); /* c = (s')**-1 mod n */
 
     /*
     ** ANSI X9.62, Section 5.4.2, Step 4
     **
     ** u1 = ((HASH(M')) * c) mod n
     */
-    SECITEM_TO_MPINT(*digest, &u1);                  /* u1 = HASH(M)     */
+    SECITEM_TO_MPINT(*digest, &u1); /* u1 = HASH(M)     */
 
     /* In the definition of EC signing, digests are truncated
-     * to the length of n in bits. 
+     * to the length of n in bits.
      * (see SEC 1 "Elliptic Curve Digit Signature Algorithm" section 4.1.*/
-    CHECK_MPI_OK( (obits = mpl_significant_bits(&n)) );
-    if (digest->len*8 > obits) {  /* u1 = HASH(M')     */
-	mpl_rsh(&u1,&u1,digest->len*8 - obits);
+    CHECK_MPI_OK((obits = mpl_significant_bits(&n)));
+    if (digest->len * 8 > obits) { /* u1 = HASH(M')     */
+        mpl_rsh(&u1, &u1, digest->len * 8 - obits);
     }
 
 #if EC_DEBUG
@@ -993,14 +995,14 @@ ECDSA_VerifyDigest(ECPublicKey *key, const SECItem *signature,
     printf("digest: %s (dec)\n", mpstr);
 #endif
 
-    CHECK_MPI_OK( mp_mulmod(&u1, &c, &n, &u1) );  /* u1 = u1 * c mod n */
+    CHECK_MPI_OK(mp_mulmod(&u1, &c, &n, &u1)); /* u1 = u1 * c mod n */
 
     /*
     ** ANSI X9.62, Section 5.4.2, Step 4
     **
     ** u2 = ((r') * c) mod n
     */
-    CHECK_MPI_OK( mp_mulmod(&r_, &c, &n, &u2) );
+    CHECK_MPI_OK(mp_mulmod(&r_, &c, &n, &u2));
 
     /*
     ** ANSI X9.62, Section 5.4.3, Step 1
@@ -1009,25 +1011,24 @@ ECDSA_VerifyDigest(ECPublicKey *key, const SECItem *signature,
     ** Here, A = u1.G     B = u2.Q    and   C = A + B
     ** If the result, C, is the point at infinity, reject the signature
     */
-    if (ec_points_mul(ecParams, &u1, &u2, &key->publicValue, &pointC)
-	!= SECSuccess) {
-	rv = SECFailure;
-	goto cleanup;
+    if (ec_points_mul(ecParams, &u1, &u2, &key->publicValue, &pointC) != SECSuccess) {
+        rv = SECFailure;
+        goto cleanup;
     }
     if (ec_point_at_infinity(&pointC)) {
-	PORT_SetError(SEC_ERROR_BAD_SIGNATURE);
-	rv = SECFailure;
-	goto cleanup;
+        PORT_SetError(SEC_ERROR_BAD_SIGNATURE);
+        rv = SECFailure;
+        goto cleanup;
     }
 
-    CHECK_MPI_OK( mp_read_unsigned_octets(&x1, pointC.data + 1, flen) );
+    CHECK_MPI_OK(mp_read_unsigned_octets(&x1, pointC.data + 1, flen));
 
     /*
     ** ANSI X9.62, Section 5.4.4, Step 2
     **
     ** v = x1 mod n
     */
-    CHECK_MPI_OK( mp_mod(&x1, &n, &v) );
+    CHECK_MPI_OK(mp_mod(&x1, &n, &v));
 
 #if EC_DEBUG
     mp_todecimal(&r_, mpstr);
@@ -1042,10 +1043,10 @@ ECDSA_VerifyDigest(ECPublicKey *key, const SECItem *signature,
     ** Verification:  v == r'
     */
     if (mp_cmp(&v, &r_)) {
-	PORT_SetError(SEC_ERROR_BAD_SIGNATURE);
-	rv = SECFailure; /* Signature failed to verify. */
+        PORT_SetError(SEC_ERROR_BAD_SIGNATURE);
+        rv = SECFailure; /* Signature failed to verify. */
     } else {
-	rv = SECSuccess; /* Signature verified. */
+        rv = SECSuccess; /* Signature verified. */
     }
 
 #if EC_DEBUG
@@ -1069,15 +1070,16 @@ cleanup:
     mp_clear(&v);
     mp_clear(&n);
 
-    if (pointC.data) SECITEM_ZfreeItem(&pointC, PR_FALSE);
+    if (pointC.data)
+        SECITEM_ZfreeItem(&pointC, PR_FALSE);
     if (err) {
-	MP_TO_SEC_ERROR(err);
-	rv = SECFailure;
+        MP_TO_SEC_ERROR(err);
+        rv = SECFailure;
     }
 
 #if EC_DEBUG
     printf("ECDSA verification %s\n",
-	(rv == SECSuccess) ? "succeeded" : "failed");
+           (rv == SECSuccess) ? "succeeded" : "failed");
 #endif
 #else
     PORT_SetError(SEC_ERROR_UNSUPPORTED_KEYALG);
@@ -1085,4 +1087,3 @@ cleanup:
 
     return rv;
 }
-
index 194f3b3fd..13a2f0266 100644
--- a/nss/lib/freebl/mpi/mpi.c
+++ b/nss/lib/freebl/mpi/mpi.c
@@ -26,7 +26,7 @@
 #if MP_LOGTAB
 /*
   A table of the logs of 2 for various bases (the 0 and 1 entries of
-  this table are meaningless and should not be referenced).  
+  this table are meaningless and should not be referenced).
 
   This table is used to compute output lengths for the mp_toradix()
   function.  Since a number n in radix r takes up about log_r(n)
@@ -36,7 +36,7 @@
   log_r(n) = log_2(n) * log_r(2)
 
   This table, therefore, is a table of log_r(2) for 2 <= r <= 36,
-  which are the output bases supported.  
+  which are the output bases supported.
  */
 #include "logtab.h"
 #endif
@@ -45,20 +45,20 @@
 
 /* Constant strings returned by mp_strerror() */
 static const char *mp_err_string[] = {
-  "unknown result code",     /* say what?            */
-  "boolean true",            /* MP_OKAY, MP_YES      */
-  "boolean false",           /* MP_NO                */
-  "out of memory",           /* MP_MEM               */
-  "argument out of range",   /* MP_RANGE             */
-  "invalid input parameter", /* MP_BADARG            */
-  "result is undefined"      /* MP_UNDEF             */
+    "unknown result code",     /* say what?            */
+    "boolean true",            /* MP_OKAY, MP_YES      */
+    "boolean false",           /* MP_NO                */
+    "out of memory",           /* MP_MEM               */
+    "argument out of range",   /* MP_RANGE             */
+    "invalid input parameter", /* MP_BADARG            */
+    "result is undefined"      /* MP_UNDEF             */
 };
 
 /* Value to digit maps for radix conversion   */
 
 /* s_dmap_1 - standard digits and letters */
-static const char *s_dmap_1 = 
-  "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+/";
+static const char *s_dmap_1 =
+    "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+/";
 
 /* }}} */
 
@@ -67,18 +67,20 @@ static const char *s_dmap_1 =
 /* Default precision for newly created mp_int's      */
 static mp_size s_mp_defprec = MP_DEFPREC;
 
-mp_size mp_get_prec(void)
+mp_size
+mp_get_prec(void)
 {
-  return s_mp_defprec;
+    return s_mp_defprec;
 
 } /* end mp_get_prec() */
 
-void         mp_set_prec(mp_size prec)
+void
+mp_set_prec(mp_size prec)
 {
-  if(prec == 0)
-    s_mp_defprec = MP_DEFPREC;
-  else
-    s_mp_defprec = prec;
+    if (prec == 0)
+        s_mp_defprec = MP_DEFPREC;
+    else
+        s_mp_defprec = prec;
 
 } /* end mp_set_prec() */
 
@@ -94,9 +96,10 @@ void         mp_set_prec(mp_size prec)
   MP_MEM if memory could not be allocated for the structure.
  */
 
-mp_err mp_init(mp_int *mp)
+mp_err
+mp_init(mp_int *mp)
 {
-  return mp_init_size(mp, s_mp_defprec);
+    return mp_init_size(mp, s_mp_defprec);
 
 } /* end mp_init() */
 
@@ -112,19 +115,20 @@ mp_err mp_init(mp_int *mp)
   not be allocated for the structure.
  */
 
-mp_err mp_init_size(mp_int *mp, mp_size prec)
+mp_err
+mp_init_size(mp_int *mp, mp_size prec)
 {
-  ARGCHK(mp != NULL && prec > 0, MP_BADARG);
+    ARGCHK(mp != NULL && prec > 0, MP_BADARG);
 
-  prec = MP_ROUNDUP(prec, s_mp_defprec);
-  if((DIGITS(mp) = s_mp_alloc(prec, sizeof(mp_digit))) == NULL)
-    return MP_MEM;
+    prec = MP_ROUNDUP(prec, s_mp_defprec);
+    if ((DIGITS(mp) = s_mp_alloc(prec, sizeof(mp_digit))) == NULL)
+        return MP_MEM;
 
-  SIGN(mp) = ZPOS;
-  USED(mp) = 1;
-  ALLOC(mp) = prec;
+    SIGN(mp) = ZPOS;
+    USED(mp) = 1;
+    ALLOC(mp) = prec;
 
-  return MP_OKAY;
+    return MP_OKAY;
 
 } /* end mp_init_size() */
 
@@ -140,22 +144,23 @@ mp_err mp_init_size(mp_int *mp, mp_size prec)
   structure.
  */
 
-mp_err mp_init_copy(mp_int *mp, const mp_int *from)
+mp_err
+mp_init_copy(mp_int *mp, const mp_int *from)
 {
-  ARGCHK(mp != NULL && from != NULL, MP_BADARG);
+    ARGCHK(mp != NULL && from != NULL, MP_BADARG);
 
-  if(mp == from)
-    return MP_OKAY;
+    if (mp == from)
+        return MP_OKAY;
 
-  if((DIGITS(mp) = s_mp_alloc(ALLOC(from), sizeof(mp_digit))) == NULL)
-    return MP_MEM;
+    if ((DIGITS(mp) = s_mp_alloc(ALLOC(from), sizeof(mp_digit))) == NULL)
+        return MP_MEM;
 
-  s_mp_copy(DIGITS(from), DIGITS(mp), USED(from));
-  USED(mp) = USED(from);
-  ALLOC(mp) = ALLOC(from);
-  SIGN(mp) = SIGN(from);
+    s_mp_copy(DIGITS(from), DIGITS(mp), USED(from));
+    USED(mp) = USED(from);
+    ALLOC(mp) = ALLOC(from);
+    SIGN(mp) = SIGN(from);
 
-  return MP_OKAY;
+    return MP_OKAY;
 
 } /* end mp_init_copy() */
 
@@ -171,48 +176,49 @@ mp_err mp_init_copy(mp_int *mp, const mp_int *from)
   instead). If 'from' and 'to' are identical, nothing happens.
  */
 
-mp_err mp_copy(const mp_int *from, mp_int *to)
+mp_err
+mp_copy(const mp_int *from, mp_int *to)
 {
-  ARGCHK(from != NULL && to != NULL, MP_BADARG);
+    ARGCHK(from != NULL && to != NULL, MP_BADARG);
 
-  if(from == to)
-    return MP_OKAY;
+    if (from == to)
+        return MP_OKAY;
 
-  { /* copy */
-    mp_digit   *tmp;
+    { /* copy */
+        mp_digit *tmp;
 
-    /*
-      If the allocated buffer in 'to' already has enough space to hold
-      all the used digits of 'from', we'll re-use it to avoid hitting
-      the memory allocater more than necessary; otherwise, we'd have
-      to grow anyway, so we just allocate a hunk and make the copy as
-      usual
-     */
-    if(ALLOC(to) >= USED(from)) {
-      s_mp_setz(DIGITS(to) + USED(from), ALLOC(to) - USED(from));
-      s_mp_copy(DIGITS(from), DIGITS(to), USED(from));
-      
-    } else {
-      if((tmp = s_mp_alloc(ALLOC(from), sizeof(mp_digit))) == NULL)
-	return MP_MEM;
+        /*
+          If the allocated buffer in 'to' already has enough space to hold
+          all the used digits of 'from', we'll re-use it to avoid hitting
+          the memory allocater more than necessary; otherwise, we'd have
+          to grow anyway, so we just allocate a hunk and make the copy as
+          usual
+         */
+        if (ALLOC(to) >= USED(from)) {
+            s_mp_setz(DIGITS(to) + USED(from), ALLOC(to) - USED(from));
+            s_mp_copy(DIGITS(from), DIGITS(to), USED(from));
 
-      s_mp_copy(DIGITS(from), tmp, USED(from));
+        } else {
+            if ((tmp = s_mp_alloc(ALLOC(from), sizeof(mp_digit))) == NULL)
+                return MP_MEM;
 
-      if(DIGITS(to) != NULL) {
-	s_mp_setz(DIGITS(to), ALLOC(to));
-	s_mp_free(DIGITS(to));
-      }
+            s_mp_copy(DIGITS(from), tmp, USED(from));
 
-      DIGITS(to) = tmp;
-      ALLOC(to) = ALLOC(from);
-    }
+            if (DIGITS(to) != NULL) {
+                s_mp_setz(DIGITS(to), ALLOC(to));
+                s_mp_free(DIGITS(to));
+            }
+
+            DIGITS(to) = tmp;
+            ALLOC(to) = ALLOC(from);
+        }
 
-    /* Copy the precision and sign from the original */
-    USED(to) = USED(from);
-    SIGN(to) = SIGN(from);
-  } /* end copy */
+        /* Copy the precision and sign from the original */
+        USED(to) = USED(from);
+        SIGN(to) = SIGN(from);
+    } /* end copy */
 
-  return MP_OKAY;
+    return MP_OKAY;
 
 } /* end mp_copy() */
 
@@ -228,16 +234,17 @@ mp_err mp_copy(const mp_int *from, mp_int *to)
   locals it creates...).  This cannot fail.
  */
 
-void mp_exch(mp_int *mp1, mp_int *mp2)
+void
+mp_exch(mp_int *mp1, mp_int *mp2)
 {
 #if MP_ARGCHK == 2
-  assert(mp1 != NULL && mp2 != NULL);
+    assert(mp1 != NULL && mp2 != NULL);
 #else
-  if(mp1 == NULL || mp2 == NULL)
-    return;
+    if (mp1 == NULL || mp2 == NULL)
+        return;
 #endif
 
-  s_mp_exch(mp1, mp2);
+    s_mp_exch(mp1, mp2);
 
 } /* end mp_exch() */
 
@@ -253,19 +260,20 @@ void mp_exch(mp_int *mp1, mp_int *mp2)
   get tollchocked.
  */
 
-void   mp_clear(mp_int *mp)
+void
+mp_clear(mp_int *mp)
 {
-  if(mp == NULL)
-    return;
+    if (mp == NULL)
+        return;
 
-  if(DIGITS(mp) != NULL) {
-    s_mp_setz(DIGITS(mp), ALLOC(mp));
-    s_mp_free(DIGITS(mp));
-    DIGITS(mp) = NULL;
-  }
+    if (DIGITS(mp) != NULL) {
+        s_mp_setz(DIGITS(mp), ALLOC(mp));
+        s_mp_free(DIGITS(mp));
+        DIGITS(mp) = NULL;
+    }
 
-  USED(mp) = 0;
-  ALLOC(mp) = 0;
+    USED(mp) = 0;
+    ALLOC(mp) = 0;
 
 } /* end mp_clear() */
 
@@ -274,19 +282,20 @@ void   mp_clear(mp_int *mp)
 /* {{{ mp_zero(mp) */
 
 /*
-  mp_zero(mp) 
+  mp_zero(mp)
 
   Set mp to zero.  Does not change the allocated size of the structure,
   and therefore cannot fail (except on a bad argument, which we ignore)
  */
-void   mp_zero(mp_int *mp)
+void
+mp_zero(mp_int *mp)
 {
-  if(mp == NULL)
-    return;
+    if (mp == NULL)
+        return;
 
-  s_mp_setz(DIGITS(mp), ALLOC(mp));
-  USED(mp) = 1;
-  SIGN(mp) = ZPOS;
+    s_mp_setz(DIGITS(mp), ALLOC(mp));
+    USED(mp) = 1;
+    SIGN(mp) = ZPOS;
 
 } /* end mp_zero() */
 
@@ -294,13 +303,14 @@ void   mp_zero(mp_int *mp)
 
 /* {{{ mp_set(mp, d) */
 
-void   mp_set(mp_int *mp, mp_digit d)
+void
+mp_set(mp_int *mp, mp_digit d)
 {
-  if(mp == NULL)
-    return;
+    if (mp == NULL)
+        return;
 
-  mp_zero(mp);
-  DIGIT(mp, 0) = d;
+    mp_zero(mp);
+    DIGIT(mp, 0) = d;
 
 } /* end mp_set() */
 
@@ -308,34 +318,35 @@ void   mp_set(mp_int *mp, mp_digit d)
 
 /* {{{ mp_set_int(mp, z) */
 
-mp_err mp_set_int(mp_int *mp, long z)
+mp_err
+mp_set_int(mp_int *mp, long z)
 {
-  int            ix;
-  unsigned long  v = labs(z);
-  mp_err         res;
+    int ix;
+    unsigned long v = labs(z);
+    mp_err res;
 
-  ARGCHK(mp != NULL, MP_BADARG);
+    ARGCHK(mp != NULL, MP_BADARG);
 
-  mp_zero(mp);
-  if(z == 0)
-    return MP_OKAY;  /* shortcut for zero */
+    mp_zero(mp);
+    if (z == 0)
+        return MP_OKAY; /* shortcut for zero */
 
-  if (sizeof v <= sizeof(mp_digit)) {
-    DIGIT(mp,0) = v;
-  } else {
-    for (ix = sizeof(long) - 1; ix >= 0; ix--) {
-      if ((res = s_mp_mul_d(mp, (UCHAR_MAX + 1))) != MP_OKAY)
-	return res;
-
-      res = s_mp_add_d(mp, (mp_digit)((v >> (ix * CHAR_BIT)) & UCHAR_MAX));
-      if (res != MP_OKAY)
-	return res;
+    if (sizeof v <= sizeof(mp_digit)) {
+        DIGIT(mp, 0) = v;
+    } else {
+        for (ix = sizeof(long) - 1; ix >= 0; ix--) {
+            if ((res = s_mp_mul_d(mp, (UCHAR_MAX + 1))) != MP_OKAY)
+                return res;
+
+            res = s_mp_add_d(mp, (mp_digit)((v >> (ix * CHAR_BIT)) & UCHAR_MAX));
+            if (res != MP_OKAY)
+                return res;
+        }
     }
-  }
-  if(z < 0)
-    SIGN(mp) = NEG;
+    if (z < 0)
+        SIGN(mp) = NEG;
 
-  return MP_OKAY;
+    return MP_OKAY;
 
 } /* end mp_set_int() */
 
@@ -343,30 +354,31 @@ mp_err mp_set_int(mp_int *mp, long z)
 
 /* {{{ mp_set_ulong(mp, z) */
 
-mp_err mp_set_ulong(mp_int *mp, unsigned long z)
+mp_err
+mp_set_ulong(mp_int *mp, unsigned long z)
 {
-  int            ix;
-  mp_err         res;
-
-  ARGCHK(mp != NULL, MP_BADARG);
+    int ix;
+    mp_err res;
 
-  mp_zero(mp);
-  if(z == 0)
-    return MP_OKAY;  /* shortcut for zero */
+    ARGCHK(mp != NULL, MP_BADARG);
 
-  if (sizeof z <= sizeof(mp_digit)) {
-    DIGIT(mp,0) = z;
-  } else {
-    for (ix = sizeof(long) - 1; ix >= 0; ix--) {
-      if ((res = s_mp_mul_d(mp, (UCHAR_MAX + 1))) != MP_OKAY)
-	return res;
+    mp_zero(mp);
+    if (z == 0)
+        return MP_OKAY; /* shortcut for zero */
 
-      res = s_mp_add_d(mp, (mp_digit)((z >> (ix * CHAR_BIT)) & UCHAR_MAX));
-      if (res != MP_OKAY)
-	return res;
+    if (sizeof z <= sizeof(mp_digit)) {
+        DIGIT(mp, 0) = z;
+    } else {
+        for (ix = sizeof(long) - 1; ix >= 0; ix--) {
+            if ((res = s_mp_mul_d(mp, (UCHAR_MAX + 1))) != MP_OKAY)
+                return res;
+
+            res = s_mp_add_d(mp, (mp_digit)((z >> (ix * CHAR_BIT)) & UCHAR_MAX));
+            if (res != MP_OKAY)
+                return res;
+        }
     }
-  }
-  return MP_OKAY;
+    return MP_OKAY;
 } /* end mp_set_ulong() */
 
 /* }}} */
@@ -383,36 +395,37 @@ mp_err mp_set_ulong(mp_int *mp, unsigned long z)
   its primary addend (single digits are unsigned anyway).
  */
 
-mp_err mp_add_d(const mp_int *a, mp_digit d, mp_int *b)
+mp_err
+mp_add_d(const mp_int *a, mp_digit d, mp_int *b)
 {
-  mp_int   tmp;
-  mp_err   res;
+    mp_int tmp;
+    mp_err res;
 
-  ARGCHK(a != NULL && b != NULL, MP_BADARG);
+    ARGCHK(a != NULL && b != NULL, MP_BADARG);
 
-  if((res = mp_init_copy(&tmp, a)) != MP_OKAY)
-    return res;
+    if ((res = mp_init_copy(&tmp, a)) != MP_OKAY)
+        return res;
 
-  if(SIGN(&tmp) == ZPOS) {
-    if((res = s_mp_add_d(&tmp, d)) != MP_OKAY)
-      goto CLEANUP;
-  } else if(s_mp_cmp_d(&tmp, d) >= 0) {
-    if((res = s_mp_sub_d(&tmp, d)) != MP_OKAY)
-      goto CLEANUP;
-  } else {
-    mp_neg(&tmp, &tmp);
+    if (SIGN(&tmp) == ZPOS) {
+        if ((res = s_mp_add_d(&tmp, d)) != MP_OKAY)
+            goto CLEANUP;
+    } else if (s_mp_cmp_d(&tmp, d) >= 0) {
+        if ((res = s_mp_sub_d(&tmp, d)) != MP_OKAY)
+            goto CLEANUP;
+    } else {
+        mp_neg(&tmp, &tmp);
 
-    DIGIT(&tmp, 0) = d - DIGIT(&tmp, 0);
-  }
+        DIGIT(&tmp, 0) = d - DIGIT(&tmp, 0);
+    }
 
-  if(s_mp_cmp_d(&tmp, 0) == 0)
-    SIGN(&tmp) = ZPOS;
+    if (s_mp_cmp_d(&tmp, 0) == 0)
+        SIGN(&tmp) = ZPOS;
 
-  s_mp_exch(&tmp, b);
+    s_mp_exch(&tmp, b);
 
 CLEANUP:
-  mp_clear(&tmp);
-  return res;
+    mp_clear(&tmp);
+    return res;
 
 } /* end mp_add_d() */
 
@@ -427,37 +440,38 @@ CLEANUP:
   sign of its subtrahend (single digits are unsigned anyway).
  */
 
-mp_err mp_sub_d(const mp_int *a, mp_digit d, mp_int *b)
+mp_err
+mp_sub_d(const mp_int *a, mp_digit d, mp_int *b)
 {
-  mp_int   tmp;
-  mp_err   res;
+    mp_int tmp;
+    mp_err res;
 
-  ARGCHK(a != NULL && b != NULL, MP_BADARG);
+    ARGCHK(a != NULL && b != NULL, MP_BADARG);
 
-  if((res = mp_init_copy(&tmp, a)) != MP_OKAY)
-    return res;
+    if ((res = mp_init_copy(&tmp, a)) != MP_OKAY)
+        return res;
 
-  if(SIGN(&tmp) == NEG) {
-    if((res = s_mp_add_d(&tmp, d)) != MP_OKAY)
-      goto CLEANUP;
-  } else if(s_mp_cmp_d(&tmp, d) >= 0) {
-    if((res = s_mp_sub_d(&tmp, d)) != MP_OKAY)
-      goto CLEANUP;
-  } else {
-    mp_neg(&tmp, &tmp);
+    if (SIGN(&tmp) == NEG) {
+        if ((res = s_mp_add_d(&tmp, d)) != MP_OKAY)
+            goto CLEANUP;
+    } else if (s_mp_cmp_d(&tmp, d) >= 0) {
+        if ((res = s_mp_sub_d(&tmp, d)) != MP_OKAY)
+            goto CLEANUP;
+    } else {
+        mp_neg(&tmp, &tmp);
 
-    DIGIT(&tmp, 0) = d - DIGIT(&tmp, 0);
-    SIGN(&tmp) = NEG;
-  }
+        DIGIT(&tmp, 0) = d - DIGIT(&tmp, 0);
+        SIGN(&tmp) = NEG;
+    }
 
-  if(s_mp_cmp_d(&tmp, 0) == 0)
-    SIGN(&tmp) = ZPOS;
+    if (s_mp_cmp_d(&tmp, 0) == 0)
+        SIGN(&tmp) = ZPOS;
 
-  s_mp_exch(&tmp, b);
+    s_mp_exch(&tmp, b);
 
 CLEANUP:
-  mp_clear(&tmp);
-  return res;
+    mp_clear(&tmp);
+    return res;
 
 } /* end mp_sub_d() */
 
@@ -472,23 +486,24 @@ CLEANUP:
   of its multiplicand (single digits are unsigned anyway)
  */
 
-mp_err mp_mul_d(const mp_int *a, mp_digit d, mp_int *b)
+mp_err
+mp_mul_d(const mp_int *a, mp_digit d, mp_int *b)
 {
-  mp_err  res;
+    mp_err res;
 
-  ARGCHK(a != NULL && b != NULL, MP_BADARG);
+    ARGCHK(a != NULL && b != NULL, MP_BADARG);
 
-  if(d == 0) {
-    mp_zero(b);
-    return MP_OKAY;
-  }
+    if (d == 0) {
+        mp_zero(b);
+        return MP_OKAY;
+    }
 
-  if((res = mp_copy(a, b)) != MP_OKAY)
-    return res;
+    if ((res = mp_copy(a, b)) != MP_OKAY)
+        return res;
 
-  res = s_mp_mul_d(b, d);
+    res = s_mp_mul_d(b, d);
 
-  return res;
+    return res;
 
 } /* end mp_mul_d() */
 
@@ -496,16 +511,17 @@ mp_err mp_mul_d(const mp_int *a, mp_digit d, mp_int *b)
 
 /* {{{ mp_mul_2(a, c) */
 
-mp_err mp_mul_2(const mp_int *a, mp_int *c)
+mp_err
+mp_mul_2(const mp_int *a, mp_int *c)
 {
-  mp_err  res;
+    mp_err res;
 
-  ARGCHK(a != NULL && c != NULL, MP_BADARG);
+    ARGCHK(a != NULL && c != NULL, MP_BADARG);
 
-  if((res = mp_copy(a, c)) != MP_OKAY)
-    return res;
+    if ((res = mp_copy(a, c)) != MP_OKAY)
+        return res;
 
-  return s_mp_mul_2(c);
+    return s_mp_mul_2(c);
 
 } /* end mp_mul_2() */
 
@@ -521,55 +537,56 @@ mp_err mp_mul_2(const mp_int *a, mp_int *c)
   unsigned anyway).
  */
 
-mp_err mp_div_d(const mp_int *a, mp_digit d, mp_int *q, mp_digit *r)
+mp_err
+mp_div_d(const mp_int *a, mp_digit d, mp_int *q, mp_digit *r)
 {
-  mp_err   res;
-  mp_int   qp;
-  mp_digit rem = 0;
-  int      pow;
+    mp_err res;
+    mp_int qp;
+    mp_digit rem = 0;
+    int pow;
 
-  ARGCHK(a != NULL, MP_BADARG);
+    ARGCHK(a != NULL, MP_BADARG);
 
-  if(d == 0)
-    return MP_RANGE;
+    if (d == 0)
+        return MP_RANGE;
 
-  /* Shortcut for powers of two ... */
-  if((pow = s_mp_ispow2d(d)) >= 0) {
-    mp_digit  mask;
+    /* Shortcut for powers of two ... */
+    if ((pow = s_mp_ispow2d(d)) >= 0) {
+        mp_digit mask;
 
-    mask = ((mp_digit)1 << pow) - 1;
-    rem = DIGIT(a, 0) & mask;
+        mask = ((mp_digit)1 << pow) - 1;
+        rem = DIGIT(a, 0) & mask;
 
-    if(q) {
-      if((res = mp_copy(a, q)) != MP_OKAY) {
-        return res;
-      }
-      s_mp_div_2d(q, pow);
-    }
+        if (q) {
+            if ((res = mp_copy(a, q)) != MP_OKAY) {
+                return res;
+            }
+            s_mp_div_2d(q, pow);
+        }
 
-    if(r)
-      *r = rem;
+        if (r)
+            *r = rem;
 
-    return MP_OKAY;
-  }
+        return MP_OKAY;
+    }
 
-  if((res = mp_init_copy(&qp, a)) != MP_OKAY)
-    return res;
+    if ((res = mp_init_copy(&qp, a)) != MP_OKAY)
+        return res;
 
-  res = s_mp_div_d(&qp, d, &rem);
+    res = s_mp_div_d(&qp, d, &rem);
 
-  if(s_mp_cmp_d(&qp, 0) == 0)
-    SIGN(q) = ZPOS;
+    if (s_mp_cmp_d(&qp, 0) == 0)
+        SIGN(q) = ZPOS;
 
-  if(r) {
-    *r = rem;
-  }
+    if (r) {
+        *r = rem;
+    }
 
-  if(q)
-    s_mp_exch(&qp, q);
+    if (q)
+        s_mp_exch(&qp, q);
 
-  mp_clear(&qp);
-  return res;
+    mp_clear(&qp);
+    return res;
 
 } /* end mp_div_d() */
 
@@ -583,18 +600,19 @@ mp_err mp_div_d(const mp_int *a, mp_digit d, mp_int *q, mp_digit *r)
   Compute c = a / 2, disregarding the remainder.
  */
 
-mp_err mp_div_2(const mp_int *a, mp_int *c)
+mp_err
+mp_div_2(const mp_int *a, mp_int *c)
 {
-  mp_err  res;
+    mp_err res;
 
-  ARGCHK(a != NULL && c != NULL, MP_BADARG);
+    ARGCHK(a != NULL && c != NULL, MP_BADARG);
 
-  if((res = mp_copy(a, c)) != MP_OKAY)
-    return res;
+    if ((res = mp_copy(a, c)) != MP_OKAY)
+        return res;
 
-  s_mp_div_2(c);
+    s_mp_div_2(c);
 
-  return MP_OKAY;
+    return MP_OKAY;
 
 } /* end mp_div_2() */
 
@@ -602,40 +620,41 @@ mp_err mp_div_2(const mp_int *a, mp_int *c)
 
 /* {{{ mp_expt_d(a, d, b) */
 
-mp_err mp_expt_d(const mp_int *a, mp_digit d, mp_int *c)
+mp_err
+mp_expt_d(const mp_int *a, mp_digit d, mp_int *c)
 {
-  mp_int   s, x;
-  mp_err   res;
+    mp_int s, x;
+    mp_err res;
 
-  ARGCHK(a != NULL && c != NULL, MP_BADARG);
+    ARGCHK(a != NULL && c != NULL, MP_BADARG);
 
-  if((res = mp_init(&s)) != MP_OKAY)
-    return res;
-  if((res = mp_init_copy(&x, a)) != MP_OKAY)
-    goto X;
+    if ((res = mp_init(&s)) != MP_OKAY)
+        return res;
+    if ((res = mp_init_copy(&x, a)) != MP_OKAY)
+        goto X;
 
-  DIGIT(&s, 0) = 1;
+    DIGIT(&s, 0) = 1;
 
-  while(d != 0) {
-    if(d & 1) {
-      if((res = s_mp_mul(&s, &x)) != MP_OKAY)
-	goto CLEANUP;
-    }
+    while (d != 0) {
+        if (d & 1) {
+            if ((res = s_mp_mul(&s, &x)) != MP_OKAY)
+                goto CLEANUP;
+        }
 
-    d /= 2;
+        d /= 2;
 
-    if((res = s_mp_sqr(&x)) != MP_OKAY)
-      goto CLEANUP;
-  }
+        if ((res = s_mp_sqr(&x)) != MP_OKAY)
+            goto CLEANUP;
+    }
 
-  s_mp_exch(&s, c);
+    s_mp_exch(&s, c);
 
 CLEANUP:
-  mp_clear(&x);
+    mp_clear(&x);
 X:
-  mp_clear(&s);
+    mp_clear(&s);
 
-  return res;
+    return res;
 
 } /* end mp_expt_d() */
 
@@ -654,18 +673,19 @@ X:
   Compute b = |a|.  'a' and 'b' may be identical.
  */
 
-mp_err mp_abs(const mp_int *a, mp_int *b)
+mp_err
+mp_abs(const mp_int *a, mp_int *b)
 {
-  mp_err   res;
+    mp_err res;
 
-  ARGCHK(a != NULL && b != NULL, MP_BADARG);
+    ARGCHK(a != NULL && b != NULL, MP_BADARG);
 
-  if((res = mp_copy(a, b)) != MP_OKAY)
-    return res;
+    if ((res = mp_copy(a, b)) != MP_OKAY)
+        return res;
 
-  SIGN(b) = ZPOS;
+    SIGN(b) = ZPOS;
 
-  return MP_OKAY;
+    return MP_OKAY;
 
 } /* end mp_abs() */
 
@@ -679,21 +699,22 @@ mp_err mp_abs(const mp_int *a, mp_int *b)
   Compute b = -a.  'a' and 'b' may be identical.
  */
 
-mp_err mp_neg(const mp_int *a, mp_int *b)
+mp_err
+mp_neg(const mp_int *a, mp_int *b)
 {
-  mp_err   res;
+    mp_err res;
 
-  ARGCHK(a != NULL && b != NULL, MP_BADARG);
+    ARGCHK(a != NULL && b != NULL, MP_BADARG);
 
-  if((res = mp_copy(a, b)) != MP_OKAY)
-    return res;
+    if ((res = mp_copy(a, b)) != MP_OKAY)
+        return res;
 
-  if(s_mp_cmp_d(b, 0) == MP_EQ) 
-    SIGN(b) = ZPOS;
-  else 
-    SIGN(b) = (SIGN(b) == NEG) ? ZPOS : NEG;
+    if (s_mp_cmp_d(b, 0) == MP_EQ)
+        SIGN(b) = ZPOS;
+    else
+        SIGN(b) = (SIGN(b) == NEG) ? ZPOS : NEG;
 
-  return MP_OKAY;
+    return MP_OKAY;
 
 } /* end mp_neg() */
 
@@ -707,25 +728,26 @@ mp_err mp_neg(const mp_int *a, mp_int *b)
   Compute c = a + b.  All parameters may be identical.
  */
 
-mp_err mp_add(const mp_int *a, const mp_int *b, mp_int *c)
+mp_err
+mp_add(const mp_int *a, const mp_int *b, mp_int *c)
 {
-  mp_err  res;
+    mp_err res;
 
-  ARGCHK(a != NULL && b != NULL && c != NULL, MP_BADARG);
+    ARGCHK(a != NULL && b != NULL && c != NULL, MP_BADARG);
 
-  if(SIGN(a) == SIGN(b)) { /* same sign:  add values, keep sign */
-    MP_CHECKOK( s_mp_add_3arg(a, b, c) );
-  } else if(s_mp_cmp(a, b) >= 0) {  /* different sign: |a| >= |b|   */
-    MP_CHECKOK( s_mp_sub_3arg(a, b, c) );
-  } else {                          /* different sign: |a|  < |b|   */
-    MP_CHECKOK( s_mp_sub_3arg(b, a, c) );
-  }
+    if (SIGN(a) == SIGN(b)) { /* same sign:  add values, keep sign */
+        MP_CHECKOK(s_mp_add_3arg(a, b, c));
+    } else if (s_mp_cmp(a, b) >= 0) { /* different sign: |a| >= |b|   */
+        MP_CHECKOK(s_mp_sub_3arg(a, b, c));
+    } else { /* different sign: |a|  < |b|   */
+        MP_CHECKOK(s_mp_sub_3arg(b, a, c));
+    }
 
-  if (s_mp_cmp_d(c, 0) == MP_EQ)
-    SIGN(c) = ZPOS;
+    if (s_mp_cmp_d(c, 0) == MP_EQ)
+        SIGN(c) = ZPOS;
 
 CLEANUP:
-  return res;
+    return res;
 
 } /* end mp_add() */
 
@@ -739,35 +761,36 @@ CLEANUP:
   Compute c = a - b.  All parameters may be identical.
  */
 
-mp_err mp_sub(const mp_int *a, const mp_int *b, mp_int *c)
+mp_err
+mp_sub(const mp_int *a, const mp_int *b, mp_int *c)
 {
-  mp_err  res;
-  int     magDiff;
+    mp_err res;
+    int magDiff;
 
-  ARGCHK(a != NULL && b != NULL && c != NULL, MP_BADARG);
+    ARGCHK(a != NULL && b != NULL && c != NULL, MP_BADARG);
 
-  if (a == b) {
-    mp_zero(c);
-    return MP_OKAY;
-  }
+    if (a == b) {
+        mp_zero(c);
+        return MP_OKAY;
+    }
 
-  if (MP_SIGN(a) != MP_SIGN(b)) {
-    MP_CHECKOK( s_mp_add_3arg(a, b, c) );
-  } else if (!(magDiff = s_mp_cmp(a, b))) {
-    mp_zero(c);
-    res = MP_OKAY;
-  } else if (magDiff > 0) {
-    MP_CHECKOK( s_mp_sub_3arg(a, b, c) );
-  } else {
-    MP_CHECKOK( s_mp_sub_3arg(b, a, c) );
-    MP_SIGN(c) = !MP_SIGN(a);
-  }
+    if (MP_SIGN(a) != MP_SIGN(b)) {
+        MP_CHECKOK(s_mp_add_3arg(a, b, c));
+    } else if (!(magDiff = s_mp_cmp(a, b))) {
+        mp_zero(c);
+        res = MP_OKAY;
+    } else if (magDiff > 0) {
+        MP_CHECKOK(s_mp_sub_3arg(a, b, c));
+    } else {
+        MP_CHECKOK(s_mp_sub_3arg(b, a, c));
+        MP_SIGN(c) = !MP_SIGN(a);
+    }
 
-  if (s_mp_cmp_d(c, 0) == MP_EQ)
-    MP_SIGN(c) = MP_ZPOS;
+    if (s_mp_cmp_d(c, 0) == MP_EQ)
+        MP_SIGN(c) = MP_ZPOS;
 
 CLEANUP:
-  return res;
+    return res;
 
 } /* end mp_sub() */
 
@@ -780,87 +803,89 @@ CLEANUP:
 
   Compute c = a * b.  All parameters may be identical.
  */
-mp_err   mp_mul(const mp_int *a, const mp_int *b, mp_int * c)
+mp_err
+mp_mul(const mp_int *a, const mp_int *b, mp_int *c)
 {
-  mp_digit *pb;
-  mp_int   tmp;
-  mp_err   res;
-  mp_size  ib;
-  mp_size  useda, usedb;
-
-  ARGCHK(a != NULL && b != NULL && c != NULL, MP_BADARG);
-
-  if (a == c) {
-    if ((res = mp_init_copy(&tmp, a)) != MP_OKAY)
-      return res;
-    if (a == b) 
-      b = &tmp;
-    a = &tmp;
-  } else if (b == c) {
-    if ((res = mp_init_copy(&tmp, b)) != MP_OKAY)
-      return res;
-    b = &tmp;
-  } else {
-    MP_DIGITS(&tmp) = 0;
-  }
+    mp_digit *pb;
+    mp_int tmp;
+    mp_err res;
+    mp_size ib;
+    mp_size useda, usedb;
+
+    ARGCHK(a != NULL && b != NULL && c != NULL, MP_BADARG);
+
+    if (a == c) {
+        if ((res = mp_init_copy(&tmp, a)) != MP_OKAY)
+            return res;
+        if (a == b)
+            b = &tmp;
+        a = &tmp;
+    } else if (b == c) {
+        if ((res = mp_init_copy(&tmp, b)) != MP_OKAY)
+            return res;
+        b = &tmp;
+    } else {
+        MP_DIGITS(&tmp) = 0;
+    }
 
-  if (MP_USED(a) < MP_USED(b)) {
-    const mp_int *xch = b;	/* switch a and b, to do fewer outer loops */
-    b = a;
-    a = xch;
-  }
+    if (MP_USED(a) < MP_USED(b)) {
+        const mp_int *xch = b; /* switch a and b, to do fewer outer loops */
+        b = a;
+        a = xch;
+    }
 
-  MP_USED(c) = 1; MP_DIGIT(c, 0) = 0;
-  if((res = s_mp_pad(c, USED(a) + USED(b))) != MP_OKAY)
-    goto CLEANUP;
+    MP_USED(c) = 1;
+    MP_DIGIT(c, 0) = 0;
+    if ((res = s_mp_pad(c, USED(a) + USED(b))) != MP_OKAY)
+        goto CLEANUP;
 
 #ifdef NSS_USE_COMBA
-  if ((MP_USED(a) == MP_USED(b)) && IS_POWER_OF_2(MP_USED(b))) {
-      if (MP_USED(a) == 4) {
-          s_mp_mul_comba_4(a, b, c);
-          goto CLEANUP;
-      }
-      if (MP_USED(a) == 8) {
-          s_mp_mul_comba_8(a, b, c);
-          goto CLEANUP;
-      }
-      if (MP_USED(a) == 16) {
-          s_mp_mul_comba_16(a, b, c);
-          goto CLEANUP;
-      }
-      if (MP_USED(a) == 32) {
-          s_mp_mul_comba_32(a, b, c);
-          goto CLEANUP;
-      } 
-  }
+    if ((MP_USED(a) == MP_USED(b)) && IS_POWER_OF_2(MP_USED(b))) {
+        if (MP_USED(a) == 4) {
+            s_mp_mul_comba_4(a, b, c);
+            goto CLEANUP;
+        }
+        if (MP_USED(a) == 8) {
+            s_mp_mul_comba_8(a, b, c);
+            goto CLEANUP;
+        }
+        if (MP_USED(a) == 16) {
+            s_mp_mul_comba_16(a, b, c);
+            goto CLEANUP;
+        }
+        if (MP_USED(a) == 32) {
+            s_mp_mul_comba_32(a, b, c);
+            goto CLEANUP;
+        }
+    }
 #endif
 
-  pb = MP_DIGITS(b);
-  s_mpv_mul_d(MP_DIGITS(a), MP_USED(a), *pb++, MP_DIGITS(c));
+    pb = MP_DIGITS(b);
+    s_mpv_mul_d(MP_DIGITS(a), MP_USED(a), *pb++, MP_DIGITS(c));
 
-  /* Outer loop:  Digits of b */
-  useda = MP_USED(a);
-  usedb = MP_USED(b);
-  for (ib = 1; ib < usedb; ib++) {
-    mp_digit b_i    = *pb++;
+    /* Outer loop:  Digits of b */
+    useda = MP_USED(a);
+    usedb = MP_USED(b);
+    for (ib = 1; ib < usedb; ib++) {
+        mp_digit b_i = *pb++;
 
-    /* Inner product:  Digits of a */
-    if (b_i)
-      s_mpv_mul_d_add(MP_DIGITS(a), useda, b_i, MP_DIGITS(c) + ib);
-    else
-      MP_DIGIT(c, ib + useda) = b_i;
-  }
+        /* Inner product:  Digits of a */
+        if (b_i)
+            s_mpv_mul_d_add(MP_DIGITS(a), useda, b_i, MP_DIGITS(c) + ib);
+        else
+            MP_DIGIT(c, ib + useda) = b_i;
+    }
 
-  s_mp_clamp(c);
+    s_mp_clamp(c);
 
-  if(SIGN(a) == SIGN(b) || s_mp_cmp_d(c, 0) == MP_EQ)
-    SIGN(c) = ZPOS;
-  else
-    SIGN(c) = NEG;
+    if (SIGN(a) == SIGN(b) || s_mp_cmp_d(c, 0) == MP_EQ)
+        SIGN(c) = ZPOS;
+    else
+        SIGN(c) = NEG;
 
 CLEANUP:
-  mp_clear(&tmp);
-  return res;
+    mp_clear(&tmp);
+    return res;
 } /* end mp_mul() */
 
 /* }}} */
@@ -877,81 +902,82 @@ CLEANUP:
  */
 
 /* sqr = a^2;   Caller provides both a and tmp; */
-mp_err   mp_sqr(const mp_int *a, mp_int *sqr)
+mp_err
+mp_sqr(const mp_int *a, mp_int *sqr)
 {
-  mp_digit *pa;
-  mp_digit d;
-  mp_err   res;
-  mp_size  ix;
-  mp_int   tmp;
-  int      count;
-
-  ARGCHK(a != NULL && sqr != NULL, MP_BADARG);
-
-  if (a == sqr) {
-    if((res = mp_init_copy(&tmp, a)) != MP_OKAY)
-      return res;
-    a = &tmp;
-  } else {
-    DIGITS(&tmp) = 0;
-    res = MP_OKAY;
-  }
+    mp_digit *pa;
+    mp_digit d;
+    mp_err res;
+    mp_size ix;
+    mp_int tmp;
+    int count;
+
+    ARGCHK(a != NULL && sqr != NULL, MP_BADARG);
+
+    if (a == sqr) {
+        if ((res = mp_init_copy(&tmp, a)) != MP_OKAY)
+            return res;
+        a = &tmp;
+    } else {
+        DIGITS(&tmp) = 0;
+        res = MP_OKAY;
+    }
 
-  ix = 2 * MP_USED(a);
-  if (ix > MP_ALLOC(sqr)) {
-    MP_USED(sqr) = 1; 
-    MP_CHECKOK( s_mp_grow(sqr, ix) );
-  } 
-  MP_USED(sqr) = ix;
-  MP_DIGIT(sqr, 0) = 0;
+    ix = 2 * MP_USED(a);
+    if (ix > MP_ALLOC(sqr)) {
+        MP_USED(sqr) = 1;
+        MP_CHECKOK(s_mp_grow(sqr, ix));
+    }
+    MP_USED(sqr) = ix;
+    MP_DIGIT(sqr, 0) = 0;
 
 #ifdef NSS_USE_COMBA
-  if (IS_POWER_OF_2(MP_USED(a))) {
-      if (MP_USED(a) == 4) {
-          s_mp_sqr_comba_4(a, sqr);
-          goto CLEANUP;
-      }
-      if (MP_USED(a) == 8) {
-          s_mp_sqr_comba_8(a, sqr);
-          goto CLEANUP;
-      }
-      if (MP_USED(a) == 16) {
-          s_mp_sqr_comba_16(a, sqr);
-          goto CLEANUP;
-      }
-      if (MP_USED(a) == 32) {
-          s_mp_sqr_comba_32(a, sqr);
-          goto CLEANUP;
-      } 
-  }
+    if (IS_POWER_OF_2(MP_USED(a))) {
+        if (MP_USED(a) == 4) {
+            s_mp_sqr_comba_4(a, sqr);
+            goto CLEANUP;
+        }
+        if (MP_USED(a) == 8) {
+            s_mp_sqr_comba_8(a, sqr);
+            goto CLEANUP;
+        }
+        if (MP_USED(a) == 16) {
+            s_mp_sqr_comba_16(a, sqr);
+            goto CLEANUP;
+        }
+        if (MP_USED(a) == 32) {
+            s_mp_sqr_comba_32(a, sqr);
+            goto CLEANUP;
+        }
+    }
 #endif
 
-  pa = MP_DIGITS(a);
-  count = MP_USED(a) - 1;
-  if (count > 0) {
-    d = *pa++;
-    s_mpv_mul_d(pa, count, d, MP_DIGITS(sqr) + 1);
-    for (ix = 3; --count > 0; ix += 2) {
-      d = *pa++;
-      s_mpv_mul_d_add(pa, count, d, MP_DIGITS(sqr) + ix);
-    } /* for(ix ...) */
-    MP_DIGIT(sqr, MP_USED(sqr)-1) = 0; /* above loop stopped short of this. */
-
-    /* now sqr *= 2 */
-    s_mp_mul_2(sqr);
-  } else {
-    MP_DIGIT(sqr, 1) = 0;
-  }
-
-  /* now add the squares of the digits of a to sqr. */
-  s_mpv_sqr_add_prop(MP_DIGITS(a), MP_USED(a), MP_DIGITS(sqr));
-
-  SIGN(sqr) = ZPOS;
-  s_mp_clamp(sqr);
+    pa = MP_DIGITS(a);
+    count = MP_USED(a) - 1;
+    if (count > 0) {
+        d = *pa++;
+        s_mpv_mul_d(pa, count, d, MP_DIGITS(sqr) + 1);
+        for (ix = 3; --count > 0; ix += 2) {
+            d = *pa++;
+            s_mpv_mul_d_add(pa, count, d, MP_DIGITS(sqr) + ix);
+        }                                    /* for(ix ...) */
+        MP_DIGIT(sqr, MP_USED(sqr) - 1) = 0; /* above loop stopped short of this. */
+
+        /* now sqr *= 2 */
+        s_mp_mul_2(sqr);
+    } else {
+        MP_DIGIT(sqr, 1) = 0;
+    }
+
+    /* now add the squares of the digits of a to sqr. */
+    s_mpv_sqr_add_prop(MP_DIGITS(a), MP_USED(a), MP_DIGITS(sqr));
+
+    SIGN(sqr) = ZPOS;
+    s_mp_clamp(sqr);
 
 CLEANUP:
-  mp_clear(&tmp);
-  return res;
+    mp_clear(&tmp);
+    return res;
 
 } /* end mp_sqr() */
 #endif
@@ -967,85 +993,86 @@ CLEANUP:
   as output parameters.  If q or r is NULL, that portion of the
   computation will be discarded (although it will still be computed)
  */
-mp_err mp_div(const mp_int *a, const mp_int *b, mp_int *q, mp_int *r)
+mp_err
+mp_div(const mp_int *a, const mp_int *b, mp_int *q, mp_int *r)
 {
-  mp_err   res;
-  mp_int   *pQ, *pR;
-  mp_int   qtmp, rtmp, btmp;
-  int      cmp;
-  mp_sign  signA;
-  mp_sign  signB;
-
-  ARGCHK(a != NULL && b != NULL, MP_BADARG);
-  
-  signA = MP_SIGN(a);
-  signB = MP_SIGN(b);
-
-  if(mp_cmp_z(b) == MP_EQ)
-    return MP_RANGE;
-
-  DIGITS(&qtmp) = 0;
-  DIGITS(&rtmp) = 0;
-  DIGITS(&btmp) = 0;
-
-  /* Set up some temporaries... */
-  if (!r || r == a || r == b) {
-    MP_CHECKOK( mp_init_copy(&rtmp, a) );
-    pR = &rtmp;
-  } else {
-    MP_CHECKOK( mp_copy(a, r) );
-    pR = r;
-  }
-
-  if (!q || q == a || q == b) {
-    MP_CHECKOK( mp_init_size(&qtmp, MP_USED(a)) );
-    pQ = &qtmp;
-  } else {
-    MP_CHECKOK( s_mp_pad(q, MP_USED(a)) );
-    pQ = q;
-    mp_zero(pQ);
-  }
-
-  /*
-    If |a| <= |b|, we can compute the solution without division;
-    otherwise, we actually do the work required.
-   */
-  if ((cmp = s_mp_cmp(a, b)) <= 0) {
-    if (cmp) {
-      /* r was set to a above. */
-      mp_zero(pQ);
+    mp_err res;
+    mp_int *pQ, *pR;
+    mp_int qtmp, rtmp, btmp;
+    int cmp;
+    mp_sign signA;
+    mp_sign signB;
+
+    ARGCHK(a != NULL && b != NULL, MP_BADARG);
+
+    signA = MP_SIGN(a);
+    signB = MP_SIGN(b);
+
+    if (mp_cmp_z(b) == MP_EQ)
+        return MP_RANGE;
+
+    DIGITS(&qtmp) = 0;
+    DIGITS(&rtmp) = 0;
+    DIGITS(&btmp) = 0;
+
+    /* Set up some temporaries... */
+    if (!r || r == a || r == b) {
+        MP_CHECKOK(mp_init_copy(&rtmp, a));
+        pR = &rtmp;
+    } else {
+        MP_CHECKOK(mp_copy(a, r));
+        pR = r;
+    }
+
+    if (!q || q == a || q == b) {
+        MP_CHECKOK(mp_init_size(&qtmp, MP_USED(a)));
+        pQ = &qtmp;
+    } else {
+        MP_CHECKOK(s_mp_pad(q, MP_USED(a)));
+        pQ = q;
+        mp_zero(pQ);
+    }
+
+    /*
+      If |a| <= |b|, we can compute the solution without division;
+      otherwise, we actually do the work required.
+     */
+    if ((cmp = s_mp_cmp(a, b)) <= 0) {
+        if (cmp) {
+            /* r was set to a above. */
+            mp_zero(pQ);
+        } else {
+            mp_set(pQ, 1);
+            mp_zero(pR);
+        }
     } else {
-      mp_set(pQ, 1);
-      mp_zero(pR);
+        MP_CHECKOK(mp_init_copy(&btmp, b));
+        MP_CHECKOK(s_mp_div(pR, &btmp, pQ));
     }
-  } else {
-    MP_CHECKOK( mp_init_copy(&btmp, b) );
-    MP_CHECKOK( s_mp_div(pR, &btmp, pQ) );
-  }
 
-  /* Compute the signs for the output  */
-  MP_SIGN(pR) = signA;   /* Sr = Sa              */
-  /* Sq = ZPOS if Sa == Sb */ /* Sq = NEG if Sa != Sb */
-  MP_SIGN(pQ) = (signA == signB) ? ZPOS : NEG;
+    /* Compute the signs for the output  */
+    MP_SIGN(pR) = signA;        /* Sr = Sa              */
+    /* Sq = ZPOS if Sa == Sb */ /* Sq = NEG if Sa != Sb */
+    MP_SIGN(pQ) = (signA == signB) ? ZPOS : NEG;
 
-  if(s_mp_cmp_d(pQ, 0) == MP_EQ)
-    SIGN(pQ) = ZPOS;
-  if(s_mp_cmp_d(pR, 0) == MP_EQ)
-    SIGN(pR) = ZPOS;
+    if (s_mp_cmp_d(pQ, 0) == MP_EQ)
+        SIGN(pQ) = ZPOS;
+    if (s_mp_cmp_d(pR, 0) == MP_EQ)
+        SIGN(pR) = ZPOS;
 
-  /* Copy output, if it is needed      */
-  if(q && q != pQ) 
-    s_mp_exch(pQ, q);
+    /* Copy output, if it is needed      */
+    if (q && q != pQ)
+        s_mp_exch(pQ, q);
 
-  if(r && r != pR) 
-    s_mp_exch(pR, r);
+    if (r && r != pR)
+        s_mp_exch(pR, r);
 
 CLEANUP:
-  mp_clear(&btmp);
-  mp_clear(&rtmp);
-  mp_clear(&qtmp);
+    mp_clear(&btmp);
+    mp_clear(&rtmp);
+    mp_clear(&qtmp);
 
-  return res;
+    return res;
 
 } /* end mp_div() */
 
@@ -1053,28 +1080,29 @@ CLEANUP:
 
 /* {{{ mp_div_2d(a, d, q, r) */
 
-mp_err mp_div_2d(const mp_int *a, mp_digit d, mp_int *q, mp_int *r)
+mp_err
+mp_div_2d(const mp_int *a, mp_digit d, mp_int *q, mp_int *r)
 {
-  mp_err  res;
-
-  ARGCHK(a != NULL, MP_BADARG);
-
-  if(q) {
-    if((res = mp_copy(a, q)) != MP_OKAY)
-      return res;
-  }
-  if(r) {
-    if((res = mp_copy(a, r)) != MP_OKAY)
-      return res;
-  }
-  if(q) {
-    s_mp_div_2d(q, d);
-  }
-  if(r) {
-    s_mp_mod_2d(r, d);
-  }
-
-  return MP_OKAY;
+    mp_err res;
+
+    ARGCHK(a != NULL, MP_BADARG);
+
+    if (q) {
+        if ((res = mp_copy(a, q)) != MP_OKAY)
+            return res;
+    }
+    if (r) {
+        if ((res = mp_copy(a, r)) != MP_OKAY)
+            return res;
+    }
+    if (q) {
+        s_mp_div_2d(q, d);
+    }
+    if (r) {
+        s_mp_mod_2d(r, d);
+    }
+
+    return MP_OKAY;
 
 } /* end mp_div_2d() */
 
@@ -1089,70 +1117,71 @@ mp_err mp_div_2d(const mp_int *a, mp_digit d, mp_int *q, mp_int *r)
   standard iterative square-and-multiply technique.
  */
 
-mp_err mp_expt(mp_int *a, mp_int *b, mp_int *c)
+mp_err
+mp_expt(mp_int *a, mp_int *b, mp_int *c)
 {
-  mp_int   s, x;
-  mp_err   res;
-  mp_digit d;
-  unsigned int      dig, bit;
+    mp_int s, x;
+    mp_err res;
+    mp_digit d;
+    unsigned int dig, bit;
 
-  ARGCHK(a != NULL && b != NULL && c != NULL, MP_BADARG);
+    ARGCHK(a != NULL && b != NULL && c != NULL, MP_BADARG);
 
-  if(mp_cmp_z(b) < 0)
-    return MP_RANGE;
+    if (mp_cmp_z(b) < 0)
+        return MP_RANGE;
 
-  if((res = mp_init(&s)) != MP_OKAY)
-    return res;
+    if ((res = mp_init(&s)) != MP_OKAY)
+        return res;
+
+    mp_set(&s, 1);
 
-  mp_set(&s, 1);
+    if ((res = mp_init_copy(&x, a)) != MP_OKAY)
+        goto X;
 
-  if((res = mp_init_copy(&x, a)) != MP_OKAY)
-    goto X;
+    /* Loop over low-order digits in ascending order */
+    for (dig = 0; dig < (USED(b) - 1); dig++) {
+        d = DIGIT(b, dig);
 
-  /* Loop over low-order digits in ascending order */
-  for(dig = 0; dig < (USED(b) - 1); dig++) {
-    d = DIGIT(b, dig);
+        /* Loop over bits of each non-maximal digit */
+        for (bit = 0; bit < DIGIT_BIT; bit++) {
+            if (d & 1) {
+                if ((res = s_mp_mul(&s, &x)) != MP_OKAY)
+                    goto CLEANUP;
+            }
 
-    /* Loop over bits of each non-maximal digit */
-    for(bit = 0; bit < DIGIT_BIT; bit++) {
-      if(d & 1) {
-	if((res = s_mp_mul(&s, &x)) != MP_OKAY) 
-	  goto CLEANUP;
-      }
+            d >>= 1;
 
-      d >>= 1;
-      
-      if((res = s_mp_sqr(&x)) != MP_OKAY)
-	goto CLEANUP;
+            if ((res = s_mp_sqr(&x)) != MP_OKAY)
+                goto CLEANUP;
+        }
     }
-  }
 
-  /* Consider now the last digit... */
-  d = DIGIT(b, dig);
+    /* Consider now the last digit... */
+    d = DIGIT(b, dig);
 
-  while(d) {
-    if(d & 1) {
-      if((res = s_mp_mul(&s, &x)) != MP_OKAY)
-	goto CLEANUP;
-    }
+    while (d) {
+        if (d & 1) {
+            if ((res = s_mp_mul(&s, &x)) != MP_OKAY)
+                goto CLEANUP;
+        }
 
-    d >>= 1;
+        d >>= 1;
+
+        if ((res = s_mp_sqr(&x)) != MP_OKAY)
+            goto CLEANUP;
+    }
 
-    if((res = s_mp_sqr(&x)) != MP_OKAY)
-      goto CLEANUP;
-  }
-  
-  if(mp_iseven(b))
-    SIGN(&s) = SIGN(a);
+    if (mp_iseven(b))
+        SIGN(&s) = SIGN(a);
 
-  res = mp_copy(&s, c);
+    res = mp_copy(&s, c);
 
 CLEANUP:
-  mp_clear(&x);
+    mp_clear(&x);
 X:
-  mp_clear(&s);
+    mp_clear(&s);
 
-  return res;
+    return res;
 
 } /* end mp_expt() */
 
@@ -1162,11 +1191,12 @@ X:
 
 /* Compute a = 2^k */
 
-mp_err mp_2expt(mp_int *a, mp_digit k)
+mp_err
+mp_2expt(mp_int *a, mp_digit k)
 {
-  ARGCHK(a != NULL, MP_BADARG);
+    ARGCHK(a != NULL, MP_BADARG);
 
-  return s_mp_2expt(a, k);
+    return s_mp_2expt(a, k);
 
 } /* end mp_2expt() */
 
@@ -1180,19 +1210,20 @@ mp_err mp_2expt(mp_int *a, mp_digit k)
   Compute c = a (mod m).  Result will always be 0 <= c < m.
  */
 
-mp_err mp_mod(const mp_int *a, const mp_int *m, mp_int *c)
+mp_err
+mp_mod(const mp_int *a, const mp_int *m, mp_int *c)
 {
-  mp_err  res;
-  int     mag;
+    mp_err res;
+    int mag;
 
-  ARGCHK(a != NULL && m != NULL && c != NULL, MP_BADARG);
+    ARGCHK(a != NULL && m != NULL && c != NULL, MP_BADARG);
 
-  if(SIGN(m) == NEG)
-    return MP_RANGE;
+    if (SIGN(m) == NEG)
+        return MP_RANGE;
 
-  /*
+    /*
      If |a| > m, we need to divide to get the remainder and take the
-     absolute value.  
+     absolute value.
 
      If |a| < m, we don't need to do any division, just copy and adjust
      the sign (if a is negative).
@@ -1202,32 +1233,30 @@ mp_err mp_mod(const mp_int *a, const mp_int *m, mp_int *c)
      This order is intended to minimize the average path length of the
      comparison chain on common workloads -- the most frequent cases are
      that |a| != m, so we do those first.
-   */
-  if((mag = s_mp_cmp(a, m)) > 0) {
-    if((res = mp_div(a, m, NULL, c)) != MP_OKAY)
-      return res;
-    
-    if(SIGN(c) == NEG) {
-      if((res = mp_add(c, m, c)) != MP_OKAY)
-	return res;
-    }
+     */
+    if ((mag = s_mp_cmp(a, m)) > 0) {
+        if ((res = mp_div(a, m, NULL, c)) != MP_OKAY)
+            return res;
 
-  } else if(mag < 0) {
-    if((res = mp_copy(a, c)) != MP_OKAY)
-      return res;
+        if (SIGN(c) == NEG) {
+            if ((res = mp_add(c, m, c)) != MP_OKAY)
+                return res;
+        }
 
-    if(mp_cmp_z(a) < 0) {
-      if((res = mp_add(c, m, c)) != MP_OKAY)
-	return res;
+    } else if (mag < 0) {
+        if ((res = mp_copy(a, c)) != MP_OKAY)
+            return res;
 
-    }
-    
-  } else {
-    mp_zero(c);
+        if (mp_cmp_z(a) < 0) {
+            if ((res = mp_add(c, m, c)) != MP_OKAY)
+                return res;
+        }
 
-  }
+    } else {
+        mp_zero(c);
+    }
 
-  return MP_OKAY;
+    return MP_OKAY;
 
 } /* end mp_mod() */
 
@@ -1240,28 +1269,29 @@ mp_err mp_mod(const mp_int *a, const mp_int *m, mp_int *c)
 
   Compute c = a (mod d).  Result will always be 0 <= c < d
  */
-mp_err mp_mod_d(const mp_int *a, mp_digit d, mp_digit *c)
+mp_err
+mp_mod_d(const mp_int *a, mp_digit d, mp_digit *c)
 {
-  mp_err   res;
-  mp_digit rem;
+    mp_err res;
+    mp_digit rem;
 
-  ARGCHK(a != NULL && c != NULL, MP_BADARG);
+    ARGCHK(a != NULL && c != NULL, MP_BADARG);
 
-  if(s_mp_cmp_d(a, d) > 0) {
-    if((res = mp_div_d(a, d, NULL, &rem)) != MP_OKAY)
-      return res;
+    if (s_mp_cmp_d(a, d) > 0) {
+        if ((res = mp_div_d(a, d, NULL, &rem)) != MP_OKAY)
+            return res;
 
-  } else {
-    if(SIGN(a) == NEG)
-      rem = d - DIGIT(a, 0);
-    else
-      rem = DIGIT(a, 0);
-  }
+    } else {
+        if (SIGN(a) == NEG)
+            rem = d - DIGIT(a, 0);
+        else
+            rem = DIGIT(a, 0);
+    }
 
-  if(c)
-    *c = rem;
+    if (c)
+        *c = rem;
 
-  return MP_OKAY;
+    return MP_OKAY;
 
 } /* end mp_mod_d() */
 
@@ -1282,68 +1312,68 @@ mp_err mp_mod_d(const mp_int *a, mp_digit d, mp_digit *c)
 
   It is a range error to pass a negative value.
  */
-mp_err mp_sqrt(const mp_int *a, mp_int *b)
+mp_err
+mp_sqrt(const mp_int *a, mp_int *b)
 {
-  mp_int   x, t;
-  mp_err   res;
-  mp_size  used;
-
-  ARGCHK(a != NULL && b != NULL, MP_BADARG);
-
-  /* Cannot take square root of a negative value */
-  if(SIGN(a) == NEG)
-    return MP_RANGE;
-
-  /* Special cases for zero and one, trivial     */
-  if(mp_cmp_d(a, 1) <= 0)
-    return mp_copy(a, b);
-    
-  /* Initialize the temporaries we'll use below  */
-  if((res = mp_init_size(&t, USED(a))) != MP_OKAY)
-    return res;
+    mp_int x, t;
+    mp_err res;
+    mp_size used;
 
-  /* Compute an initial guess for the iteration as a itself */
-  if((res = mp_init_copy(&x, a)) != MP_OKAY)
-    goto X;
+    ARGCHK(a != NULL && b != NULL, MP_BADARG);
 
-  used = MP_USED(&x);
-  if (used > 1) {
-    s_mp_rshd(&x, used / 2);
-  }
+    /* Cannot take square root of a negative value */
+    if (SIGN(a) == NEG)
+        return MP_RANGE;
 
-  for(;;) {
-    /* t = (x * x) - a */
-    if((res = mp_copy(&x, &t)) != MP_OKAY ||
-       (res = mp_sqr(&t, &t)) != MP_OKAY ||
-       (res = mp_sub(&t, a, &t)) != MP_OKAY)
-      goto CLEANUP;
+    /* Special cases for zero and one, trivial     */
+    if (mp_cmp_d(a, 1) <= 0)
+        return mp_copy(a, b);
 
-    /* t = t / 2x       */
-    s_mp_mul_2(&x);
-    if((res = mp_div(&t, &x, &t, NULL)) != MP_OKAY)
-      goto CLEANUP;
-    s_mp_div_2(&x);
+    /* Initialize the temporaries we'll use below  */
+    if ((res = mp_init_size(&t, USED(a))) != MP_OKAY)
+        return res;
 
-    /* Terminate the loop, if the quotient is zero */
-    if(mp_cmp_z(&t) == MP_EQ)
-      break;
+    /* Compute an initial guess for the iteration as a itself */
+    if ((res = mp_init_copy(&x, a)) != MP_OKAY)
+        goto X;
 
-    /* x = x - t       */
-    if((res = mp_sub(&x, &t, &x)) != MP_OKAY)
-      goto CLEANUP;
+    used = MP_USED(&x);
+    if (used > 1) {
+        s_mp_rshd(&x, used / 2);
+    }
 
-  }
+    for (;;) {
+        /* t = (x * x) - a */
+        if ((res = mp_copy(&x, &t)) != MP_OKAY ||
+            (res = mp_sqr(&t, &t)) != MP_OKAY ||
+            (res = mp_sub(&t, a, &t)) != MP_OKAY)
+            goto CLEANUP;
+
+        /* t = t / 2x       */
+        s_mp_mul_2(&x);
+        if ((res = mp_div(&t, &x, &t, NULL)) != MP_OKAY)
+            goto CLEANUP;
+        s_mp_div_2(&x);
+
+        /* Terminate the loop, if the quotient is zero */
+        if (mp_cmp_z(&t) == MP_EQ)
+            break;
+
+        /* x = x - t       */
+        if ((res = mp_sub(&x, &t, &x)) != MP_OKAY)
+            goto CLEANUP;
+    }
 
-  /* Copy result to output parameter */
-  MP_CHECKOK(mp_sub_d(&x, 1, &x));
-  s_mp_exch(&x, b);
+    /* Copy result to output parameter */
+    MP_CHECKOK(mp_sub_d(&x, 1, &x));
+    s_mp_exch(&x, b);
 
- CLEANUP:
-  mp_clear(&x);
- X:
-  mp_clear(&t); 
+CLEANUP:
+    mp_clear(&x);
+X:
+    mp_clear(&t);
 
-  return res;
+    return res;
 
 } /* end mp_sqrt() */
 
@@ -1363,19 +1393,19 @@ mp_err mp_sqrt(const mp_int *a, mp_int *b)
   Compute c = (a + b) mod m
  */
 
-mp_err mp_addmod(const mp_int *a, const mp_int *b, const mp_int *m, mp_int *c)
+mp_err
+mp_addmod(const mp_int *a, const mp_int *b, const mp_int *m, mp_int *c)
 {
-  mp_err  res;
+    mp_err res;
 
-  ARGCHK(a != NULL && b != NULL && m != NULL && c != NULL, MP_BADARG);
-
-  if((res = mp_add(a, b, c)) != MP_OKAY)
-    return res;
-  if((res = mp_mod(c, m, c)) != MP_OKAY)
-    return res;
+    ARGCHK(a != NULL && b != NULL && m != NULL && c != NULL, MP_BADARG);
 
-  return MP_OKAY;
+    if ((res = mp_add(a, b, c)) != MP_OKAY)
+        return res;
+    if ((res = mp_mod(c, m, c)) != MP_OKAY)
+        return res;
 
+    return MP_OKAY;
 }
 
 /* }}} */
@@ -1388,19 +1418,19 @@ mp_err mp_addmod(const mp_int *a, const mp_int *b, const mp_int *m, mp_int *c)
   Compute c = (a - b) mod m
  */
 
-mp_err mp_submod(const mp_int *a, const mp_int *b, const mp_int *m, mp_int *c)
+mp_err
+mp_submod(const mp_int *a, const mp_int *b, const mp_int *m, mp_int *c)
 {
-  mp_err  res;
+    mp_err res;
 
-  ARGCHK(a != NULL && b != NULL && m != NULL && c != NULL, MP_BADARG);
+    ARGCHK(a != NULL && b != NULL && m != NULL && c != NULL, MP_BADARG);
 
-  if((res = mp_sub(a, b, c)) != MP_OKAY)
-    return res;
-  if((res = mp_mod(c, m, c)) != MP_OKAY)
-    return res;
-
-  return MP_OKAY;
+    if ((res = mp_sub(a, b, c)) != MP_OKAY)
+        return res;
+    if ((res = mp_mod(c, m, c)) != MP_OKAY)
+        return res;
 
+    return MP_OKAY;
 }
 
 /* }}} */
@@ -1413,19 +1443,19 @@ mp_err mp_submod(const mp_int *a, const mp_int *b, const mp_int *m, mp_int *c)
   Compute c = (a * b) mod m
  */
 
-mp_err mp_mulmod(const mp_int *a, const mp_int *b, const mp_int *m, mp_int *c)
+mp_err
+mp_mulmod(const mp_int *a, const mp_int *b, const mp_int *m, mp_int *c)
 {
-  mp_err  res;
+    mp_err res;
 
-  ARGCHK(a != NULL && b != NULL && m != NULL && c != NULL, MP_BADARG);
-
-  if((res = mp_mul(a, b, c)) != MP_OKAY)
-    return res;
-  if((res = mp_mod(c, m, c)) != MP_OKAY)
-    return res;
+    ARGCHK(a != NULL && b != NULL && m != NULL && c != NULL, MP_BADARG);
 
-  return MP_OKAY;
+    if ((res = mp_mul(a, b, c)) != MP_OKAY)
+        return res;
+    if ((res = mp_mod(c, m, c)) != MP_OKAY)
+        return res;
 
+    return MP_OKAY;
 }
 
 /* }}} */
@@ -1433,18 +1463,19 @@ mp_err mp_mulmod(const mp_int *a, const mp_int *b, const mp_int *m, mp_int *c)
 /* {{{ mp_sqrmod(a, m, c) */
 
 #if MP_SQUARE
-mp_err mp_sqrmod(const mp_int *a, const mp_int *m, mp_int *c)
+mp_err
+mp_sqrmod(const mp_int *a, const mp_int *m, mp_int *c)
 {
-  mp_err  res;
+    mp_err res;
 
-  ARGCHK(a != NULL && m != NULL && c != NULL, MP_BADARG);
+    ARGCHK(a != NULL && m != NULL && c != NULL, MP_BADARG);
 
-  if((res = mp_sqr(a, c)) != MP_OKAY)
-    return res;
-  if((res = mp_mod(c, m, c)) != MP_OKAY)
-    return res;
+    if ((res = mp_sqr(a, c)) != MP_OKAY)
+        return res;
+    if ((res = mp_mod(c, m, c)) != MP_OKAY)
+        return res;
 
-  return MP_OKAY;
+    return MP_OKAY;
 
 } /* end mp_sqrmod() */
 #endif
@@ -1459,92 +1490,93 @@ mp_err mp_sqrmod(const mp_int *a, const mp_int *m, mp_int *c)
   Compute c = (a ** b) mod m.  Uses a standard square-and-multiply
   method with modular reductions at each step. (This is basically the
   same code as mp_expt(), except for the addition of the reductions)
-  
+
   The modular reductions are done using Barrett's algorithm (see
   s_mp_reduce() below for details)
  */
 
-mp_err s_mp_exptmod(const mp_int *a, const mp_int *b, const mp_int *m, mp_int *c)
+mp_err
+s_mp_exptmod(const mp_int *a, const mp_int *b, const mp_int *m, mp_int *c)
 {
-  mp_int   s, x, mu;
-  mp_err   res;
-  mp_digit d;
-  unsigned int      dig, bit;
-
-  ARGCHK(a != NULL && b != NULL && c != NULL, MP_BADARG);
-
-  if(mp_cmp_z(b) < 0 || mp_cmp_z(m) <= 0)
-    return MP_RANGE;
+    mp_int s, x, mu;
+    mp_err res;
+    mp_digit d;
+    unsigned int dig, bit;
 
-  if((res = mp_init(&s)) != MP_OKAY)
-    return res;
-  if((res = mp_init_copy(&x, a)) != MP_OKAY ||
-     (res = mp_mod(&x, m, &x)) != MP_OKAY)
-    goto X;
-  if((res = mp_init(&mu)) != MP_OKAY)
-    goto MU;
-
-  mp_set(&s, 1);
-
-  /* mu = b^2k / m */
-  if((res = s_mp_add_d(&mu, 1)) != MP_OKAY)
-    goto CLEANUP;
-  if((res = s_mp_lshd(&mu, 2 * USED(m))) != MP_OKAY)
-    goto CLEANUP;
-  if((res = mp_div(&mu, m, &mu, NULL)) != MP_OKAY)
-    goto CLEANUP;
-
-  /* Loop over digits of b in ascending order, except highest order */
-  for(dig = 0; dig < (USED(b) - 1); dig++) {
-    d = DIGIT(b, dig);
+    ARGCHK(a != NULL && b != NULL && c != NULL, MP_BADARG);
 
-    /* Loop over the bits of the lower-order digits */
-    for(bit = 0; bit < DIGIT_BIT; bit++) {
-      if(d & 1) {
-	if((res = s_mp_mul(&s, &x)) != MP_OKAY)
-	  goto CLEANUP;
-	if((res = s_mp_reduce(&s, m, &mu)) != MP_OKAY)
-	  goto CLEANUP;
-      }
+    if (mp_cmp_z(b) < 0 || mp_cmp_z(m) <= 0)
+        return MP_RANGE;
 
-      d >>= 1;
-
-      if((res = s_mp_sqr(&x)) != MP_OKAY)
-	goto CLEANUP;
-      if((res = s_mp_reduce(&x, m, &mu)) != MP_OKAY)
-	goto CLEANUP;
+    if ((res = mp_init(&s)) != MP_OKAY)
+        return res;
+    if ((res = mp_init_copy(&x, a)) != MP_OKAY ||
+        (res = mp_mod(&x, m, &x)) != MP_OKAY)
+        goto X;
+    if ((res = mp_init(&mu)) != MP_OKAY)
+        goto MU;
+
+    mp_set(&s, 1);
+
+    /* mu = b^2k / m */
+    if ((res = s_mp_add_d(&mu, 1)) != MP_OKAY)
+        goto CLEANUP;
+    if ((res = s_mp_lshd(&mu, 2 * USED(m))) != MP_OKAY)
+        goto CLEANUP;
+    if ((res = mp_div(&mu, m, &mu, NULL)) != MP_OKAY)
+        goto CLEANUP;
+
+    /* Loop over digits of b in ascending order, except highest order */
+    for (dig = 0; dig < (USED(b) - 1); dig++) {
+        d = DIGIT(b, dig);
+
+        /* Loop over the bits of the lower-order digits */
+        for (bit = 0; bit < DIGIT_BIT; bit++) {
+            if (d & 1) {
+                if ((res = s_mp_mul(&s, &x)) != MP_OKAY)
+                    goto CLEANUP;
+                if ((res = s_mp_reduce(&s, m, &mu)) != MP_OKAY)
+                    goto CLEANUP;
+            }
+
+            d >>= 1;
+
+            if ((res = s_mp_sqr(&x)) != MP_OKAY)
+                goto CLEANUP;
+            if ((res = s_mp_reduce(&x, m, &mu)) != MP_OKAY)
+                goto CLEANUP;
+        }
     }
-  }
 
-  /* Now do the last digit... */
-  d = DIGIT(b, dig);
+    /* Now do the last digit... */
+    d = DIGIT(b, dig);
 
-  while(d) {
-    if(d & 1) {
-      if((res = s_mp_mul(&s, &x)) != MP_OKAY)
-	goto CLEANUP;
-      if((res = s_mp_reduce(&s, m, &mu)) != MP_OKAY)
-	goto CLEANUP;
-    }
+    while (d) {
+        if (d & 1) {
+            if ((res = s_mp_mul(&s, &x)) != MP_OKAY)
+                goto CLEANUP;
+            if ((res = s_mp_reduce(&s, m, &mu)) != MP_OKAY)
+                goto CLEANUP;
+        }
 
-    d >>= 1;
+        d >>= 1;
 
-    if((res = s_mp_sqr(&x)) != MP_OKAY)
-      goto CLEANUP;
-    if((res = s_mp_reduce(&x, m, &mu)) != MP_OKAY)
-      goto CLEANUP;
-  }
+        if ((res = s_mp_sqr(&x)) != MP_OKAY)
+            goto CLEANUP;
+        if ((res = s_mp_reduce(&x, m, &mu)) != MP_OKAY)
+            goto CLEANUP;
+    }
 
-  s_mp_exch(&s, c);
+    s_mp_exch(&s, c);
 
- CLEANUP:
-  mp_clear(&mu);
- MU:
-  mp_clear(&x);
- X:
-  mp_clear(&s);
+CLEANUP:
+    mp_clear(&mu);
+MU:
+    mp_clear(&x);
+X:
+    mp_clear(&s);
 
-  return res;
+    return res;
 
 } /* end s_mp_exptmod() */
 
@@ -1552,42 +1584,43 @@ mp_err s_mp_exptmod(const mp_int *a, const mp_int *b, const mp_int *m, mp_int *c
 
 /* {{{ mp_exptmod_d(a, d, m, c) */
 
-mp_err mp_exptmod_d(const mp_int *a, mp_digit d, const mp_int *m, mp_int *c)
+mp_err
+mp_exptmod_d(const mp_int *a, mp_digit d, const mp_int *m, mp_int *c)
 {
-  mp_int   s, x;
-  mp_err   res;
+    mp_int s, x;
+    mp_err res;
 
-  ARGCHK(a != NULL && c != NULL, MP_BADARG);
+    ARGCHK(a != NULL && c != NULL, MP_BADARG);
 
-  if((res = mp_init(&s)) != MP_OKAY)
-    return res;
-  if((res = mp_init_copy(&x, a)) != MP_OKAY)
-    goto X;
+    if ((res = mp_init(&s)) != MP_OKAY)
+        return res;
+    if ((res = mp_init_copy(&x, a)) != MP_OKAY)
+        goto X;
 
-  mp_set(&s, 1);
+    mp_set(&s, 1);
 
-  while(d != 0) {
-    if(d & 1) {
-      if((res = s_mp_mul(&s, &x)) != MP_OKAY ||
-	 (res = mp_mod(&s, m, &s)) != MP_OKAY)
-	goto CLEANUP;
-    }
+    while (d != 0) {
+        if (d & 1) {
+            if ((res = s_mp_mul(&s, &x)) != MP_OKAY ||
+                (res = mp_mod(&s, m, &s)) != MP_OKAY)
+                goto CLEANUP;
+        }
 
-    d /= 2;
+        d /= 2;
 
-    if((res = s_mp_sqr(&x)) != MP_OKAY ||
-       (res = mp_mod(&x, m, &x)) != MP_OKAY)
-      goto CLEANUP;
-  }
+        if ((res = s_mp_sqr(&x)) != MP_OKAY ||
+            (res = mp_mod(&x, m, &x)) != MP_OKAY)
+            goto CLEANUP;
+    }
 
-  s_mp_exch(&s, c);
+    s_mp_exch(&s, c);
 
 CLEANUP:
-  mp_clear(&x);
+    mp_clear(&x);
 X:
-  mp_clear(&s);
+    mp_clear(&s);
 
-  return res;
+    return res;
 
 } /* end mp_exptmod_d() */
 
@@ -1607,14 +1640,15 @@ X:
   Compare a <=> 0.  Returns <0 if a<0, 0 if a=0, >0 if a>0.
  */
 
-int    mp_cmp_z(const mp_int *a)
+int
+mp_cmp_z(const mp_int *a)
 {
-  if(SIGN(a) == NEG)
-    return MP_LT;
-  else if(USED(a) == 1 && DIGIT(a, 0) == 0)
-    return MP_EQ;
-  else
-    return MP_GT;
+    if (SIGN(a) == NEG)
+        return MP_LT;
+    else if (USED(a) == 1 && DIGIT(a, 0) == 0)
+        return MP_EQ;
+    else
+        return MP_GT;
 
 } /* end mp_cmp_z() */
 
@@ -1628,14 +1662,15 @@ int    mp_cmp_z(const mp_int *a)
   Compare a <=> d.  Returns <0 if a<d, 0 if a=d, >0 if a>d
  */
 
-int    mp_cmp_d(const mp_int *a, mp_digit d)
+int
+mp_cmp_d(const mp_int *a, mp_digit d)
 {
-  ARGCHK(a != NULL, MP_EQ);
+    ARGCHK(a != NULL, MP_EQ);
 
-  if(SIGN(a) == NEG)
-    return MP_LT;
+    if (SIGN(a) == NEG)
+        return MP_LT;
 
-  return s_mp_cmp_d(a, d);
+    return s_mp_cmp_d(a, d);
 
 } /* end mp_cmp_d() */
 
@@ -1643,26 +1678,27 @@ int    mp_cmp_d(const mp_int *a, mp_digit d)
 
 /* {{{ mp_cmp(a, b) */
 
-int    mp_cmp(const mp_int *a, const mp_int *b)
+int
+mp_cmp(const mp_int *a, const mp_int *b)
 {
-  ARGCHK(a != NULL && b != NULL, MP_EQ);
+    ARGCHK(a != NULL && b != NULL, MP_EQ);
 
-  if(SIGN(a) == SIGN(b)) {
-    int  mag;
+    if (SIGN(a) == SIGN(b)) {
+        int mag;
 
-    if((mag = s_mp_cmp(a, b)) == MP_EQ)
-      return MP_EQ;
+        if ((mag = s_mp_cmp(a, b)) == MP_EQ)
+            return MP_EQ;
 
-    if(SIGN(a) == ZPOS)
-      return mag;
-    else
-      return -mag;
+        if (SIGN(a) == ZPOS)
+            return mag;
+        else
+            return -mag;
 
-  } else if(SIGN(a) == ZPOS) {
-    return MP_GT;
-  } else {
-    return MP_LT;
-  }
+    } else if (SIGN(a) == ZPOS) {
+        return MP_GT;
+    } else {
+        return MP_LT;
+    }
 
 } /* end mp_cmp() */
 
@@ -1676,11 +1712,12 @@ int    mp_cmp(const mp_int *a, const mp_int *b)
   Compares |a| <=> |b|, and returns an appropriate comparison result
  */
 
-int    mp_cmp_mag(const mp_int *a, const mp_int *b)
+int
+mp_cmp_mag(const mp_int *a, const mp_int *b)
 {
-  ARGCHK(a != NULL && b != NULL, MP_EQ);
+    ARGCHK(a != NULL && b != NULL, MP_EQ);
 
-  return s_mp_cmp(a, b);
+    return s_mp_cmp(a, b);
 
 } /* end mp_cmp_mag() */
 
@@ -1693,11 +1730,12 @@ int    mp_cmp_mag(const mp_int *a, const mp_int *b)
 
   Returns a true (non-zero) value if a is odd, false (zero) otherwise.
  */
-int    mp_isodd(const mp_int *a)
+int
+mp_isodd(const mp_int *a)
 {
-  ARGCHK(a != NULL, 0);
+    ARGCHK(a != NULL, 0);
 
-  return (int)(DIGIT(a, 0) & 1);
+    return (int)(DIGIT(a, 0) & 1);
 
 } /* end mp_isodd() */
 
@@ -1705,9 +1743,10 @@ int    mp_isodd(const mp_int *a)
 
 /* {{{ mp_iseven(a) */
 
-int    mp_iseven(const mp_int *a)
+int
+mp_iseven(const mp_int *a)
 {
-  return !mp_isodd(a);
+    return !mp_isodd(a);
 
 } /* end mp_iseven() */
 
@@ -1725,94 +1764,94 @@ int    mp_iseven(const mp_int *a)
   Like the old mp_gcd() function, except computes the GCD using the
   binary algorithm due to Josef Stein in 1961 (via Knuth).
  */
-mp_err mp_gcd(mp_int *a, mp_int *b, mp_int *c)
+mp_err
+mp_gcd(mp_int *a, mp_int *b, mp_int *c)
 {
-  mp_err   res;
-  mp_int   u, v, t;
-  mp_size  k = 0;
-
-  ARGCHK(a != NULL && b != NULL && c != NULL, MP_BADARG);
+    mp_err res;
+    mp_int u, v, t;
+    mp_size k = 0;
+
+    ARGCHK(a != NULL && b != NULL && c != NULL, MP_BADARG);
+
+    if (mp_cmp_z(a) == MP_EQ && mp_cmp_z(b) == MP_EQ)
+        return MP_RANGE;
+    if (mp_cmp_z(a) == MP_EQ) {
+        return mp_copy(b, c);
+    } else if (mp_cmp_z(b) == MP_EQ) {
+        return mp_copy(a, c);
+    }
 
-  if(mp_cmp_z(a) == MP_EQ && mp_cmp_z(b) == MP_EQ)
-      return MP_RANGE;
-  if(mp_cmp_z(a) == MP_EQ) {
-    return mp_copy(b, c);
-  } else if(mp_cmp_z(b) == MP_EQ) {
-    return mp_copy(a, c);
-  }
+    if ((res = mp_init(&t)) != MP_OKAY)
+        return res;
+    if ((res = mp_init_copy(&u, a)) != MP_OKAY)
+        goto U;
+    if ((res = mp_init_copy(&v, b)) != MP_OKAY)
+        goto V;
+
+    SIGN(&u) = ZPOS;
+    SIGN(&v) = ZPOS;
+
+    /* Divide out common factors of 2 until at least 1 of a, b is even */
+    while (mp_iseven(&u) && mp_iseven(&v)) {
+        s_mp_div_2(&u);
+        s_mp_div_2(&v);
+        ++k;
+    }
 
-  if((res = mp_init(&t)) != MP_OKAY)
-    return res;
-  if((res = mp_init_copy(&u, a)) != MP_OKAY)
-    goto U;
-  if((res = mp_init_copy(&v, b)) != MP_OKAY)
-    goto V;
-
-  SIGN(&u) = ZPOS;
-  SIGN(&v) = ZPOS;
-
-  /* Divide out common factors of 2 until at least 1 of a, b is even */
-  while(mp_iseven(&u) && mp_iseven(&v)) {
-    s_mp_div_2(&u);
-    s_mp_div_2(&v);
-    ++k;
-  }
-
-  /* Initialize t */
-  if(mp_isodd(&u)) {
-    if((res = mp_copy(&v, &t)) != MP_OKAY)
-      goto CLEANUP;
-    
-    /* t = -v */
-    if(SIGN(&v) == ZPOS)
-      SIGN(&t) = NEG;
-    else
-      SIGN(&t) = ZPOS;
-    
-  } else {
-    if((res = mp_copy(&u, &t)) != MP_OKAY)
-      goto CLEANUP;
+    /* Initialize t */
+    if (mp_isodd(&u)) {
+        if ((res = mp_copy(&v, &t)) != MP_OKAY)
+            goto CLEANUP;
 
-  }
+        /* t = -v */
+        if (SIGN(&v) == ZPOS)
+            SIGN(&t) = NEG;
+        else
+            SIGN(&t) = ZPOS;
 
-  for(;;) {
-    while(mp_iseven(&t)) {
-      s_mp_div_2(&t);
+    } else {
+        if ((res = mp_copy(&u, &t)) != MP_OKAY)
+            goto CLEANUP;
     }
 
-    if(mp_cmp_z(&t) == MP_GT) {
-      if((res = mp_copy(&t, &u)) != MP_OKAY)
-	goto CLEANUP;
+    for (;;) {
+        while (mp_iseven(&t)) {
+            s_mp_div_2(&t);
+        }
 
-    } else {
-      if((res = mp_copy(&t, &v)) != MP_OKAY)
-	goto CLEANUP;
+        if (mp_cmp_z(&t) == MP_GT) {
+            if ((res = mp_copy(&t, &u)) != MP_OKAY)
+                goto CLEANUP;
 
-      /* v = -t */
-      if(SIGN(&t) == ZPOS)
-	SIGN(&v) = NEG;
-      else
-	SIGN(&v) = ZPOS;
-    }
+        } else {
+            if ((res = mp_copy(&t, &v)) != MP_OKAY)
+                goto CLEANUP;
+
+            /* v = -t */
+            if (SIGN(&t) == ZPOS)
+                SIGN(&v) = NEG;
+            else
+                SIGN(&v) = ZPOS;
+        }
 
-    if((res = mp_sub(&u, &v, &t)) != MP_OKAY)
-      goto CLEANUP;
+        if ((res = mp_sub(&u, &v, &t)) != MP_OKAY)
+            goto CLEANUP;
 
-    if(s_mp_cmp_d(&t, 0) == MP_EQ)
-      break;
-  }
+        if (s_mp_cmp_d(&t, 0) == MP_EQ)
+            break;
+    }
 
-  s_mp_2expt(&v, k);       /* v = 2^k   */
-  res = mp_mul(&u, &v, c); /* c = u * v */
+    s_mp_2expt(&v, k);       /* v = 2^k   */
+    res = mp_mul(&u, &v, c); /* c = u * v */
 
- CLEANUP:
-  mp_clear(&v);
- V:
-  mp_clear(&u);
- U:
-  mp_clear(&t);
+CLEANUP:
+    mp_clear(&v);
+V:
+    mp_clear(&u);
+U:
+    mp_clear(&t);
 
-  return res;
+    return res;
 
 } /* end mp_gcd() */
 
@@ -1827,32 +1866,33 @@ mp_err mp_gcd(mp_int *a, mp_int *b, mp_int *c)
    ... by computing the product, and dividing out the gcd.
  */
 
-mp_err mp_lcm(mp_int *a, mp_int *b, mp_int *c)
+mp_err
+mp_lcm(mp_int *a, mp_int *b, mp_int *c)
 {
-  mp_int  gcd, prod;
-  mp_err  res;
+    mp_int gcd, prod;
+    mp_err res;
 
-  ARGCHK(a != NULL && b != NULL && c != NULL, MP_BADARG);
+    ARGCHK(a != NULL && b != NULL && c != NULL, MP_BADARG);
 
-  /* Set up temporaries */
-  if((res = mp_init(&gcd)) != MP_OKAY)
-    return res;
-  if((res = mp_init(&prod)) != MP_OKAY)
-    goto GCD;
+    /* Set up temporaries */
+    if ((res = mp_init(&gcd)) != MP_OKAY)
+        return res;
+    if ((res = mp_init(&prod)) != MP_OKAY)
+        goto GCD;
 
-  if((res = mp_mul(a, b, &prod)) != MP_OKAY)
-    goto CLEANUP;
-  if((res = mp_gcd(a, b, &gcd)) != MP_OKAY)
-    goto CLEANUP;
+    if ((res = mp_mul(a, b, &prod)) != MP_OKAY)
+        goto CLEANUP;
+    if ((res = mp_gcd(a, b, &gcd)) != MP_OKAY)
+        goto CLEANUP;
 
-  res = mp_div(&prod, &gcd, c, NULL);
+    res = mp_div(&prod, &gcd, c, NULL);
 
- CLEANUP:
-  mp_clear(&prod);
- GCD:
-  mp_clear(&gcd);
+CLEANUP:
+    mp_clear(&prod);
+GCD:
+    mp_clear(&gcd);
 
-  return res;
+    return res;
 
 } /* end mp_lcm() */
 
@@ -1869,156 +1909,161 @@ mp_err mp_lcm(mp_int *a, mp_int *b, mp_int *c)
   See algorithm 14.61 in Handbook of Applied Cryptogrpahy.
  */
 
-mp_err mp_xgcd(const mp_int *a, const mp_int *b, mp_int *g, mp_int *x, mp_int *y)
+mp_err
+mp_xgcd(const mp_int *a, const mp_int *b, mp_int *g, mp_int *x, mp_int *y)
 {
-  mp_int   gx, xc, yc, u, v, A, B, C, D;
-  mp_int  *clean[9];
-  mp_err   res;
-  int      last = -1;
-
-  if(mp_cmp_z(b) == 0)
-    return MP_RANGE;
-
-  /* Initialize all these variables we need */
-  MP_CHECKOK( mp_init(&u) );
-  clean[++last] = &u;
-  MP_CHECKOK( mp_init(&v) );
-  clean[++last] = &v;
-  MP_CHECKOK( mp_init(&gx) );
-  clean[++last] = &gx;
-  MP_CHECKOK( mp_init(&A) );
-  clean[++last] = &A;
-  MP_CHECKOK( mp_init(&B) );
-  clean[++last] = &B;
-  MP_CHECKOK( mp_init(&C) );
-  clean[++last] = &C;
-  MP_CHECKOK( mp_init(&D) );
-  clean[++last] = &D;
-  MP_CHECKOK( mp_init_copy(&xc, a) );
-  clean[++last] = &xc;
-  mp_abs(&xc, &xc);
-  MP_CHECKOK( mp_init_copy(&yc, b) );
-  clean[++last] = &yc;
-  mp_abs(&yc, &yc);
-
-  mp_set(&gx, 1);
-
-  /* Divide by two until at least one of them is odd */
-  while(mp_iseven(&xc) && mp_iseven(&yc)) {
-    mp_size nx = mp_trailing_zeros(&xc);
-    mp_size ny = mp_trailing_zeros(&yc);
-    mp_size n  = MP_MIN(nx, ny);
-    s_mp_div_2d(&xc,n);
-    s_mp_div_2d(&yc,n);
-    MP_CHECKOK( s_mp_mul_2d(&gx,n) );
-  }
-
-  MP_CHECKOK(mp_copy(&xc, &u));
-  MP_CHECKOK(mp_copy(&yc, &v));
-  mp_set(&A, 1); mp_set(&D, 1);
-
-  /* Loop through binary GCD algorithm */
-  do {
-    while(mp_iseven(&u)) {
-      s_mp_div_2(&u);
-
-      if(mp_iseven(&A) && mp_iseven(&B)) {
-	s_mp_div_2(&A); s_mp_div_2(&B);
-      } else {
-	MP_CHECKOK( mp_add(&A, &yc, &A) );
-	s_mp_div_2(&A);
-	MP_CHECKOK( mp_sub(&B, &xc, &B) );
-	s_mp_div_2(&B);
-      }
-    }
-
-    while(mp_iseven(&v)) {
-      s_mp_div_2(&v);
-
-      if(mp_iseven(&C) && mp_iseven(&D)) {
-	s_mp_div_2(&C); s_mp_div_2(&D);
-      } else {
-	MP_CHECKOK( mp_add(&C, &yc, &C) );
-	s_mp_div_2(&C);
-	MP_CHECKOK( mp_sub(&D, &xc, &D) );
-	s_mp_div_2(&D);
-      }
-    }
-
-    if(mp_cmp(&u, &v) >= 0) {
-      MP_CHECKOK( mp_sub(&u, &v, &u) );
-      MP_CHECKOK( mp_sub(&A, &C, &A) );
-      MP_CHECKOK( mp_sub(&B, &D, &B) );
-    } else {
-      MP_CHECKOK( mp_sub(&v, &u, &v) );
-      MP_CHECKOK( mp_sub(&C, &A, &C) );
-      MP_CHECKOK( mp_sub(&D, &B, &D) );
+    mp_int gx, xc, yc, u, v, A, B, C, D;
+    mp_int *clean[9];
+    mp_err res;
+    int last = -1;
+
+    if (mp_cmp_z(b) == 0)
+        return MP_RANGE;
+
+    /* Initialize all these variables we need */
+    MP_CHECKOK(mp_init(&u));
+    clean[++last] = &u;
+    MP_CHECKOK(mp_init(&v));
+    clean[++last] = &v;
+    MP_CHECKOK(mp_init(&gx));
+    clean[++last] = &gx;
+    MP_CHECKOK(mp_init(&A));
+    clean[++last] = &A;
+    MP_CHECKOK(mp_init(&B));
+    clean[++last] = &B;
+    MP_CHECKOK(mp_init(&C));
+    clean[++last] = &C;
+    MP_CHECKOK(mp_init(&D));
+    clean[++last] = &D;
+    MP_CHECKOK(mp_init_copy(&xc, a));
+    clean[++last] = &xc;
+    mp_abs(&xc, &xc);
+    MP_CHECKOK(mp_init_copy(&yc, b));
+    clean[++last] = &yc;
+    mp_abs(&yc, &yc);
+
+    mp_set(&gx, 1);
+
+    /* Divide by two until at least one of them is odd */
+    while (mp_iseven(&xc) && mp_iseven(&yc)) {
+        mp_size nx = mp_trailing_zeros(&xc);
+        mp_size ny = mp_trailing_zeros(&yc);
+        mp_size n = MP_MIN(nx, ny);
+        s_mp_div_2d(&xc, n);
+        s_mp_div_2d(&yc, n);
+        MP_CHECKOK(s_mp_mul_2d(&gx, n));
     }
-  } while (mp_cmp_z(&u) != 0);
 
-  /* copy results to output */
-  if(x)
-    MP_CHECKOK( mp_copy(&C, x) );
+    MP_CHECKOK(mp_copy(&xc, &u));
+    MP_CHECKOK(mp_copy(&yc, &v));
+    mp_set(&A, 1);
+    mp_set(&D, 1);
+
+    /* Loop through binary GCD algorithm */
+    do {
+        while (mp_iseven(&u)) {
+            s_mp_div_2(&u);
+
+            if (mp_iseven(&A) && mp_iseven(&B)) {
+                s_mp_div_2(&A);
+                s_mp_div_2(&B);
+            } else {
+                MP_CHECKOK(mp_add(&A, &yc, &A));
+                s_mp_div_2(&A);
+                MP_CHECKOK(mp_sub(&B, &xc, &B));
+                s_mp_div_2(&B);
+            }
+        }
+
+        while (mp_iseven(&v)) {
+            s_mp_div_2(&v);
+
+            if (mp_iseven(&C) && mp_iseven(&D)) {
+                s_mp_div_2(&C);
+                s_mp_div_2(&D);
+            } else {
+                MP_CHECKOK(mp_add(&C, &yc, &C));
+                s_mp_div_2(&C);
+                MP_CHECKOK(mp_sub(&D, &xc, &D));
+                s_mp_div_2(&D);
+            }
+        }
+
+        if (mp_cmp(&u, &v) >= 0) {
+            MP_CHECKOK(mp_sub(&u, &v, &u));
+            MP_CHECKOK(mp_sub(&A, &C, &A));
+            MP_CHECKOK(mp_sub(&B, &D, &B));
+        } else {
+            MP_CHECKOK(mp_sub(&v, &u, &v));
+            MP_CHECKOK(mp_sub(&C, &A, &C));
+            MP_CHECKOK(mp_sub(&D, &B, &D));
+        }
+    } while (mp_cmp_z(&u) != 0);
+
+    /* copy results to output */
+    if (x)
+        MP_CHECKOK(mp_copy(&C, x));
+
+    if (y)
+        MP_CHECKOK(mp_copy(&D, y));
+
+    if (g)
+        MP_CHECKOK(mp_mul(&gx, &v, g));
 
-  if(y)
-    MP_CHECKOK( mp_copy(&D, y) );
-      
-  if(g)
-    MP_CHECKOK( mp_mul(&gx, &v, g) );
-
- CLEANUP:
-  while(last >= 0)
-    mp_clear(clean[last--]);
+CLEANUP:
+    while (last >= 0)
+        mp_clear(clean[last--]);
 
-  return res;
+    return res;
 
 } /* end mp_xgcd() */
 
 /* }}} */
 
-mp_size mp_trailing_zeros(const mp_int *mp)
+mp_size
+mp_trailing_zeros(const mp_int *mp)
 {
-  mp_digit d;
-  mp_size  n = 0;
-  unsigned int      ix;
+    mp_digit d;
+    mp_size n = 0;
+    unsigned int ix;
 
-  if (!mp || !MP_DIGITS(mp) || !mp_cmp_z(mp))
-    return n;
+    if (!mp || !MP_DIGITS(mp) || !mp_cmp_z(mp))
+        return n;
 
-  for (ix = 0; !(d = MP_DIGIT(mp,ix)) && (ix < MP_USED(mp)); ++ix)
-    n += MP_DIGIT_BIT;
-  if (!d)
-    return 0;	/* shouldn't happen, but ... */
+    for (ix = 0; !(d = MP_DIGIT(mp, ix)) && (ix < MP_USED(mp)); ++ix)
+        n += MP_DIGIT_BIT;
+    if (!d)
+        return 0; /* shouldn't happen, but ... */
 #if !defined(MP_USE_UINT_DIGIT)
-  if (!(d & 0xffffffffU)) {
-    d >>= 32;
-    n  += 32;
-  }
+    if (!(d & 0xffffffffU)) {
+        d >>= 32;
+        n += 32;
+    }
 #endif
-  if (!(d & 0xffffU)) {
-    d >>= 16;
-    n  += 16;
-  }
-  if (!(d & 0xffU)) {
-    d >>= 8;
-    n  += 8;
-  }
-  if (!(d & 0xfU)) {
-    d >>= 4;
-    n  += 4;
-  }
-  if (!(d & 0x3U)) {
-    d >>= 2;
-    n  += 2;
-  }
-  if (!(d & 0x1U)) {
-    d >>= 1;
-    n  += 1;
-  }
+    if (!(d & 0xffffU)) {
+        d >>= 16;
+        n += 16;
+    }
+    if (!(d & 0xffU)) {
+        d >>= 8;
+        n += 8;
+    }
+    if (!(d & 0xfU)) {
+        d >>= 4;
+        n += 4;
+    }
+    if (!(d & 0x3U)) {
+        d >>= 2;
+        n += 2;
+    }
+    if (!(d & 0x1U)) {
+        d >>= 1;
+        n += 1;
+    }
 #if MP_ARGCHK == 2
-  assert(0 != (d & 1));
+    assert(0 != (d & 1));
 #endif
-  return n;
+    return n;
 }
 
 /* Given a and prime p, computes c and k such that a*c == 2**k (mod p).
@@ -2026,337 +2071,343 @@ mp_size mp_trailing_zeros(const mp_int *mp)
 ** This technique from the paper "Fast Modular Reciprocals" (unpublished)
 ** by Richard Schroeppel (a.k.a. Captain Nemo).
 */
-mp_err s_mp_almost_inverse(const mp_int *a, const mp_int *p, mp_int *c)
+mp_err
+s_mp_almost_inverse(const mp_int *a, const mp_int *p, mp_int *c)
 {
-  mp_err res;
-  mp_err k    = 0;
-  mp_int d, f, g;
-
-  ARGCHK(a && p && c, MP_BADARG);
-
-  MP_DIGITS(&d) = 0;
-  MP_DIGITS(&f) = 0;
-  MP_DIGITS(&g) = 0;
-  MP_CHECKOK( mp_init(&d) );
-  MP_CHECKOK( mp_init_copy(&f, a) );	/* f = a */
-  MP_CHECKOK( mp_init_copy(&g, p) );	/* g = p */
-
-  mp_set(c, 1);
-  mp_zero(&d);
-
-  if (mp_cmp_z(&f) == 0) {
-    res = MP_UNDEF;
-  } else 
-  for (;;) {
-    int diff_sign;
-    while (mp_iseven(&f)) {
-      mp_size n = mp_trailing_zeros(&f);
-      if (!n) {
-	res = MP_UNDEF;
-	goto CLEANUP;
-      }
-      s_mp_div_2d(&f, n);
-      MP_CHECKOK( s_mp_mul_2d(&d, n) );
-      k += n;
-    }
-    if (mp_cmp_d(&f, 1) == MP_EQ) {	/* f == 1 */
-      res = k;
-      break;
-    }
-    diff_sign = mp_cmp(&f, &g);
-    if (diff_sign < 0) {		/* f < g */
-      s_mp_exch(&f, &g);
-      s_mp_exch(c, &d);
-    } else if (diff_sign == 0) {		/* f == g */
-      res = MP_UNDEF;		/* a and p are not relatively prime */
-      break;
-    }
-    if ((MP_DIGIT(&f,0) % 4) == (MP_DIGIT(&g,0) % 4)) {
-      MP_CHECKOK( mp_sub(&f, &g, &f) );	/* f = f - g */
-      MP_CHECKOK( mp_sub(c,  &d,  c) );	/* c = c - d */
-    } else {
-      MP_CHECKOK( mp_add(&f, &g, &f) );	/* f = f + g */
-      MP_CHECKOK( mp_add(c,  &d,  c) );	/* c = c + d */
+    mp_err res;
+    mp_err k = 0;
+    mp_int d, f, g;
+
+    ARGCHK(a && p && c, MP_BADARG);
+
+    MP_DIGITS(&d) = 0;
+    MP_DIGITS(&f) = 0;
+    MP_DIGITS(&g) = 0;
+    MP_CHECKOK(mp_init(&d));
+    MP_CHECKOK(mp_init_copy(&f, a)); /* f = a */
+    MP_CHECKOK(mp_init_copy(&g, p)); /* g = p */
+
+    mp_set(c, 1);
+    mp_zero(&d);
+
+    if (mp_cmp_z(&f) == 0) {
+        res = MP_UNDEF;
+    } else
+        for (;;) {
+            int diff_sign;
+            while (mp_iseven(&f)) {
+                mp_size n = mp_trailing_zeros(&f);
+                if (!n) {
+                    res = MP_UNDEF;
+                    goto CLEANUP;
+                }
+                s_mp_div_2d(&f, n);
+                MP_CHECKOK(s_mp_mul_2d(&d, n));
+                k += n;
+            }
+            if (mp_cmp_d(&f, 1) == MP_EQ) { /* f == 1 */
+                res = k;
+                break;
+            }
+            diff_sign = mp_cmp(&f, &g);
+            if (diff_sign < 0) { /* f < g */
+                s_mp_exch(&f, &g);
+                s_mp_exch(c, &d);
+            } else if (diff_sign == 0) { /* f == g */
+                res = MP_UNDEF;          /* a and p are not relatively prime */
+                break;
+            }
+            if ((MP_DIGIT(&f, 0) % 4) == (MP_DIGIT(&g, 0) % 4)) {
+                MP_CHECKOK(mp_sub(&f, &g, &f)); /* f = f - g */
+                MP_CHECKOK(mp_sub(c, &d, c));   /* c = c - d */
+            } else {
+                MP_CHECKOK(mp_add(&f, &g, &f)); /* f = f + g */
+                MP_CHECKOK(mp_add(c, &d, c));   /* c = c + d */
+            }
+        }
+    if (res >= 0) {
+        while (MP_SIGN(c) != MP_ZPOS) {
+            MP_CHECKOK(mp_add(c, p, c));
+        }
+        res = k;
     }
-  }
-  if (res >= 0) {
-    while (MP_SIGN(c) != MP_ZPOS) {
-      MP_CHECKOK( mp_add(c, p, c) );
-    }
-    res = k;
-  }
 
 CLEANUP:
-  mp_clear(&d);
-  mp_clear(&f);
-  mp_clear(&g);
-  return res;
+    mp_clear(&d);
+    mp_clear(&f);
+    mp_clear(&g);
+    return res;
 }
 
 /* Compute T = (P ** -1) mod MP_RADIX.  Also works for 16-bit mp_digits.
 ** This technique from the paper "Fast Modular Reciprocals" (unpublished)
 ** by Richard Schroeppel (a.k.a. Captain Nemo).
 */
-mp_digit  s_mp_invmod_radix(mp_digit P)
+mp_digit
+s_mp_invmod_radix(mp_digit P)
 {
-  mp_digit T = P;
-  T *= 2 - (P * T);
-  T *= 2 - (P * T);
-  T *= 2 - (P * T);
-  T *= 2 - (P * T);
+    mp_digit T = P;
+    T *= 2 - (P * T);
+    T *= 2 - (P * T);
+    T *= 2 - (P * T);
+    T *= 2 - (P * T);
 #if !defined(MP_USE_UINT_DIGIT)
-  T *= 2 - (P * T);
-  T *= 2 - (P * T);
+    T *= 2 - (P * T);
+    T *= 2 - (P * T);
 #endif
-  return T;
+    return T;
 }
 
-/* Given c, k, and prime p, where a*c == 2**k (mod p), 
+/* Given c, k, and prime p, where a*c == 2**k (mod p),
 ** Compute x = (a ** -1) mod p.  This is similar to Montgomery reduction.
 ** This technique from the paper "Fast Modular Reciprocals" (unpublished)
 ** by Richard Schroeppel (a.k.a. Captain Nemo).
 */
-mp_err  s_mp_fixup_reciprocal(const mp_int *c, const mp_int *p, int k, mp_int *x)
+mp_err
+s_mp_fixup_reciprocal(const mp_int *c, const mp_int *p, int k, mp_int *x)
 {
-  int      k_orig = k;
-  mp_digit r;
-  mp_size  ix;
-  mp_err   res;
-
-  if (mp_cmp_z(c) < 0) {		/* c < 0 */
-    MP_CHECKOK( mp_add(c, p, x) );	/* x = c + p */
-  } else {
-    MP_CHECKOK( mp_copy(c, x) );	/* x = c */
-  }
-
-  /* make sure x is large enough */
-  ix = MP_HOWMANY(k, MP_DIGIT_BIT) + MP_USED(p) + 1;
-  ix = MP_MAX(ix, MP_USED(x));
-  MP_CHECKOK( s_mp_pad(x, ix) );
-
-  r = 0 - s_mp_invmod_radix(MP_DIGIT(p,0));
-
-  for (ix = 0; k > 0; ix++) {
-    int      j = MP_MIN(k, MP_DIGIT_BIT);
-    mp_digit v = r * MP_DIGIT(x, ix);
-    if (j < MP_DIGIT_BIT) {
-      v &= ((mp_digit)1 << j) - 1;	/* v = v mod (2 ** j) */
-    }
-    s_mp_mul_d_add_offset(p, v, x, ix); /* x += p * v * (RADIX ** ix) */
-    k -= j;
-  }
-  s_mp_clamp(x);
-  s_mp_div_2d(x, k_orig);
-  res = MP_OKAY;
+    int k_orig = k;
+    mp_digit r;
+    mp_size ix;
+    mp_err res;
+
+    if (mp_cmp_z(c) < 0) {           /* c < 0 */
+        MP_CHECKOK(mp_add(c, p, x)); /* x = c + p */
+    } else {
+        MP_CHECKOK(mp_copy(c, x)); /* x = c */
+    }
+
+    /* make sure x is large enough */
+    ix = MP_HOWMANY(k, MP_DIGIT_BIT) + MP_USED(p) + 1;
+    ix = MP_MAX(ix, MP_USED(x));
+    MP_CHECKOK(s_mp_pad(x, ix));
+
+    r = 0 - s_mp_invmod_radix(MP_DIGIT(p, 0));
+
+    for (ix = 0; k > 0; ix++) {
+        int j = MP_MIN(k, MP_DIGIT_BIT);
+        mp_digit v = r * MP_DIGIT(x, ix);
+        if (j < MP_DIGIT_BIT) {
+            v &= ((mp_digit)1 << j) - 1; /* v = v mod (2 ** j) */
+        }
+        s_mp_mul_d_add_offset(p, v, x, ix); /* x += p * v * (RADIX ** ix) */
+        k -= j;
+    }
+    s_mp_clamp(x);
+    s_mp_div_2d(x, k_orig);
+    res = MP_OKAY;
 
 CLEANUP:
-  return res;
+    return res;
 }
 
 /* compute mod inverse using Schroeppel's method, only if m is odd */
-mp_err s_mp_invmod_odd_m(const mp_int *a, const mp_int *m, mp_int *c)
+mp_err
+s_mp_invmod_odd_m(const mp_int *a, const mp_int *m, mp_int *c)
 {
-  int k;
-  mp_err  res;
-  mp_int  x;
-
-  ARGCHK(a && m && c, MP_BADARG);
+    int k;
+    mp_err res;
+    mp_int x;
 
-  if(mp_cmp_z(a) == 0 || mp_cmp_z(m) == 0)
-    return MP_RANGE;
-  if (mp_iseven(m))
-    return MP_UNDEF;
+    ARGCHK(a && m && c, MP_BADARG);
 
-  MP_DIGITS(&x) = 0;
+    if (mp_cmp_z(a) == 0 || mp_cmp_z(m) == 0)
+        return MP_RANGE;
+    if (mp_iseven(m))
+        return MP_UNDEF;
 
-  if (a == c) {
-    if ((res = mp_init_copy(&x, a)) != MP_OKAY)
-      return res;
-    if (a == m) 
-      m = &x;
-    a = &x;
-  } else if (m == c) {
-    if ((res = mp_init_copy(&x, m)) != MP_OKAY)
-      return res;
-    m = &x;
-  } else {
     MP_DIGITS(&x) = 0;
-  }
 
-  MP_CHECKOK( s_mp_almost_inverse(a, m, c) );
-  k = res;
-  MP_CHECKOK( s_mp_fixup_reciprocal(c, m, k, c) );
+    if (a == c) {
+        if ((res = mp_init_copy(&x, a)) != MP_OKAY)
+            return res;
+        if (a == m)
+            m = &x;
+        a = &x;
+    } else if (m == c) {
+        if ((res = mp_init_copy(&x, m)) != MP_OKAY)
+            return res;
+        m = &x;
+    } else {
+        MP_DIGITS(&x) = 0;
+    }
+
+    MP_CHECKOK(s_mp_almost_inverse(a, m, c));
+    k = res;
+    MP_CHECKOK(s_mp_fixup_reciprocal(c, m, k, c));
 CLEANUP:
-  mp_clear(&x);
-  return res;
+    mp_clear(&x);
+    return res;
 }
 
 /* Known good algorithm for computing modular inverse.  But slow. */
-mp_err mp_invmod_xgcd(const mp_int *a, const mp_int *m, mp_int *c)
+mp_err
+mp_invmod_xgcd(const mp_int *a, const mp_int *m, mp_int *c)
 {
-  mp_int  g, x;
-  mp_err  res;
+    mp_int g, x;
+    mp_err res;
 
-  ARGCHK(a && m && c, MP_BADARG);
+    ARGCHK(a && m && c, MP_BADARG);
 
-  if(mp_cmp_z(a) == 0 || mp_cmp_z(m) == 0)
-    return MP_RANGE;
+    if (mp_cmp_z(a) == 0 || mp_cmp_z(m) == 0)
+        return MP_RANGE;
 
-  MP_DIGITS(&g) = 0;
-  MP_DIGITS(&x) = 0;
-  MP_CHECKOK( mp_init(&x) );
-  MP_CHECKOK( mp_init(&g) );
+    MP_DIGITS(&g) = 0;
+    MP_DIGITS(&x) = 0;
+    MP_CHECKOK(mp_init(&x));
+    MP_CHECKOK(mp_init(&g));
 
-  MP_CHECKOK( mp_xgcd(a, m, &g, &x, NULL) );
+    MP_CHECKOK(mp_xgcd(a, m, &g, &x, NULL));
 
-  if (mp_cmp_d(&g, 1) != MP_EQ) {
-    res = MP_UNDEF;
-    goto CLEANUP;
-  }
+    if (mp_cmp_d(&g, 1) != MP_EQ) {
+        res = MP_UNDEF;
+        goto CLEANUP;
+    }
 
-  res = mp_mod(&x, m, c);
-  SIGN(c) = SIGN(a);
+    res = mp_mod(&x, m, c);
+    SIGN(c) = SIGN(a);
 
 CLEANUP:
-  mp_clear(&x);
-  mp_clear(&g);
+    mp_clear(&x);
+    mp_clear(&g);
 
-  return res;
+    return res;
 }
 
 /* modular inverse where modulus is 2**k. */
 /* c = a**-1 mod 2**k */
-mp_err s_mp_invmod_2d(const mp_int *a, mp_size k, mp_int *c)
+mp_err
+s_mp_invmod_2d(const mp_int *a, mp_size k, mp_int *c)
 {
-  mp_err res;
-  mp_size ix = k + 4;
-  mp_int t0, t1, val, tmp, two2k;
-
-  static const mp_digit d2 = 2;
-  static const mp_int two = { MP_ZPOS, 1, 1, (mp_digit *)&d2 };
-
-  if (mp_iseven(a))
-    return MP_UNDEF;
-  if (k <= MP_DIGIT_BIT) {
-    mp_digit i = s_mp_invmod_radix(MP_DIGIT(a,0));
-    if (k < MP_DIGIT_BIT)
-      i &= ((mp_digit)1 << k) - (mp_digit)1;
-    mp_set(c, i);
-    return MP_OKAY;
-  }
-  MP_DIGITS(&t0) = 0;
-  MP_DIGITS(&t1) = 0;
-  MP_DIGITS(&val) = 0;
-  MP_DIGITS(&tmp) = 0;
-  MP_DIGITS(&two2k) = 0;
-  MP_CHECKOK( mp_init_copy(&val, a) );
-  s_mp_mod_2d(&val, k);
-  MP_CHECKOK( mp_init_copy(&t0, &val) );
-  MP_CHECKOK( mp_init_copy(&t1, &t0)  );
-  MP_CHECKOK( mp_init(&tmp) );
-  MP_CHECKOK( mp_init(&two2k) );
-  MP_CHECKOK( s_mp_2expt(&two2k, k) );
-  do {
-    MP_CHECKOK( mp_mul(&val, &t1, &tmp)  );
-    MP_CHECKOK( mp_sub(&two, &tmp, &tmp) );
-    MP_CHECKOK( mp_mul(&t1, &tmp, &t1)   );
-    s_mp_mod_2d(&t1, k);
-    while (MP_SIGN(&t1) != MP_ZPOS) {
-      MP_CHECKOK( mp_add(&t1, &two2k, &t1) );
-    }
-    if (mp_cmp(&t1, &t0) == MP_EQ) 
-      break;
-    MP_CHECKOK( mp_copy(&t1, &t0) );
-  } while (--ix > 0);
-  if (!ix) {
-    res = MP_UNDEF;
-  } else {
-    mp_exch(c, &t1);
-  }
+    mp_err res;
+    mp_size ix = k + 4;
+    mp_int t0, t1, val, tmp, two2k;
+
+    static const mp_digit d2 = 2;
+    static const mp_int two = { MP_ZPOS, 1, 1, (mp_digit *)&d2 };
+
+    if (mp_iseven(a))
+        return MP_UNDEF;
+    if (k <= MP_DIGIT_BIT) {
+        mp_digit i = s_mp_invmod_radix(MP_DIGIT(a, 0));
+        if (k < MP_DIGIT_BIT)
+            i &= ((mp_digit)1 << k) - (mp_digit)1;
+        mp_set(c, i);
+        return MP_OKAY;
+    }
+    MP_DIGITS(&t0) = 0;
+    MP_DIGITS(&t1) = 0;
+    MP_DIGITS(&val) = 0;
+    MP_DIGITS(&tmp) = 0;
+    MP_DIGITS(&two2k) = 0;
+    MP_CHECKOK(mp_init_copy(&val, a));
+    s_mp_mod_2d(&val, k);
+    MP_CHECKOK(mp_init_copy(&t0, &val));
+    MP_CHECKOK(mp_init_copy(&t1, &t0));
+    MP_CHECKOK(mp_init(&tmp));
+    MP_CHECKOK(mp_init(&two2k));
+    MP_CHECKOK(s_mp_2expt(&two2k, k));
+    do {
+        MP_CHECKOK(mp_mul(&val, &t1, &tmp));
+        MP_CHECKOK(mp_sub(&two, &tmp, &tmp));
+        MP_CHECKOK(mp_mul(&t1, &tmp, &t1));
+        s_mp_mod_2d(&t1, k);
+        while (MP_SIGN(&t1) != MP_ZPOS) {
+            MP_CHECKOK(mp_add(&t1, &two2k, &t1));
+        }
+        if (mp_cmp(&t1, &t0) == MP_EQ)
+            break;
+        MP_CHECKOK(mp_copy(&t1, &t0));
+    } while (--ix > 0);
+    if (!ix) {
+        res = MP_UNDEF;
+    } else {
+        mp_exch(c, &t1);
+    }
 
 CLEANUP:
-  mp_clear(&t0);
-  mp_clear(&t1);
-  mp_clear(&val);
-  mp_clear(&tmp);
-  mp_clear(&two2k);
-  return res;
+    mp_clear(&t0);
+    mp_clear(&t1);
+    mp_clear(&val);
+    mp_clear(&tmp);
+    mp_clear(&two2k);
+    return res;
 }
 
-mp_err s_mp_invmod_even_m(const mp_int *a, const mp_int *m, mp_int *c)
+mp_err
+s_mp_invmod_even_m(const mp_int *a, const mp_int *m, mp_int *c)
 {
-  mp_err res;
-  mp_size k;
-  mp_int oddFactor, evenFactor;	/* factors of the modulus */
-  mp_int oddPart, evenPart;	/* parts to combine via CRT. */
-  mp_int C2, tmp1, tmp2;
-
-  /*static const mp_digit d1 = 1; */
-  /*static const mp_int one = { MP_ZPOS, 1, 1, (mp_digit *)&d1 }; */
-
-  if ((res = s_mp_ispow2(m)) >= 0) {
-    k = res;
-    return s_mp_invmod_2d(a, k, c);
-  }
-  MP_DIGITS(&oddFactor) = 0;
-  MP_DIGITS(&evenFactor) = 0;
-  MP_DIGITS(&oddPart) = 0;
-  MP_DIGITS(&evenPart) = 0;
-  MP_DIGITS(&C2)     = 0;
-  MP_DIGITS(&tmp1)   = 0;
-  MP_DIGITS(&tmp2)   = 0;
-
-  MP_CHECKOK( mp_init_copy(&oddFactor, m) );    /* oddFactor = m */
-  MP_CHECKOK( mp_init(&evenFactor) );
-  MP_CHECKOK( mp_init(&oddPart) );
-  MP_CHECKOK( mp_init(&evenPart) );
-  MP_CHECKOK( mp_init(&C2)     );
-  MP_CHECKOK( mp_init(&tmp1)   );
-  MP_CHECKOK( mp_init(&tmp2)   );
-
-  k = mp_trailing_zeros(m);
-  s_mp_div_2d(&oddFactor, k);
-  MP_CHECKOK( s_mp_2expt(&evenFactor, k) );
-
-  /* compute a**-1 mod oddFactor. */
-  MP_CHECKOK( s_mp_invmod_odd_m(a, &oddFactor, &oddPart) );
-  /* compute a**-1 mod evenFactor, where evenFactor == 2**k. */
-  MP_CHECKOK( s_mp_invmod_2d(   a,       k,    &evenPart) );
-
-  /* Use Chinese Remainer theorem to compute a**-1 mod m. */
-  /* let m1 = oddFactor,  v1 = oddPart, 
-   * let m2 = evenFactor, v2 = evenPart.
-   */
+    mp_err res;
+    mp_size k;
+    mp_int oddFactor, evenFactor; /* factors of the modulus */
+    mp_int oddPart, evenPart;     /* parts to combine via CRT. */
+    mp_int C2, tmp1, tmp2;
+
+    /*static const mp_digit d1 = 1; */
+    /*static const mp_int one = { MP_ZPOS, 1, 1, (mp_digit *)&d1 }; */
+
+    if ((res = s_mp_ispow2(m)) >= 0) {
+        k = res;
+        return s_mp_invmod_2d(a, k, c);
+    }
+    MP_DIGITS(&oddFactor) = 0;
+    MP_DIGITS(&evenFactor) = 0;
+    MP_DIGITS(&oddPart) = 0;
+    MP_DIGITS(&evenPart) = 0;
+    MP_DIGITS(&C2) = 0;
+    MP_DIGITS(&tmp1) = 0;
+    MP_DIGITS(&tmp2) = 0;
+
+    MP_CHECKOK(mp_init_copy(&oddFactor, m)); /* oddFactor = m */
+    MP_CHECKOK(mp_init(&evenFactor));
+    MP_CHECKOK(mp_init(&oddPart));
+    MP_CHECKOK(mp_init(&evenPart));
+    MP_CHECKOK(mp_init(&C2));
+    MP_CHECKOK(mp_init(&tmp1));
+    MP_CHECKOK(mp_init(&tmp2));
+
+    k = mp_trailing_zeros(m);
+    s_mp_div_2d(&oddFactor, k);
+    MP_CHECKOK(s_mp_2expt(&evenFactor, k));
+
+    /* compute a**-1 mod oddFactor. */
+    MP_CHECKOK(s_mp_invmod_odd_m(a, &oddFactor, &oddPart));
+    /* compute a**-1 mod evenFactor, where evenFactor == 2**k. */
+    MP_CHECKOK(s_mp_invmod_2d(a, k, &evenPart));
+
+    /* Use Chinese Remainer theorem to compute a**-1 mod m. */
+    /* let m1 = oddFactor,  v1 = oddPart,
+     * let m2 = evenFactor, v2 = evenPart.
+     */
 
-  /* Compute C2 = m1**-1 mod m2. */
-  MP_CHECKOK( s_mp_invmod_2d(&oddFactor, k,    &C2) );
+    /* Compute C2 = m1**-1 mod m2. */
+    MP_CHECKOK(s_mp_invmod_2d(&oddFactor, k, &C2));
 
-  /* compute u = (v2 - v1)*C2 mod m2 */
-  MP_CHECKOK( mp_sub(&evenPart, &oddPart,   &tmp1) );
-  MP_CHECKOK( mp_mul(&tmp1,     &C2,        &tmp2) );
-  s_mp_mod_2d(&tmp2, k);
-  while (MP_SIGN(&tmp2) != MP_ZPOS) {
-    MP_CHECKOK( mp_add(&tmp2, &evenFactor, &tmp2) );
-  }
+    /* compute u = (v2 - v1)*C2 mod m2 */
+    MP_CHECKOK(mp_sub(&evenPart, &oddPart, &tmp1));
+    MP_CHECKOK(mp_mul(&tmp1, &C2, &tmp2));
+    s_mp_mod_2d(&tmp2, k);
+    while (MP_SIGN(&tmp2) != MP_ZPOS) {
+        MP_CHECKOK(mp_add(&tmp2, &evenFactor, &tmp2));
+    }
 
-  /* compute answer = v1 + u*m1 */
-  MP_CHECKOK( mp_mul(&tmp2,     &oddFactor, c) );
-  MP_CHECKOK( mp_add(&oddPart,  c,          c) );
-  /* not sure this is necessary, but it's low cost if not. */
-  MP_CHECKOK( mp_mod(c,         m,          c) );
+    /* compute answer = v1 + u*m1 */
+    MP_CHECKOK(mp_mul(&tmp2, &oddFactor, c));
+    MP_CHECKOK(mp_add(&oddPart, c, c));
+    /* not sure this is necessary, but it's low cost if not. */
+    MP_CHECKOK(mp_mod(c, m, c));
 
 CLEANUP:
-  mp_clear(&oddFactor);
-  mp_clear(&evenFactor);
-  mp_clear(&oddPart);
-  mp_clear(&evenPart);
-  mp_clear(&C2);
-  mp_clear(&tmp1);
-  mp_clear(&tmp2);
-  return res;
+    mp_clear(&oddFactor);
+    mp_clear(&evenFactor);
+    mp_clear(&oddPart);
+    mp_clear(&evenPart);
+    mp_clear(&C2);
+    mp_clear(&tmp1);
+    mp_clear(&tmp2);
+    return res;
 }
 
-
 /* {{{ mp_invmod(a, m, c) */
 
 /*
@@ -2367,21 +2418,22 @@ CLEANUP:
   MP_UNDEF is returned, and there is no inverse.
  */
 
-mp_err mp_invmod(const mp_int *a, const mp_int *m, mp_int *c)
+mp_err
+mp_invmod(const mp_int *a, const mp_int *m, mp_int *c)
 {
 
-  ARGCHK(a && m && c, MP_BADARG);
+    ARGCHK(a && m && c, MP_BADARG);
 
-  if(mp_cmp_z(a) == 0 || mp_cmp_z(m) == 0)
-    return MP_RANGE;
+    if (mp_cmp_z(a) == 0 || mp_cmp_z(m) == 0)
+        return MP_RANGE;
 
-  if (mp_isodd(m)) {
-    return s_mp_invmod_odd_m(a, m, c);
-  }
-  if (mp_iseven(a))
-    return MP_UNDEF;	/* not invertable */
+    if (mp_isodd(m)) {
+        return s_mp_invmod_odd_m(a, m, c);
+    }
+    if (mp_iseven(a))
+        return MP_UNDEF; /* not invertable */
 
-  return s_mp_invmod_even_m(a, m, c);
+    return s_mp_invmod_even_m(a, m, c);
 
 } /* end mp_invmod() */
 
@@ -2401,18 +2453,19 @@ mp_err mp_invmod(const mp_int *a, const mp_int *m, mp_int *c)
   stream 'ofp'.  Output is generated using the internal radix.
  */
 
-void   mp_print(mp_int *mp, FILE *ofp)
+void
+mp_print(mp_int *mp, FILE *ofp)
 {
-  int   ix;
+    int ix;
 
-  if(mp == NULL || ofp == NULL)
-    return;
+    if (mp == NULL || ofp == NULL)
+        return;
 
-  fputc((SIGN(mp) == NEG) ? '-' : '+', ofp);
+    fputc((SIGN(mp) == NEG) ? '-' : '+', ofp);
 
-  for(ix = USED(mp) - 1; ix >= 0; ix--) {
-    fprintf(ofp, DIGIT_FMT, DIGIT(mp, ix));
-  }
+    for (ix = USED(mp) - 1; ix >= 0; ix--) {
+        fprintf(ofp, DIGIT_FMT, DIGIT(mp, ix));
+    }
 
 } /* end mp_print() */
 
@@ -2425,37 +2478,38 @@ void   mp_print(mp_int *mp, FILE *ofp)
 
 /* {{{ mp_read_raw(mp, str, len) */
 
-/* 
+/*
    mp_read_raw(mp, str, len)
 
    Read in a raw value (base 256) into the given mp_int
  */
 
-mp_err  mp_read_raw(mp_int *mp, char *str, int len)
+mp_err
+mp_read_raw(mp_int *mp, char *str, int len)
 {
-  int            ix;
-  mp_err         res;
-  unsigned char *ustr = (unsigned char *)str;
+    int ix;
+    mp_err res;
+    unsigned char *ustr = (unsigned char *)str;
 
-  ARGCHK(mp != NULL && str != NULL && len > 0, MP_BADARG);
+    ARGCHK(mp != NULL && str != NULL && len > 0, MP_BADARG);
 
-  mp_zero(mp);
+    mp_zero(mp);
 
-  /* Get sign from first byte */
-  if(ustr[0])
-    SIGN(mp) = NEG;
-  else
-    SIGN(mp) = ZPOS;
-
-  /* Read the rest of the digits */
-  for(ix = 1; ix < len; ix++) {
-    if((res = mp_mul_d(mp, 256, mp)) != MP_OKAY)
-      return res;
-    if((res = mp_add_d(mp, ustr[ix], mp)) != MP_OKAY)
-      return res;
-  }
+    /* Get sign from first byte */
+    if (ustr[0])
+        SIGN(mp) = NEG;
+    else
+        SIGN(mp) = ZPOS;
+
+    /* Read the rest of the digits */
+    for (ix = 1; ix < len; ix++) {
+        if ((res = mp_mul_d(mp, 256, mp)) != MP_OKAY)
+            return res;
+        if ((res = mp_add_d(mp, ustr[ix], mp)) != MP_OKAY)
+            return res;
+    }
 
-  return MP_OKAY;
+    return MP_OKAY;
 
 } /* end mp_read_raw() */
 
@@ -2463,11 +2517,12 @@ mp_err  mp_read_raw(mp_int *mp, char *str, int len)
 
 /* {{{ mp_raw_size(mp) */
 
-int    mp_raw_size(mp_int *mp)
+int
+mp_raw_size(mp_int *mp)
 {
-  ARGCHK(mp != NULL, 0);
+    ARGCHK(mp != NULL, 0);
 
-  return (USED(mp) * sizeof(mp_digit)) + 1;
+    return (USED(mp) * sizeof(mp_digit)) + 1;
 
 } /* end mp_raw_size() */
 
@@ -2475,25 +2530,26 @@ int    mp_raw_size(mp_int *mp)
 
 /* {{{ mp_toraw(mp, str) */
 
-mp_err mp_toraw(mp_int *mp, char *str)
+mp_err
+mp_toraw(mp_int *mp, char *str)
 {
-  int  ix, jx, pos = 1;
+    int ix, jx, pos = 1;
 
-  ARGCHK(mp != NULL && str != NULL, MP_BADARG);
+    ARGCHK(mp != NULL && str != NULL, MP_BADARG);
 
-  str[0] = (char)SIGN(mp);
+    str[0] = (char)SIGN(mp);
 
-  /* Iterate over each digit... */
-  for(ix = USED(mp) - 1; ix >= 0; ix--) {
-    mp_digit  d = DIGIT(mp, ix);
+    /* Iterate over each digit... */
+    for (ix = USED(mp) - 1; ix >= 0; ix--) {
+        mp_digit d = DIGIT(mp, ix);
 
-    /* Unpack digit bytes, high order first */
-    for(jx = sizeof(mp_digit) - 1; jx >= 0; jx--) {
-      str[pos++] = (char)(d >> (jx * CHAR_BIT));
+        /* Unpack digit bytes, high order first */
+        for (jx = sizeof(mp_digit) - 1; jx >= 0; jx--) {
+            str[pos++] = (char)(d >> (jx * CHAR_BIT));
+        }
     }
-  }
 
-  return MP_OKAY;
+    return MP_OKAY;
 
 } /* end mp_toraw() */
 
@@ -2510,103 +2566,106 @@ mp_err mp_toraw(mp_int *mp, char *str)
   character or the end of the string.
  */
 
-mp_err  mp_read_radix(mp_int *mp, const char *str, int radix)
+mp_err
+mp_read_radix(mp_int *mp, const char *str, int radix)
 {
-  int     ix = 0, val = 0;
-  mp_err  res;
-  mp_sign sig = ZPOS;
-
-  ARGCHK(mp != NULL && str != NULL && radix >= 2 && radix <= MAX_RADIX, 
-	 MP_BADARG);
-
-  mp_zero(mp);
-
-  /* Skip leading non-digit characters until a digit or '-' or '+' */
-  while(str[ix] && 
-	(s_mp_tovalue(str[ix], radix) < 0) && 
-	str[ix] != '-' &&
-	str[ix] != '+') {
-    ++ix;
-  }
-
-  if(str[ix] == '-') {
-    sig = NEG;
-    ++ix;
-  } else if(str[ix] == '+') {
-    sig = ZPOS; /* this is the default anyway... */
-    ++ix;
-  }
-
-  while((val = s_mp_tovalue(str[ix], radix)) >= 0) {
-    if((res = s_mp_mul_d(mp, radix)) != MP_OKAY)
-      return res;
-    if((res = s_mp_add_d(mp, val)) != MP_OKAY)
-      return res;
-    ++ix;
-  }
-
-  if(s_mp_cmp_d(mp, 0) == MP_EQ)
-    SIGN(mp) = ZPOS;
-  else
-    SIGN(mp) = sig;
+    int ix = 0, val = 0;
+    mp_err res;
+    mp_sign sig = ZPOS;
+
+    ARGCHK(mp != NULL && str != NULL && radix >= 2 && radix <= MAX_RADIX,
+           MP_BADARG);
 
-  return MP_OKAY;
+    mp_zero(mp);
+
+    /* Skip leading non-digit characters until a digit or '-' or '+' */
+    while (str[ix] &&
+           (s_mp_tovalue(str[ix], radix) < 0) &&
+           str[ix] != '-' &&
+           str[ix] != '+') {
+        ++ix;
+    }
+
+    if (str[ix] == '-') {
+        sig = NEG;
+        ++ix;
+    } else if (str[ix] == '+') {
+        sig = ZPOS; /* this is the default anyway... */
+        ++ix;
+    }
+
+    while ((val = s_mp_tovalue(str[ix], radix)) >= 0) {
+        if ((res = s_mp_mul_d(mp, radix)) != MP_OKAY)
+            return res;
+        if ((res = s_mp_add_d(mp, val)) != MP_OKAY)
+            return res;
+        ++ix;
+    }
+
+    if (s_mp_cmp_d(mp, 0) == MP_EQ)
+        SIGN(mp) = ZPOS;
+    else
+        SIGN(mp) = sig;
+
+    return MP_OKAY;
 
 } /* end mp_read_radix() */
 
-mp_err mp_read_variable_radix(mp_int *a, const char * str, int default_radix)
+mp_err
+mp_read_variable_radix(mp_int *a, const char *str, int default_radix)
 {
-  int     radix = default_radix;
-  int     cx;
-  mp_sign sig   = ZPOS;
-  mp_err  res;
-
-  /* Skip leading non-digit characters until a digit or '-' or '+' */
-  while ((cx = *str) != 0 && 
-	(s_mp_tovalue(cx, radix) < 0) && 
-	cx != '-' &&
-	cx != '+') {
-    ++str;
-  }
-
-  if (cx == '-') {
-    sig = NEG;
-    ++str;
-  } else if (cx == '+') {
-    sig = ZPOS; /* this is the default anyway... */
-    ++str;
-  }
-
-  if (str[0] == '0') {
-    if ((str[1] | 0x20) == 'x') {
-      radix = 16;
-      str += 2;
-    } else {
-      radix = 8;
-      str++;
-    }
-  }
-  res = mp_read_radix(a, str, radix);
-  if (res == MP_OKAY) {
-    MP_SIGN(a) = (s_mp_cmp_d(a, 0) == MP_EQ) ? ZPOS : sig;
-  }
-  return res;
+    int radix = default_radix;
+    int cx;
+    mp_sign sig = ZPOS;
+    mp_err res;
+
+    /* Skip leading non-digit characters until a digit or '-' or '+' */
+    while ((cx = *str) != 0 &&
+           (s_mp_tovalue(cx, radix) < 0) &&
+           cx != '-' &&
+           cx != '+') {
+        ++str;
+    }
+
+    if (cx == '-') {
+        sig = NEG;
+        ++str;
+    } else if (cx == '+') {
+        sig = ZPOS; /* this is the default anyway... */
+        ++str;
+    }
+
+    if (str[0] == '0') {
+        if ((str[1] | 0x20) == 'x') {
+            radix = 16;
+            str += 2;
+        } else {
+            radix = 8;
+            str++;
+        }
+    }
+    res = mp_read_radix(a, str, radix);
+    if (res == MP_OKAY) {
+        MP_SIGN(a) = (s_mp_cmp_d(a, 0) == MP_EQ) ? ZPOS : sig;
+    }
+    return res;
 }
 
 /* }}} */
 
 /* {{{ mp_radix_size(mp, radix) */
 
-int    mp_radix_size(mp_int *mp, int radix)
+int
+mp_radix_size(mp_int *mp, int radix)
 {
-  int  bits;
+    int bits;
+
+    if (!mp || radix < 2 || radix > MAX_RADIX)
+        return 0;
 
-  if(!mp || radix < 2 || radix > MAX_RADIX)
-    return 0;
+    bits = USED(mp) * DIGIT_BIT - 1;
 
-  bits = USED(mp) * DIGIT_BIT - 1;
- 
-  return s_mp_outlen(bits, radix);
+    return s_mp_outlen(bits, radix);
 
 } /* end mp_radix_size() */
 
@@ -2614,64 +2673,66 @@ int    mp_radix_size(mp_int *mp, int radix)
 
 /* {{{ mp_toradix(mp, str, radix) */
 
-mp_err mp_toradix(mp_int *mp, char *str, int radix)
+mp_err
+mp_toradix(mp_int *mp, char *str, int radix)
 {
-  int  ix, pos = 0;
-
-  ARGCHK(mp != NULL && str != NULL, MP_BADARG);
-  ARGCHK(radix > 1 && radix <= MAX_RADIX, MP_RANGE);
-
-  if(mp_cmp_z(mp) == MP_EQ) {
-    str[0] = '0';
-    str[1] = '\0';
-  } else {
-    mp_err   res;
-    mp_int   tmp;
-    mp_sign  sgn;
-    mp_digit rem, rdx = (mp_digit)radix;
-    char     ch;
-
-    if((res = mp_init_copy(&tmp, mp)) != MP_OKAY)
-      return res;
-
-    /* Save sign for later, and take absolute value */
-    sgn = SIGN(&tmp); SIGN(&tmp) = ZPOS;
-
-    /* Generate output digits in reverse order      */
-    while(mp_cmp_z(&tmp) != 0) {
-      if((res = mp_div_d(&tmp, rdx, &tmp, &rem)) != MP_OKAY) {
-	mp_clear(&tmp);
-	return res;
-      }
-
-      /* Generate digits, use capital letters */
-      ch = s_mp_todigit(rem, radix, 0);
-
-      str[pos++] = ch;
-    }
-
-    /* Add - sign if original value was negative */
-    if(sgn == NEG)
-      str[pos++] = '-';
+    int ix, pos = 0;
 
-    /* Add trailing NUL to end the string        */
-    str[pos--] = '\0';
+    ARGCHK(mp != NULL && str != NULL, MP_BADARG);
+    ARGCHK(radix > 1 && radix <= MAX_RADIX, MP_RANGE);
 
-    /* Reverse the digits and sign indicator     */
-    ix = 0;
-    while(ix < pos) {
-      char tmp = str[ix];
-
-      str[ix] = str[pos];
-      str[pos] = tmp;
-      ++ix;
-      --pos;
+    if (mp_cmp_z(mp) == MP_EQ) {
+        str[0] = '0';
+        str[1] = '\0';
+    } else {
+        mp_err res;
+        mp_int tmp;
+        mp_sign sgn;
+        mp_digit rem, rdx = (mp_digit)radix;
+        char ch;
+
+        if ((res = mp_init_copy(&tmp, mp)) != MP_OKAY)
+            return res;
+
+        /* Save sign for later, and take absolute value */
+        sgn = SIGN(&tmp);
+        SIGN(&tmp) = ZPOS;
+
+        /* Generate output digits in reverse order      */
+        while (mp_cmp_z(&tmp) != 0) {
+            if ((res = mp_div_d(&tmp, rdx, &tmp, &rem)) != MP_OKAY) {
+                mp_clear(&tmp);
+                return res;
+            }
+
+            /* Generate digits, use capital letters */
+            ch = s_mp_todigit(rem, radix, 0);
+
+            str[pos++] = ch;
+        }
+
+        /* Add - sign if original value was negative */
+        if (sgn == NEG)
+            str[pos++] = '-';
+
+        /* Add trailing NUL to end the string        */
+        str[pos--] = '\0';
+
+        /* Reverse the digits and sign indicator     */
+        ix = 0;
+        while (ix < pos) {
+            char tmp = str[ix];
+
+            str[ix] = str[pos];
+            str[pos] = tmp;
+            ++ix;
+            --pos;
+        }
+
+        mp_clear(&tmp);
     }
-    
-    mp_clear(&tmp);
-  }
 
-  return MP_OKAY;
+    return MP_OKAY;
 
 } /* end mp_toradix() */
 
@@ -2679,9 +2740,10 @@ mp_err mp_toradix(mp_int *mp, char *str, int radix)
 
 /* {{{ mp_tovalue(ch, r) */
 
-int    mp_tovalue(char ch, int r)
+int
+mp_tovalue(char ch, int r)
 {
-  return s_mp_tovalue(ch, r);
+    return s_mp_tovalue(ch, r);
 
 } /* end mp_tovalue() */
 
@@ -2699,17 +2761,18 @@ int    mp_tovalue(char ch, int r)
   not attempt to modify or free the memory associated with this
   string.
  */
-const char  *mp_strerror(mp_err ec)
+const char *
+mp_strerror(mp_err ec)
 {
-  int   aec = (ec < 0) ? -ec : ec;
+    int aec = (ec < 0) ? -ec : ec;
 
-  /* Code values are negative, so the senses of these comparisons
+    /* Code values are negative, so the senses of these comparisons
      are accurate */
-  if(ec < MP_LAST_CODE || ec > MP_OKAY) {
-    return mp_err_string[0];  /* unknown error code */
-  } else {
-    return mp_err_string[aec + 1];
-  }
+    if (ec < MP_LAST_CODE || ec > MP_OKAY) {
+        return mp_err_string[0]; /* unknown error code */
+    } else {
+        return mp_err_string[aec + 1];
+    }
 
 } /* end mp_strerror() */
 
@@ -2724,26 +2787,27 @@ const char  *mp_strerror(mp_err ec)
 /* {{{ s_mp_grow(mp, min) */
 
 /* Make sure there are at least 'min' digits allocated to mp              */
-mp_err   s_mp_grow(mp_int *mp, mp_size min)
+mp_err
+s_mp_grow(mp_int *mp, mp_size min)
 {
-  if(min > ALLOC(mp)) {
-    mp_digit   *tmp;
+    if (min > ALLOC(mp)) {
+        mp_digit *tmp;
 
-    /* Set min to next nearest default precision block size */
-    min = MP_ROUNDUP(min, s_mp_defprec);
+        /* Set min to next nearest default precision block size */
+        min = MP_ROUNDUP(min, s_mp_defprec);
 
-    if((tmp = s_mp_alloc(min, sizeof(mp_digit))) == NULL)
-      return MP_MEM;
+        if ((tmp = s_mp_alloc(min, sizeof(mp_digit))) == NULL)
+            return MP_MEM;
 
-    s_mp_copy(DIGITS(mp), tmp, USED(mp));
+        s_mp_copy(DIGITS(mp), tmp, USED(mp));
 
-    s_mp_setz(DIGITS(mp), ALLOC(mp));
-    s_mp_free(DIGITS(mp));
-    DIGITS(mp) = tmp;
-    ALLOC(mp) = min;
-  }
+        s_mp_setz(DIGITS(mp), ALLOC(mp));
+        s_mp_free(DIGITS(mp));
+        DIGITS(mp) = tmp;
+        ALLOC(mp) = min;
+    }
 
-  return MP_OKAY;
+    return MP_OKAY;
 
 } /* end s_mp_grow() */
 
@@ -2752,24 +2816,25 @@ mp_err   s_mp_grow(mp_int *mp, mp_size min)
 /* {{{ s_mp_pad(mp, min) */
 
 /* Make sure the used size of mp is at least 'min', growing if needed     */
-mp_err   s_mp_pad(mp_int *mp, mp_size min)
+mp_err
+s_mp_pad(mp_int *mp, mp_size min)
 {
-  if(min > USED(mp)) {
-    mp_err  res;
-
-    /* Make sure there is room to increase precision  */
-    if (min > ALLOC(mp)) {
-      if ((res = s_mp_grow(mp, min)) != MP_OKAY)
-	return res;
-    } else {
-      s_mp_setz(DIGITS(mp) + USED(mp), min - USED(mp));
+    if (min > USED(mp)) {
+        mp_err res;
+
+        /* Make sure there is room to increase precision  */
+        if (min > ALLOC(mp)) {
+            if ((res = s_mp_grow(mp, min)) != MP_OKAY)
+                return res;
+        } else {
+            s_mp_setz(DIGITS(mp) + USED(mp), min - USED(mp));
+        }
+
+        /* Increase precision; should already be 0-filled */
+        USED(mp) = min;
     }
 
-    /* Increase precision; should already be 0-filled */
-    USED(mp) = min;
-  }
-
-  return MP_OKAY;
+    return MP_OKAY;
 
 } /* end s_mp_pad() */
 
@@ -2778,15 +2843,16 @@ mp_err   s_mp_pad(mp_int *mp, mp_size min)
 /* {{{ s_mp_setz(dp, count) */
 
 /* Set 'count' digits pointed to by dp to be zeroes                       */
-inline void s_mp_setz(mp_digit *dp, mp_size count)
+inline void
+s_mp_setz(mp_digit *dp, mp_size count)
 {
 #if MP_MEMSET == 0
-  int  ix;
+    int ix;
 
-  for(ix = 0; ix < count; ix++)
-    dp[ix] = 0;
+    for (ix = 0; ix < count; ix++)
+        dp[ix] = 0;
 #else
-  memset(dp, 0, count * sizeof(mp_digit));
+    memset(dp, 0, count * sizeof(mp_digit));
 #endif
 
 } /* end s_mp_setz() */
@@ -2796,15 +2862,16 @@ inline void s_mp_setz(mp_digit *dp, mp_size count)
 /* {{{ s_mp_copy(sp, dp, count) */
 
 /* Copy 'count' digits from sp to dp                                      */
-inline void s_mp_copy(const mp_digit *sp, mp_digit *dp, mp_size count)
+inline void
+s_mp_copy(const mp_digit *sp, mp_digit *dp, mp_size count)
 {
 #if MP_MEMCPY == 0
-  int  ix;
+    int ix;
 
-  for(ix = 0; ix < count; ix++)
-    dp[ix] = sp[ix];
+    for (ix = 0; ix < count; ix++)
+        dp[ix] = sp[ix];
 #else
-  memcpy(dp, sp, count * sizeof(mp_digit));
+    memcpy(dp, sp, count * sizeof(mp_digit));
 #endif
 } /* end s_mp_copy() */
 
@@ -2813,9 +2880,10 @@ inline void s_mp_copy(const mp_digit *sp, mp_digit *dp, mp_size count)
 /* {{{ s_mp_alloc(nb, ni) */
 
 /* Allocate ni records of nb bytes each, and return a pointer to that     */
-inline void *s_mp_alloc(size_t nb, size_t ni)
+inline void *
+s_mp_alloc(size_t nb, size_t ni)
 {
-  return calloc(nb, ni);
+    return calloc(nb, ni);
 
 } /* end s_mp_alloc() */
 
@@ -2824,11 +2892,12 @@ inline void *s_mp_alloc(size_t nb, size_t ni)
 /* {{{ s_mp_free(ptr) */
 
 /* Free the memory pointed to by ptr                                      */
-inline void s_mp_free(void *ptr)
+inline void
+s_mp_free(void *ptr)
 {
-  if(ptr) {
-    free(ptr);
-  }
+    if (ptr) {
+        free(ptr);
+    }
 } /* end s_mp_free() */
 
 /* }}} */
@@ -2836,12 +2905,13 @@ inline void s_mp_free(void *ptr)
 /* {{{ s_mp_clamp(mp) */
 
 /* Remove leading zeroes from the given value                             */
-inline void s_mp_clamp(mp_int *mp)
+inline void
+s_mp_clamp(mp_int *mp)
 {
-  mp_size used = MP_USED(mp);
-  while (used > 1 && DIGIT(mp, used - 1) == 0)
-    --used;
-  MP_USED(mp) = used;
+    mp_size used = MP_USED(mp);
+    while (used > 1 && DIGIT(mp, used - 1) == 0)
+        --used;
+    MP_USED(mp) = used;
 } /* end s_mp_clamp() */
 
 /* }}} */
@@ -2849,13 +2919,14 @@ inline void s_mp_clamp(mp_int *mp)
 /* {{{ s_mp_exch(a, b) */
 
 /* Exchange the data for a and b; (b, a) = (a, b)                         */
-void     s_mp_exch(mp_int *a, mp_int *b)
+void
+s_mp_exch(mp_int *a, mp_int *b)
 {
-  mp_int   tmp;
+    mp_int tmp;
 
-  tmp = *a;
-  *a = *b;
-  *b = tmp;
+    tmp = *a;
+    *a = *b;
+    *b = tmp;
 
 } /* end s_mp_exch() */
 
@@ -2867,36 +2938,37 @@ void     s_mp_exch(mp_int *a, mp_int *b)
 
 /* {{{ s_mp_lshd(mp, p) */
 
-/* 
+/*
    Shift mp leftward by p digits, growing if needed, and zero-filling
    the in-shifted digits at the right end.  This is a convenient
    alternative to multiplication by powers of the radix
- */   
+ */
 
-mp_err   s_mp_lshd(mp_int *mp, mp_size p)
+mp_err
+s_mp_lshd(mp_int *mp, mp_size p)
 {
-  mp_err  res;
-  unsigned int     ix;
+    mp_err res;
+    unsigned int ix;
 
-  if(p == 0)
-    return MP_OKAY;
+    if (p == 0)
+        return MP_OKAY;
 
-  if (MP_USED(mp) == 1 && MP_DIGIT(mp, 0) == 0)
-    return MP_OKAY;
+    if (MP_USED(mp) == 1 && MP_DIGIT(mp, 0) == 0)
+        return MP_OKAY;
 
-  if((res = s_mp_pad(mp, USED(mp) + p)) != MP_OKAY)
-    return res;
+    if ((res = s_mp_pad(mp, USED(mp) + p)) != MP_OKAY)
+        return res;
 
-  /* Shift all the significant figures over as needed */
-  for (ix = USED(mp) - p; ix-- > 0;) {
-    DIGIT(mp, ix + p) = DIGIT(mp, ix);
-  }
+    /* Shift all the significant figures over as needed */
+    for (ix = USED(mp) - p; ix-- > 0;) {
+        DIGIT(mp, ix + p) = DIGIT(mp, ix);
+    }
 
-  /* Fill the bottom digits with zeroes */
-  for(ix = 0; (mp_size)ix < p; ix++)
-    DIGIT(mp, ix) = 0;
+    /* Fill the bottom digits with zeroes */
+    for (ix = 0; (mp_size)ix < p; ix++)
+        DIGIT(mp, ix) = 0;
 
-  return MP_OKAY;
+    return MP_OKAY;
 
 } /* end s_mp_lshd() */
 
@@ -2908,80 +2980,82 @@ mp_err   s_mp_lshd(mp_int *mp, mp_size p)
   Multiply the integer by 2^d, where d is a number of bits.  This
   amounts to a bitwise shift of the value.
  */
-mp_err   s_mp_mul_2d(mp_int *mp, mp_digit d)
+mp_err
+s_mp_mul_2d(mp_int *mp, mp_digit d)
 {
-  mp_err   res;
-  mp_digit dshift, bshift;
-  mp_digit mask;
-
-  ARGCHK(mp != NULL,  MP_BADARG);
-
-  dshift = d / MP_DIGIT_BIT;
-  bshift = d % MP_DIGIT_BIT;
-  /* bits to be shifted out of the top word */
-  if (bshift) {
-    mask = (mp_digit)~0 << (MP_DIGIT_BIT - bshift);
-    mask &= MP_DIGIT(mp, MP_USED(mp) - 1);
-  } else {
-    mask = 0;
-  }
-
-  if (MP_OKAY != (res = s_mp_pad(mp, MP_USED(mp) + dshift + (mask != 0) )))
-    return res;
+    mp_err res;
+    mp_digit dshift, bshift;
+    mp_digit mask;
+
+    ARGCHK(mp != NULL, MP_BADARG);
+
+    dshift = d / MP_DIGIT_BIT;
+    bshift = d % MP_DIGIT_BIT;
+    /* bits to be shifted out of the top word */
+    if (bshift) {
+        mask = (mp_digit)~0 << (MP_DIGIT_BIT - bshift);
+        mask &= MP_DIGIT(mp, MP_USED(mp) - 1);
+    } else {
+        mask = 0;
+    }
 
-  if (dshift && MP_OKAY != (res = s_mp_lshd(mp, dshift)))
-    return res;
+    if (MP_OKAY != (res = s_mp_pad(mp, MP_USED(mp) + dshift + (mask != 0))))
+        return res;
 
-  if (bshift) { 
-    mp_digit *pa = MP_DIGITS(mp);
-    mp_digit *alim = pa + MP_USED(mp);
-    mp_digit  prev = 0;
+    if (dshift && MP_OKAY != (res = s_mp_lshd(mp, dshift)))
+        return res;
+
+    if (bshift) {
+        mp_digit *pa = MP_DIGITS(mp);
+        mp_digit *alim = pa + MP_USED(mp);
+        mp_digit prev = 0;
 
-    for (pa += dshift; pa < alim; ) {
-      mp_digit x = *pa;
-      *pa++ = (x << bshift) | prev;
-      prev = x >> (DIGIT_BIT - bshift);
+        for (pa += dshift; pa < alim;) {
+            mp_digit x = *pa;
+            *pa++ = (x << bshift) | prev;
+            prev = x >> (DIGIT_BIT - bshift);
+        }
     }
-  }
 
-  s_mp_clamp(mp);
-  return MP_OKAY;
+    s_mp_clamp(mp);
+    return MP_OKAY;
 } /* end s_mp_mul_2d() */
 
 /* {{{ s_mp_rshd(mp, p) */
 
-/* 
+/*
    Shift mp rightward by p digits.  Maintains the invariant that
    digits above the precision are all zero.  Digits shifted off the
    end are lost.  Cannot fail.
  */
 
-void     s_mp_rshd(mp_int *mp, mp_size p)
+void
+s_mp_rshd(mp_int *mp, mp_size p)
 {
-  mp_size  ix;
-  mp_digit *src, *dst;
-
-  if(p == 0)
-    return;
-
-  /* Shortcut when all digits are to be shifted off */
-  if(p >= USED(mp)) {
-    s_mp_setz(DIGITS(mp), ALLOC(mp));
-    USED(mp) = 1;
-    SIGN(mp) = ZPOS;
-    return;
-  }
+    mp_size ix;
+    mp_digit *src, *dst;
+
+    if (p == 0)
+        return;
+
+    /* Shortcut when all digits are to be shifted off */
+    if (p >= USED(mp)) {
+        s_mp_setz(DIGITS(mp), ALLOC(mp));
+        USED(mp) = 1;
+        SIGN(mp) = ZPOS;
+        return;
+    }
 
-  /* Shift all the significant figures over as needed */
-  dst = MP_DIGITS(mp);
-  src = dst + p;
-  for (ix = USED(mp) - p; ix > 0; ix--)
-    *dst++ = *src++;
+    /* Shift all the significant figures over as needed */
+    dst = MP_DIGITS(mp);
+    src = dst + p;
+    for (ix = USED(mp) - p; ix > 0; ix--)
+        *dst++ = *src++;
 
-  MP_USED(mp) -= p;
-  /* Fill the top digits with zeroes */
-  while (p-- > 0)
-    *dst++ = 0;
+    MP_USED(mp) -= p;
+    /* Fill the top digits with zeroes */
+    while (p-- > 0)
+        *dst++ = 0;
 
 } /* end s_mp_rshd() */
 
@@ -2990,9 +3064,10 @@ void     s_mp_rshd(mp_int *mp, mp_size p)
 /* {{{ s_mp_div_2(mp) */
 
 /* Divide by two -- take advantage of radix properties to do it fast      */
-void     s_mp_div_2(mp_int *mp)
+void
+s_mp_div_2(mp_int *mp)
 {
-  s_mp_div_2d(mp, 1);
+    s_mp_div_2d(mp, 1);
 
 } /* end s_mp_div_2() */
 
@@ -3000,34 +3075,35 @@ void     s_mp_div_2(mp_int *mp)
 
 /* {{{ s_mp_mul_2(mp) */
 
-mp_err s_mp_mul_2(mp_int *mp)
+mp_err
+s_mp_mul_2(mp_int *mp)
 {
-  mp_digit *pd;
-  unsigned int ix, used;
-  mp_digit kin = 0;
-
-  /* Shift digits leftward by 1 bit */
-  used = MP_USED(mp);
-  pd = MP_DIGITS(mp);
-  for (ix = 0; ix < used; ix++) {
-    mp_digit d = *pd;
-    *pd++ = (d << 1) | kin;
-    kin = (d >> (DIGIT_BIT - 1));
-  }
+    mp_digit *pd;
+    unsigned int ix, used;
+    mp_digit kin = 0;
 
-  /* Deal with rollover from last digit */
-  if (kin) {
-    if (ix >= ALLOC(mp)) {
-      mp_err res;
-      if((res = s_mp_grow(mp, ALLOC(mp) + 1)) != MP_OKAY)
-	return res;
+    /* Shift digits leftward by 1 bit */
+    used = MP_USED(mp);
+    pd = MP_DIGITS(mp);
+    for (ix = 0; ix < used; ix++) {
+        mp_digit d = *pd;
+        *pd++ = (d << 1) | kin;
+        kin = (d >> (DIGIT_BIT - 1));
     }
 
-    DIGIT(mp, ix) = kin;
-    USED(mp) += 1;
-  }
+    /* Deal with rollover from last digit */
+    if (kin) {
+        if (ix >= ALLOC(mp)) {
+            mp_err res;
+            if ((res = s_mp_grow(mp, ALLOC(mp) + 1)) != MP_OKAY)
+                return res;
+        }
+
+        DIGIT(mp, ix) = kin;
+        USED(mp) += 1;
+    }
 
-  return MP_OKAY;
+    return MP_OKAY;
 
 } /* end s_mp_mul_2() */
 
@@ -3040,24 +3116,25 @@ mp_err s_mp_mul_2(mp_int *mp)
   amounts to a bitwise AND of the value, and does not require the full
   division code
  */
-void     s_mp_mod_2d(mp_int *mp, mp_digit d)
+void
+s_mp_mod_2d(mp_int *mp, mp_digit d)
 {
-  mp_size  ndig = (d / DIGIT_BIT), nbit = (d % DIGIT_BIT);
-  mp_size  ix;
-  mp_digit dmask;
+    mp_size ndig = (d / DIGIT_BIT), nbit = (d % DIGIT_BIT);
+    mp_size ix;
+    mp_digit dmask;
 
-  if(ndig >= USED(mp))
-    return;
+    if (ndig >= USED(mp))
+        return;
 
-  /* Flush all the bits above 2^d in its digit */
-  dmask = ((mp_digit)1 << nbit) - 1;
-  DIGIT(mp, ndig) &= dmask;
+    /* Flush all the bits above 2^d in its digit */
+    dmask = ((mp_digit)1 << nbit) - 1;
+    DIGIT(mp, ndig) &= dmask;
 
-  /* Flush all digits above the one with 2^d in it */
-  for(ix = ndig + 1; ix < USED(mp); ix++)
-    DIGIT(mp, ix) = 0;
+    /* Flush all digits above the one with 2^d in it */
+    for (ix = ndig + 1; ix < USED(mp); ix++)
+        DIGIT(mp, ix) = 0;
 
-  s_mp_clamp(mp);
+    s_mp_clamp(mp);
 
 } /* end s_mp_mod_2d() */
 
@@ -3070,23 +3147,24 @@ void     s_mp_mod_2d(mp_int *mp, mp_digit d)
   amounts to a bitwise shift of the value, and does not require the
   full division code (used in Barrett reduction, see below)
  */
-void     s_mp_div_2d(mp_int *mp, mp_digit d)
+void
+s_mp_div_2d(mp_int *mp, mp_digit d)
 {
-  int       ix;
-  mp_digit  save, next, mask;
-
-  s_mp_rshd(mp, d / DIGIT_BIT);
-  d %= DIGIT_BIT;
-  if (d) {
-    mask = ((mp_digit)1 << d) - 1;
-    save = 0;
-    for(ix = USED(mp) - 1; ix >= 0; ix--) {
-      next = DIGIT(mp, ix) & mask;
-      DIGIT(mp, ix) = (DIGIT(mp, ix) >> d) | (save << (DIGIT_BIT - d));
-      save = next;
-    }
-  }
-  s_mp_clamp(mp);
+    int ix;
+    mp_digit save, next, mask;
+
+    s_mp_rshd(mp, d / DIGIT_BIT);
+    d %= DIGIT_BIT;
+    if (d) {
+        mask = ((mp_digit)1 << d) - 1;
+        save = 0;
+        for (ix = USED(mp) - 1; ix >= 0; ix--) {
+            next = DIGIT(mp, ix) & mask;
+            DIGIT(mp, ix) = (DIGIT(mp, ix) >> d) | (save << (DIGIT_BIT - d));
+            save = next;
+        }
+    }
+    s_mp_clamp(mp);
 
 } /* end s_mp_div_2d() */
 
@@ -3100,34 +3178,35 @@ void     s_mp_div_2d(mp_int *mp, mp_digit d)
   Normalize a and b for division, where b is the divisor.  In order
   that we might make good guesses for quotient digits, we want the
   leading digit of b to be at least half the radix, which we
-  accomplish by multiplying a and b by a power of 2.  The exponent 
-  (shift count) is placed in *pd, so that the remainder can be shifted 
+  accomplish by multiplying a and b by a power of 2.  The exponent
+  (shift count) is placed in *pd, so that the remainder can be shifted
   back at the end of the division process.
  */
 
-mp_err   s_mp_norm(mp_int *a, mp_int *b, mp_digit *pd)
+mp_err
+s_mp_norm(mp_int *a, mp_int *b, mp_digit *pd)
 {
-  mp_digit  d;
-  mp_digit  mask;
-  mp_digit  b_msd;
-  mp_err    res    = MP_OKAY;
-
-  d = 0;
-  mask  = DIGIT_MAX & ~(DIGIT_MAX >> 1);	/* mask is msb of digit */
-  b_msd = DIGIT(b, USED(b) - 1);
-  while (!(b_msd & mask)) {
-    b_msd <<= 1;
-    ++d;
-  }
-
-  if (d) {
-    MP_CHECKOK( s_mp_mul_2d(a, d) );
-    MP_CHECKOK( s_mp_mul_2d(b, d) );
-  }
-
-  *pd = d;
+    mp_digit d;
+    mp_digit mask;
+    mp_digit b_msd;
+    mp_err res = MP_OKAY;
+
+    d = 0;
+    mask = DIGIT_MAX & ~(DIGIT_MAX >> 1); /* mask is msb of digit */
+    b_msd = DIGIT(b, USED(b) - 1);
+    while (!(b_msd & mask)) {
+        b_msd <<= 1;
+        ++d;
+    }
+
+    if (d) {
+        MP_CHECKOK(s_mp_mul_2d(a, d));
+        MP_CHECKOK(s_mp_mul_2d(b, d));
+    }
+
+    *pd = d;
 CLEANUP:
-  return res;
+    return res;
 
 } /* end s_mp_norm() */
 
@@ -3140,55 +3219,55 @@ CLEANUP:
 /* {{{ s_mp_add_d(mp, d) */
 
 /* Add d to |mp| in place                                                 */
-mp_err   s_mp_add_d(mp_int *mp, mp_digit d)    /* unsigned digit addition */
+mp_err s_mp_add_d(mp_int *mp, mp_digit d) /* unsigned digit addition */
 {
 #if !defined(MP_NO_MP_WORD) && !defined(MP_NO_ADD_WORD)
-  mp_word   w, k = 0;
-  mp_size   ix = 1;
-
-  w = (mp_word)DIGIT(mp, 0) + d;
-  DIGIT(mp, 0) = ACCUM(w);
-  k = CARRYOUT(w);
+    mp_word w, k = 0;
+    mp_size ix = 1;
 
-  while(ix < USED(mp) && k) {
-    w = (mp_word)DIGIT(mp, ix) + k;
-    DIGIT(mp, ix) = ACCUM(w);
+    w = (mp_word)DIGIT(mp, 0) + d;
+    DIGIT(mp, 0) = ACCUM(w);
     k = CARRYOUT(w);
-    ++ix;
-  }
 
-  if(k != 0) {
-    mp_err  res;
+    while (ix < USED(mp) && k) {
+        w = (mp_word)DIGIT(mp, ix) + k;
+        DIGIT(mp, ix) = ACCUM(w);
+        k = CARRYOUT(w);
+        ++ix;
+    }
 
-    if((res = s_mp_pad(mp, USED(mp) + 1)) != MP_OKAY)
-      return res;
+    if (k != 0) {
+        mp_err res;
 
-    DIGIT(mp, ix) = (mp_digit)k;
-  }
+        if ((res = s_mp_pad(mp, USED(mp) + 1)) != MP_OKAY)
+            return res;
 
-  return MP_OKAY;
+        DIGIT(mp, ix) = (mp_digit)k;
+    }
+
+    return MP_OKAY;
 #else
-  mp_digit * pmp = MP_DIGITS(mp);
-  mp_digit sum, mp_i, carry = 0;
-  mp_err   res = MP_OKAY;
-  int used = (int)MP_USED(mp);
-
-  mp_i = *pmp;
-  *pmp++ = sum = d + mp_i;
-  carry = (sum < d);
-  while (carry && --used > 0) {
+    mp_digit *pmp = MP_DIGITS(mp);
+    mp_digit sum, mp_i, carry = 0;
+    mp_err res = MP_OKAY;
+    int used = (int)MP_USED(mp);
+
     mp_i = *pmp;
-    *pmp++ = sum = carry + mp_i;
-    carry = !sum;
-  }
-  if (carry && !used) {
-    /* mp is growing */
-    used = MP_USED(mp);
-    MP_CHECKOK( s_mp_pad(mp, used + 1) );
-    MP_DIGIT(mp, used) = carry;
-  }
+    *pmp++ = sum = d + mp_i;
+    carry = (sum < d);
+    while (carry && --used > 0) {
+        mp_i = *pmp;
+        *pmp++ = sum = carry + mp_i;
+        carry = !sum;
+    }
+    if (carry && !used) {
+        /* mp is growing */
+        used = MP_USED(mp);
+        MP_CHECKOK(s_mp_pad(mp, used + 1));
+        MP_DIGIT(mp, used) = carry;
+    }
 CLEANUP:
-  return res;
+    return res;
 #endif
 } /* end s_mp_add_d() */
 
@@ -3197,48 +3276,48 @@ CLEANUP:
 /* {{{ s_mp_sub_d(mp, d) */
 
 /* Subtract d from |mp| in place, assumes |mp| > d                        */
-mp_err   s_mp_sub_d(mp_int *mp, mp_digit d)    /* unsigned digit subtract */
+mp_err s_mp_sub_d(mp_int *mp, mp_digit d) /* unsigned digit subtract */
 {
 #if !defined(MP_NO_MP_WORD) && !defined(MP_NO_SUB_WORD)
-  mp_word   w, b = 0;
-  mp_size   ix = 1;
-
-  /* Compute initial subtraction    */
-  w = (RADIX + (mp_word)DIGIT(mp, 0)) - d;
-  b = CARRYOUT(w) ? 0 : 1;
-  DIGIT(mp, 0) = ACCUM(w);
+    mp_word w, b = 0;
+    mp_size ix = 1;
 
-  /* Propagate borrows leftward     */
-  while(b && ix < USED(mp)) {
-    w = (RADIX + (mp_word)DIGIT(mp, ix)) - b;
+    /* Compute initial subtraction    */
+    w = (RADIX + (mp_word)DIGIT(mp, 0)) - d;
     b = CARRYOUT(w) ? 0 : 1;
-    DIGIT(mp, ix) = ACCUM(w);
-    ++ix;
-  }
+    DIGIT(mp, 0) = ACCUM(w);
+
+    /* Propagate borrows leftward     */
+    while (b && ix < USED(mp)) {
+        w = (RADIX + (mp_word)DIGIT(mp, ix)) - b;
+        b = CARRYOUT(w) ? 0 : 1;
+        DIGIT(mp, ix) = ACCUM(w);
+        ++ix;
+    }
 
-  /* Remove leading zeroes          */
-  s_mp_clamp(mp);
+    /* Remove leading zeroes          */
+    s_mp_clamp(mp);
 
-  /* If we have a borrow out, it's a violation of the input invariant */
-  if(b)
-    return MP_RANGE;
-  else
-    return MP_OKAY;
+    /* If we have a borrow out, it's a violation of the input invariant */
+    if (b)
+        return MP_RANGE;
+    else
+        return MP_OKAY;
 #else
-  mp_digit *pmp = MP_DIGITS(mp);
-  mp_digit mp_i, diff, borrow;
-  mp_size  used = MP_USED(mp);
-
-  mp_i = *pmp;
-  *pmp++ = diff = mp_i - d;
-  borrow = (diff > mp_i);
-  while (borrow && --used) {
+    mp_digit *pmp = MP_DIGITS(mp);
+    mp_digit mp_i, diff, borrow;
+    mp_size used = MP_USED(mp);
+
     mp_i = *pmp;
-    *pmp++ = diff = mp_i - borrow;
+    *pmp++ = diff = mp_i - d;
     borrow = (diff > mp_i);
-  }
-  s_mp_clamp(mp);
-  return (borrow && !used) ? MP_RANGE : MP_OKAY;
+    while (borrow && --used) {
+        mp_i = *pmp;
+        *pmp++ = diff = mp_i - borrow;
+        borrow = (diff > mp_i);
+    }
+    s_mp_clamp(mp);
+    return (borrow && !used) ? MP_RANGE : MP_OKAY;
 #endif
 } /* end s_mp_sub_d() */
 
@@ -3247,32 +3326,33 @@ mp_err   s_mp_sub_d(mp_int *mp, mp_digit d)    /* unsigned digit subtract */
 /* {{{ s_mp_mul_d(a, d) */
 
 /* Compute a = a * d, single digit multiplication                         */
-mp_err   s_mp_mul_d(mp_int *a, mp_digit d)
+mp_err
+s_mp_mul_d(mp_int *a, mp_digit d)
 {
-  mp_err  res;
-  mp_size used;
-  int     pow;
+    mp_err res;
+    mp_size used;
+    int pow;
 
-  if (!d) {
-    mp_zero(a);
-    return MP_OKAY;
-  }
-  if (d == 1)
-    return MP_OKAY;
-  if (0 <= (pow = s_mp_ispow2d(d))) {
-    return s_mp_mul_2d(a, (mp_digit)pow);
-  }
+    if (!d) {
+        mp_zero(a);
+        return MP_OKAY;
+    }
+    if (d == 1)
+        return MP_OKAY;
+    if (0 <= (pow = s_mp_ispow2d(d))) {
+        return s_mp_mul_2d(a, (mp_digit)pow);
+    }
 
-  used = MP_USED(a);
-  MP_CHECKOK( s_mp_pad(a, used + 1) );
+    used = MP_USED(a);
+    MP_CHECKOK(s_mp_pad(a, used + 1));
 
-  s_mpv_mul_d(MP_DIGITS(a), used, d, MP_DIGITS(a));
+    s_mpv_mul_d(MP_DIGITS(a), used, d, MP_DIGITS(a));
 
-  s_mp_clamp(a);
+    s_mp_clamp(a);
 
 CLEANUP:
-  return res;
-  
+    return res;
+
 } /* end s_mp_mul_d() */
 
 /* }}} */
@@ -3286,115 +3366,115 @@ CLEANUP:
   single digit d.  If r is null, the remainder will be discarded.
  */
 
-mp_err   s_mp_div_d(mp_int *mp, mp_digit d, mp_digit *r)
+mp_err
+s_mp_div_d(mp_int *mp, mp_digit d, mp_digit *r)
 {
 #if !defined(MP_NO_MP_WORD) && !defined(MP_NO_DIV_WORD)
-  mp_word   w = 0, q;
+    mp_word w = 0, q;
 #else
-  mp_digit  w = 0, q;
+    mp_digit w = 0, q;
 #endif
-  int       ix;
-  mp_err    res;
-  mp_int    quot;
-  mp_int    rem;
-
-  if(d == 0)
-    return MP_RANGE;
-  if (d == 1) {
-    if (r)
-      *r = 0;
-    return MP_OKAY;
-  }
-  /* could check for power of 2 here, but mp_div_d does that. */
-  if (MP_USED(mp) == 1) {
-    mp_digit n   = MP_DIGIT(mp,0);
-    mp_digit rem;
-
-    q   = n / d;
-    rem = n % d;
-    MP_DIGIT(mp,0) = q;
-    if (r)
-      *r = rem;
-    return MP_OKAY;
-  }
+    int ix;
+    mp_err res;
+    mp_int quot;
+    mp_int rem;
+
+    if (d == 0)
+        return MP_RANGE;
+    if (d == 1) {
+        if (r)
+            *r = 0;
+        return MP_OKAY;
+    }
+    /* could check for power of 2 here, but mp_div_d does that. */
+    if (MP_USED(mp) == 1) {
+        mp_digit n = MP_DIGIT(mp, 0);
+        mp_digit rem;
+
+        q = n / d;
+        rem = n % d;
+        MP_DIGIT(mp, 0) = q;
+        if (r)
+            *r = rem;
+        return MP_OKAY;
+    }
 
-  MP_DIGITS(&rem)  = 0;
-  MP_DIGITS(&quot) = 0;
-  /* Make room for the quotient */
-  MP_CHECKOK( mp_init_size(&quot, USED(mp)) );
+    MP_DIGITS(&rem) = 0;
+    MP_DIGITS(&quot) = 0;
+    /* Make room for the quotient */
+    MP_CHECKOK(mp_init_size(&quot, USED(mp)));
 
 #if !defined(MP_NO_MP_WORD) && !defined(MP_NO_DIV_WORD)
-  for(ix = USED(mp) - 1; ix >= 0; ix--) {
-    w = (w << DIGIT_BIT) | DIGIT(mp, ix);
-
-    if(w >= d) {
-      q = w / d;
-      w = w % d;
-    } else {
-      q = 0;
+    for (ix = USED(mp) - 1; ix >= 0; ix--) {
+        w = (w << DIGIT_BIT) | DIGIT(mp, ix);
+
+        if (w >= d) {
+            q = w / d;
+            w = w % d;
+        } else {
+            q = 0;
+        }
+
+        s_mp_lshd(&quot, 1);
+        DIGIT(&quot, 0) = (mp_digit)q;
     }
-
-    s_mp_lshd(&quot, 1);
-    DIGIT(&quot, 0) = (mp_digit)q;
-  }
 #else
-  {
-    mp_digit p;
+    {
+        mp_digit p;
 #if !defined(MP_ASSEMBLY_DIV_2DX1D)
-    mp_digit norm;
+        mp_digit norm;
 #endif
 
-    MP_CHECKOK( mp_init_copy(&rem, mp) );
+        MP_CHECKOK(mp_init_copy(&rem, mp));
 
 #if !defined(MP_ASSEMBLY_DIV_2DX1D)
-    MP_DIGIT(&quot, 0) = d;
-    MP_CHECKOK( s_mp_norm(&rem, &quot, &norm) );
-    if (norm)
-      d <<= norm;
-    MP_DIGIT(&quot, 0) = 0;
+        MP_DIGIT(&quot, 0) = d;
+        MP_CHECKOK(s_mp_norm(&rem, &quot, &norm));
+        if (norm)
+            d <<= norm;
+        MP_DIGIT(&quot, 0) = 0;
 #endif
 
-    p = 0;
-    for (ix = USED(&rem) - 1; ix >= 0; ix--) {
-      w = DIGIT(&rem, ix);
-
-      if (p) {
-        MP_CHECKOK( s_mpv_div_2dx1d(p, w, d, &q, &w) );
-      } else if (w >= d) {
-	q = w / d;
-	w = w % d;
-      } else {
-	q = 0;
-      }
-
-      MP_CHECKOK( s_mp_lshd(&quot, 1) );
-      DIGIT(&quot, 0) = q;
-      p = w;
-    }
+        p = 0;
+        for (ix = USED(&rem) - 1; ix >= 0; ix--) {
+            w = DIGIT(&rem, ix);
+
+            if (p) {
+                MP_CHECKOK(s_mpv_div_2dx1d(p, w, d, &q, &w));
+            } else if (w >= d) {
+                q = w / d;
+                w = w % d;
+            } else {
+                q = 0;
+            }
+
+            MP_CHECKOK(s_mp_lshd(&quot, 1));
+            DIGIT(&quot, 0) = q;
+            p = w;
+        }
 #if !defined(MP_ASSEMBLY_DIV_2DX1D)
-    if (norm)
-      w >>= norm;
+        if (norm)
+            w >>= norm;
 #endif
-  }
+    }
 #endif
 
-  /* Deliver the remainder, if desired */
-  if(r) {
-    *r = (mp_digit)w;
-  }
+    /* Deliver the remainder, if desired */
+    if (r) {
+        *r = (mp_digit)w;
+    }
 
-  s_mp_clamp(&quot);
-  mp_exch(&quot, mp);
+    s_mp_clamp(&quot);
+    mp_exch(&quot, mp);
 CLEANUP:
-  mp_clear(&quot);
-  mp_clear(&rem);
+    mp_clear(&quot);
+    mp_clear(&rem);
 
-  return res;
+    return res;
 } /* end s_mp_div_d() */
 
 /* }}} */
 
-
 /* }}} */
 
 /* {{{ Primitive full arithmetic */
@@ -3402,259 +3482,261 @@ CLEANUP:
 /* {{{ s_mp_add(a, b) */
 
 /* Compute a = |a| + |b|                                                  */
-mp_err   s_mp_add(mp_int *a, const mp_int *b)  /* magnitude addition      */
+mp_err s_mp_add(mp_int *a, const mp_int *b) /* magnitude addition      */
 {
 #if !defined(MP_NO_MP_WORD) && !defined(MP_NO_ADD_WORD)
-  mp_word   w = 0;
+    mp_word w = 0;
 #else
-  mp_digit  d, sum, carry = 0;
+    mp_digit d, sum, carry = 0;
 #endif
-  mp_digit *pa, *pb;
-  mp_size   ix;
-  mp_size   used;
-  mp_err    res;
+    mp_digit *pa, *pb;
+    mp_size ix;
+    mp_size used;
+    mp_err res;
 
-  /* Make sure a has enough precision for the output value */
-  if((USED(b) > USED(a)) && (res = s_mp_pad(a, USED(b))) != MP_OKAY)
-    return res;
+    /* Make sure a has enough precision for the output value */
+    if ((USED(b) > USED(a)) && (res = s_mp_pad(a, USED(b))) != MP_OKAY)
+        return res;
 
-  /*
-    Add up all digits up to the precision of b.  If b had initially
-    the same precision as a, or greater, we took care of it by the
-    padding step above, so there is no problem.  If b had initially
-    less precision, we'll have to make sure the carry out is duly
-    propagated upward among the higher-order digits of the sum.
-   */
-  pa = MP_DIGITS(a);
-  pb = MP_DIGITS(b);
-  used = MP_USED(b);
-  for(ix = 0; ix < used; ix++) {
+    /*
+      Add up all digits up to the precision of b.  If b had initially
+      the same precision as a, or greater, we took care of it by the
+      padding step above, so there is no problem.  If b had initially
+      less precision, we'll have to make sure the carry out is duly
+      propagated upward among the higher-order digits of the sum.
+     */
+    pa = MP_DIGITS(a);
+    pb = MP_DIGITS(b);
+    used = MP_USED(b);
+    for (ix = 0; ix < used; ix++) {
 #if !defined(MP_NO_MP_WORD) && !defined(MP_NO_ADD_WORD)
-    w = w + *pa + *pb++;
-    *pa++ = ACCUM(w);
-    w = CARRYOUT(w);
+        w = w + *pa + *pb++;
+        *pa++ = ACCUM(w);
+        w = CARRYOUT(w);
 #else
-    d = *pa;
-    sum = d + *pb++;
-    d = (sum < d);			/* detect overflow */
-    *pa++ = sum += carry;
-    carry = d + (sum < carry);		/* detect overflow */
+        d = *pa;
+        sum = d + *pb++;
+        d = (sum < d); /* detect overflow */
+        *pa++ = sum += carry;
+        carry = d + (sum < carry); /* detect overflow */
 #endif
-  }
+    }
 
-  /* If we run out of 'b' digits before we're actually done, make
-     sure the carries get propagated upward...  
-   */
-  used = MP_USED(a);
+    /* If we run out of 'b' digits before we're actually done, make
+       sure the carries get propagated upward...
+     */
+    used = MP_USED(a);
 #if !defined(MP_NO_MP_WORD) && !defined(MP_NO_ADD_WORD)
-  while (w && ix < used) {
-    w = w + *pa;
-    *pa++ = ACCUM(w);
-    w = CARRYOUT(w);
-    ++ix;
-  }
+    while (w && ix < used) {
+        w = w + *pa;
+        *pa++ = ACCUM(w);
+        w = CARRYOUT(w);
+        ++ix;
+    }
 #else
-  while (carry && ix < used) {
-    sum = carry + *pa;
-    *pa++ = sum;
-    carry = !sum;
-    ++ix;
-  }
+    while (carry && ix < used) {
+        sum = carry + *pa;
+        *pa++ = sum;
+        carry = !sum;
+        ++ix;
+    }
 #endif
 
-  /* If there's an overall carry out, increase precision and include
+/* If there's an overall carry out, increase precision and include
      it.  We could have done this initially, but why touch the memory
      allocator unless we're sure we have to?
    */
 #if !defined(MP_NO_MP_WORD) && !defined(MP_NO_ADD_WORD)
-  if (w) {
-    if((res = s_mp_pad(a, used + 1)) != MP_OKAY)
-      return res;
+    if (w) {
+        if ((res = s_mp_pad(a, used + 1)) != MP_OKAY)
+            return res;
 
-    DIGIT(a, ix) = (mp_digit)w;
-  }
+        DIGIT(a, ix) = (mp_digit)w;
+    }
 #else
-  if (carry) {
-    if((res = s_mp_pad(a, used + 1)) != MP_OKAY)
-      return res;
+    if (carry) {
+        if ((res = s_mp_pad(a, used + 1)) != MP_OKAY)
+            return res;
 
-    DIGIT(a, used) = carry;
-  }
+        DIGIT(a, used) = carry;
+    }
 #endif
 
-  return MP_OKAY;
+    return MP_OKAY;
 } /* end s_mp_add() */
 
 /* }}} */
 
 /* Compute c = |a| + |b|         */ /* magnitude addition      */
-mp_err   s_mp_add_3arg(const mp_int *a, const mp_int *b, mp_int *c)  
+mp_err
+s_mp_add_3arg(const mp_int *a, const mp_int *b, mp_int *c)
 {
-  mp_digit *pa, *pb, *pc;
+    mp_digit *pa, *pb, *pc;
 #if !defined(MP_NO_MP_WORD) && !defined(MP_NO_ADD_WORD)
-  mp_word   w = 0;
+    mp_word w = 0;
 #else
-  mp_digit  sum, carry = 0, d;
+    mp_digit sum, carry = 0, d;
 #endif
-  mp_size   ix;
-  mp_size   used;
-  mp_err    res;
-
-  MP_SIGN(c) = MP_SIGN(a);
-  if (MP_USED(a) < MP_USED(b)) {
-    const mp_int *xch = a;
-    a = b;
-    b = xch;
-  }
-
-  /* Make sure a has enough precision for the output value */
-  if (MP_OKAY != (res = s_mp_pad(c, MP_USED(a))))
-    return res;
+    mp_size ix;
+    mp_size used;
+    mp_err res;
+
+    MP_SIGN(c) = MP_SIGN(a);
+    if (MP_USED(a) < MP_USED(b)) {
+        const mp_int *xch = a;
+        a = b;
+        b = xch;
+    }
 
-  /*
-    Add up all digits up to the precision of b.  If b had initially
-    the same precision as a, or greater, we took care of it by the
-    exchange step above, so there is no problem.  If b had initially
-    less precision, we'll have to make sure the carry out is duly
-    propagated upward among the higher-order digits of the sum.
-   */
-  pa = MP_DIGITS(a);
-  pb = MP_DIGITS(b);
-  pc = MP_DIGITS(c);
-  used = MP_USED(b);
-  for (ix = 0; ix < used; ix++) {
+    /* Make sure a has enough precision for the output value */
+    if (MP_OKAY != (res = s_mp_pad(c, MP_USED(a))))
+        return res;
+
+    /*
+     Add up all digits up to the precision of b.  If b had initially
+     the same precision as a, or greater, we took care of it by the
+     exchange step above, so there is no problem.  If b had initially
+     less precision, we'll have to make sure the carry out is duly
+     propagated upward among the higher-order digits of the sum.
+    */
+    pa = MP_DIGITS(a);
+    pb = MP_DIGITS(b);
+    pc = MP_DIGITS(c);
+    used = MP_USED(b);
+    for (ix = 0; ix < used; ix++) {
 #if !defined(MP_NO_MP_WORD) && !defined(MP_NO_ADD_WORD)
-    w = w + *pa++ + *pb++;
-    *pc++ = ACCUM(w);
-    w = CARRYOUT(w);
+        w = w + *pa++ + *pb++;
+        *pc++ = ACCUM(w);
+        w = CARRYOUT(w);
 #else
-    d = *pa++;
-    sum = d + *pb++;
-    d = (sum < d);			/* detect overflow */
-    *pc++ = sum += carry;
-    carry = d + (sum < carry);		/* detect overflow */
+        d = *pa++;
+        sum = d + *pb++;
+        d = (sum < d); /* detect overflow */
+        *pc++ = sum += carry;
+        carry = d + (sum < carry); /* detect overflow */
 #endif
-  }
+    }
 
-  /* If we run out of 'b' digits before we're actually done, make
-     sure the carries get propagated upward...  
+    /* If we run out of 'b' digits before we're actually done, make
+     sure the carries get propagated upward...
    */
-  for (used = MP_USED(a); ix < used; ++ix) {
+    for (used = MP_USED(a); ix < used; ++ix) {
 #if !defined(MP_NO_MP_WORD) && !defined(MP_NO_ADD_WORD)
-    w = w + *pa++;
-    *pc++ = ACCUM(w);
-    w = CARRYOUT(w);
+        w = w + *pa++;
+        *pc++ = ACCUM(w);
+        w = CARRYOUT(w);
 #else
-    *pc++ = sum = carry + *pa++;
-    carry = (sum < carry);
+        *pc++ = sum = carry + *pa++;
+        carry = (sum < carry);
 #endif
-  }
+    }
 
-  /* If there's an overall carry out, increase precision and include
+/* If there's an overall carry out, increase precision and include
      it.  We could have done this initially, but why touch the memory
      allocator unless we're sure we have to?
    */
 #if !defined(MP_NO_MP_WORD) && !defined(MP_NO_ADD_WORD)
-  if (w) {
-    if((res = s_mp_pad(c, used + 1)) != MP_OKAY)
-      return res;
+    if (w) {
+        if ((res = s_mp_pad(c, used + 1)) != MP_OKAY)
+            return res;
 
-    DIGIT(c, used) = (mp_digit)w;
-    ++used;
-  }
+        DIGIT(c, used) = (mp_digit)w;
+        ++used;
+    }
 #else
-  if (carry) {
-    if((res = s_mp_pad(c, used + 1)) != MP_OKAY)
-      return res;
+    if (carry) {
+        if ((res = s_mp_pad(c, used + 1)) != MP_OKAY)
+            return res;
 
-    DIGIT(c, used) = carry;
-    ++used;
-  }
+        DIGIT(c, used) = carry;
+        ++used;
+    }
 #endif
-  MP_USED(c) = used;
-  return MP_OKAY;
+    MP_USED(c) = used;
+    return MP_OKAY;
 }
 /* {{{ s_mp_add_offset(a, b, offset) */
 
 /* Compute a = |a| + ( |b| * (RADIX ** offset) )             */
-mp_err   s_mp_add_offset(mp_int *a, mp_int *b, mp_size offset)   
+mp_err
+s_mp_add_offset(mp_int *a, mp_int *b, mp_size offset)
 {
 #if !defined(MP_NO_MP_WORD) && !defined(MP_NO_ADD_WORD)
-  mp_word   w, k = 0;
+    mp_word w, k = 0;
 #else
-  mp_digit  d, sum, carry = 0;
+    mp_digit d, sum, carry = 0;
 #endif
-  mp_size   ib;
-  mp_size   ia;
-  mp_size   lim;
-  mp_err    res;
-
-  /* Make sure a has enough precision for the output value */
-  lim = MP_USED(b) + offset;
-  if((lim > USED(a)) && (res = s_mp_pad(a, lim)) != MP_OKAY)
-    return res;
+    mp_size ib;
+    mp_size ia;
+    mp_size lim;
+    mp_err res;
+
+    /* Make sure a has enough precision for the output value */
+    lim = MP_USED(b) + offset;
+    if ((lim > USED(a)) && (res = s_mp_pad(a, lim)) != MP_OKAY)
+        return res;
 
-  /*
+    /*
     Add up all digits up to the precision of b.  If b had initially
     the same precision as a, or greater, we took care of it by the
     padding step above, so there is no problem.  If b had initially
     less precision, we'll have to make sure the carry out is duly
     propagated upward among the higher-order digits of the sum.
    */
-  lim = USED(b);
-  for(ib = 0, ia = offset; ib < lim; ib++, ia++) {
+    lim = USED(b);
+    for (ib = 0, ia = offset; ib < lim; ib++, ia++) {
 #if !defined(MP_NO_MP_WORD) && !defined(MP_NO_ADD_WORD)
-    w = (mp_word)DIGIT(a, ia) + DIGIT(b, ib) + k;
-    DIGIT(a, ia) = ACCUM(w);
-    k = CARRYOUT(w);
+        w = (mp_word)DIGIT(a, ia) + DIGIT(b, ib) + k;
+        DIGIT(a, ia) = ACCUM(w);
+        k = CARRYOUT(w);
 #else
-    d = MP_DIGIT(a, ia);
-    sum = d + MP_DIGIT(b, ib);
-    d = (sum < d);
-    MP_DIGIT(a,ia) = sum += carry;
-    carry = d + (sum < carry);
+        d = MP_DIGIT(a, ia);
+        sum = d + MP_DIGIT(b, ib);
+        d = (sum < d);
+        MP_DIGIT(a, ia) = sum += carry;
+        carry = d + (sum < carry);
 #endif
-  }
+    }
 
-  /* If we run out of 'b' digits before we're actually done, make
-     sure the carries get propagated upward...  
+/* If we run out of 'b' digits before we're actually done, make
+     sure the carries get propagated upward...
    */
 #if !defined(MP_NO_MP_WORD) && !defined(MP_NO_ADD_WORD)
-  for (lim = MP_USED(a); k && (ia < lim); ++ia) {
-    w = (mp_word)DIGIT(a, ia) + k;
-    DIGIT(a, ia) = ACCUM(w);
-    k = CARRYOUT(w);
-  }
+    for (lim = MP_USED(a); k && (ia < lim); ++ia) {
+        w = (mp_word)DIGIT(a, ia) + k;
+        DIGIT(a, ia) = ACCUM(w);
+        k = CARRYOUT(w);
+    }
 #else
-  for (lim = MP_USED(a); carry && (ia < lim); ++ia) {
-    d = MP_DIGIT(a, ia);
-    MP_DIGIT(a,ia) = sum = d + carry;
-    carry = (sum < d);
-  }
+    for (lim = MP_USED(a); carry && (ia < lim); ++ia) {
+        d = MP_DIGIT(a, ia);
+        MP_DIGIT(a, ia) = sum = d + carry;
+        carry = (sum < d);
+    }
 #endif
 
-  /* If there's an overall carry out, increase precision and include
+/* If there's an overall carry out, increase precision and include
      it.  We could have done this initially, but why touch the memory
      allocator unless we're sure we have to?
    */
 #if !defined(MP_NO_MP_WORD) && !defined(MP_NO_ADD_WORD)
-  if(k) {
-    if((res = s_mp_pad(a, USED(a) + 1)) != MP_OKAY)
-      return res;
+    if (k) {
+        if ((res = s_mp_pad(a, USED(a) + 1)) != MP_OKAY)
+            return res;
 
-    DIGIT(a, ia) = (mp_digit)k;
-  }
+        DIGIT(a, ia) = (mp_digit)k;
+    }
 #else
-  if (carry) {
-    if((res = s_mp_pad(a, lim + 1)) != MP_OKAY)
-      return res;
+    if (carry) {
+        if ((res = s_mp_pad(a, lim + 1)) != MP_OKAY)
+            return res;
 
-    DIGIT(a, lim) = carry;
-  }
+        DIGIT(a, lim) = carry;
+    }
 #endif
-  s_mp_clamp(a);
+    s_mp_clamp(a);
 
-  return MP_OKAY;
+    return MP_OKAY;
 
 } /* end s_mp_add_offset() */
 
@@ -3663,399 +3745,419 @@ mp_err   s_mp_add_offset(mp_int *a, mp_int *b, mp_size offset)
 /* {{{ s_mp_sub(a, b) */
 
 /* Compute a = |a| - |b|, assumes |a| >= |b|                              */
-mp_err   s_mp_sub(mp_int *a, const mp_int *b)  /* magnitude subtract      */
+mp_err s_mp_sub(mp_int *a, const mp_int *b) /* magnitude subtract      */
 {
-  mp_digit *pa, *pb, *limit;
+    mp_digit *pa, *pb, *limit;
 #if !defined(MP_NO_MP_WORD) && !defined(MP_NO_SUB_WORD)
-  mp_sword  w = 0;
+    mp_sword w = 0;
 #else
-  mp_digit  d, diff, borrow = 0;
+    mp_digit d, diff, borrow = 0;
 #endif
 
-  /*
+    /*
     Subtract and propagate borrow.  Up to the precision of b, this
     accounts for the digits of b; after that, we just make sure the
     carries get to the right place.  This saves having to pad b out to
     the precision of a just to make the loops work right...
    */
-  pa = MP_DIGITS(a);
-  pb = MP_DIGITS(b);
-  limit = pb + MP_USED(b);
-  while (pb < limit) {
+    pa = MP_DIGITS(a);
+    pb = MP_DIGITS(b);
+    limit = pb + MP_USED(b);
+    while (pb < limit) {
 #if !defined(MP_NO_MP_WORD) && !defined(MP_NO_SUB_WORD)
-    w = w + *pa - *pb++;
-    *pa++ = ACCUM(w);
-    w >>= MP_DIGIT_BIT;
+        w = w + *pa - *pb++;
+        *pa++ = ACCUM(w);
+        w >>= MP_DIGIT_BIT;
 #else
-    d = *pa;
-    diff = d - *pb++;
-    d = (diff > d);				/* detect borrow */
-    if (borrow && --diff == MP_DIGIT_MAX)
-      ++d;
-    *pa++ = diff;
-    borrow = d;	
+        d = *pa;
+        diff = d - *pb++;
+        d = (diff > d); /* detect borrow */
+        if (borrow && --diff == MP_DIGIT_MAX)
+            ++d;
+        *pa++ = diff;
+        borrow = d;
 #endif
-  }
-  limit = MP_DIGITS(a) + MP_USED(a);
+    }
+    limit = MP_DIGITS(a) + MP_USED(a);
 #if !defined(MP_NO_MP_WORD) && !defined(MP_NO_SUB_WORD)
-  while (w && pa < limit) {
-    w = w + *pa;
-    *pa++ = ACCUM(w);
-    w >>= MP_DIGIT_BIT;
-  }
+    while (w && pa < limit) {
+        w = w + *pa;
+        *pa++ = ACCUM(w);
+        w >>= MP_DIGIT_BIT;
+    }
 #else
-  while (borrow && pa < limit) {
-    d = *pa;
-    *pa++ = diff = d - borrow;
-    borrow = (diff > d);
-  }
+    while (borrow && pa < limit) {
+        d = *pa;
+        *pa++ = diff = d - borrow;
+        borrow = (diff > d);
+    }
 #endif
 
-  /* Clobber any leading zeroes we created    */
-  s_mp_clamp(a);
+    /* Clobber any leading zeroes we created    */
+    s_mp_clamp(a);
 
-  /* 
+/*
      If there was a borrow out, then |b| > |a| in violation
      of our input invariant.  We've already done the work,
      but we'll at least complain about it...
    */
 #if !defined(MP_NO_MP_WORD) && !defined(MP_NO_SUB_WORD)
-  return w ? MP_RANGE : MP_OKAY;
+    return w ? MP_RANGE : MP_OKAY;
 #else
-  return borrow ? MP_RANGE : MP_OKAY;
+    return borrow ? MP_RANGE : MP_OKAY;
 #endif
 } /* end s_mp_sub() */
 
 /* }}} */
 
 /* Compute c = |a| - |b|, assumes |a| >= |b| */ /* magnitude subtract      */
-mp_err   s_mp_sub_3arg(const mp_int *a, const mp_int *b, mp_int *c)  
+mp_err
+s_mp_sub_3arg(const mp_int *a, const mp_int *b, mp_int *c)
 {
-  mp_digit *pa, *pb, *pc;
+    mp_digit *pa, *pb, *pc;
 #if !defined(MP_NO_MP_WORD) && !defined(MP_NO_SUB_WORD)
-  mp_sword  w = 0;
+    mp_sword w = 0;
 #else
-  mp_digit  d, diff, borrow = 0;
+    mp_digit d, diff, borrow = 0;
 #endif
-  int       ix, limit;
-  mp_err    res;
+    int ix, limit;
+    mp_err res;
 
-  MP_SIGN(c) = MP_SIGN(a);
+    MP_SIGN(c) = MP_SIGN(a);
 
-  /* Make sure a has enough precision for the output value */
-  if (MP_OKAY != (res = s_mp_pad(c, MP_USED(a))))
-    return res;
+    /* Make sure a has enough precision for the output value */
+    if (MP_OKAY != (res = s_mp_pad(c, MP_USED(a))))
+        return res;
 
-  /*
+    /*
     Subtract and propagate borrow.  Up to the precision of b, this
     accounts for the digits of b; after that, we just make sure the
     carries get to the right place.  This saves having to pad b out to
     the precision of a just to make the loops work right...
    */
-  pa = MP_DIGITS(a);
-  pb = MP_DIGITS(b);
-  pc = MP_DIGITS(c);
-  limit = MP_USED(b);
-  for (ix = 0; ix < limit; ++ix) {
+    pa = MP_DIGITS(a);
+    pb = MP_DIGITS(b);
+    pc = MP_DIGITS(c);
+    limit = MP_USED(b);
+    for (ix = 0; ix < limit; ++ix) {
 #if !defined(MP_NO_MP_WORD) && !defined(MP_NO_SUB_WORD)
-    w = w + *pa++ - *pb++;
-    *pc++ = ACCUM(w);
-    w >>= MP_DIGIT_BIT;
+        w = w + *pa++ - *pb++;
+        *pc++ = ACCUM(w);
+        w >>= MP_DIGIT_BIT;
 #else
-    d = *pa++;
-    diff = d - *pb++;
-    d = (diff > d);
-    if (borrow && --diff == MP_DIGIT_MAX)
-      ++d;
-    *pc++ = diff;
-    borrow = d;
+        d = *pa++;
+        diff = d - *pb++;
+        d = (diff > d);
+        if (borrow && --diff == MP_DIGIT_MAX)
+            ++d;
+        *pc++ = diff;
+        borrow = d;
 #endif
-  }
-  for (limit = MP_USED(a); ix < limit; ++ix) {
+    }
+    for (limit = MP_USED(a); ix < limit; ++ix) {
 #if !defined(MP_NO_MP_WORD) && !defined(MP_NO_SUB_WORD)
-    w = w + *pa++;
-    *pc++ = ACCUM(w);
-    w >>= MP_DIGIT_BIT;
+        w = w + *pa++;
+        *pc++ = ACCUM(w);
+        w >>= MP_DIGIT_BIT;
 #else
-    d = *pa++;
-    *pc++ = diff = d - borrow;
-    borrow = (diff > d);
+        d = *pa++;
+        *pc++ = diff = d - borrow;
+        borrow = (diff > d);
 #endif
-  }
+    }
 
-  /* Clobber any leading zeroes we created    */
-  MP_USED(c) = ix;
-  s_mp_clamp(c);
+    /* Clobber any leading zeroes we created    */
+    MP_USED(c) = ix;
+    s_mp_clamp(c);
 
-  /* 
+/*
      If there was a borrow out, then |b| > |a| in violation
      of our input invariant.  We've already done the work,
      but we'll at least complain about it...
    */
 #if !defined(MP_NO_MP_WORD) && !defined(MP_NO_SUB_WORD)
-  return w ? MP_RANGE : MP_OKAY;
+    return w ? MP_RANGE : MP_OKAY;
 #else
-  return borrow ? MP_RANGE : MP_OKAY;
+    return borrow ? MP_RANGE : MP_OKAY;
 #endif
 }
 /* {{{ s_mp_mul(a, b) */
 
 /* Compute a = |a| * |b|                                                  */
-mp_err   s_mp_mul(mp_int *a, const mp_int *b)
+mp_err
+s_mp_mul(mp_int *a, const mp_int *b)
 {
-  return mp_mul(a, b, a);
+    return mp_mul(a, b, a);
 } /* end s_mp_mul() */
 
 /* }}} */
 
 #if defined(MP_USE_UINT_DIGIT) && defined(MP_USE_LONG_LONG_MULTIPLY)
 /* This trick works on Sparc V8 CPUs with the Workshop compilers. */
-#define MP_MUL_DxD(a, b, Phi, Plo) \
-  { unsigned long long product = (unsigned long long)a * b; \
-    Plo = (mp_digit)product; \
-    Phi = (mp_digit)(product >> MP_DIGIT_BIT); }
+#define MP_MUL_DxD(a, b, Phi, Plo)                              \
+    {                                                           \
+        unsigned long long product = (unsigned long long)a * b; \
+        Plo = (mp_digit)product;                                \
+        Phi = (mp_digit)(product >> MP_DIGIT_BIT);              \
+    }
 #elif defined(OSF1)
-#define MP_MUL_DxD(a, b, Phi, Plo) \
-  { Plo = asm ("mulq %a0, %a1, %v0", a, b);\
-    Phi = asm ("umulh %a0, %a1, %v0", a, b); }
+#define MP_MUL_DxD(a, b, Phi, Plo)              \
+    {                                           \
+        Plo = asm("mulq %a0, %a1, %v0", a, b);  \
+        Phi = asm("umulh %a0, %a1, %v0", a, b); \
+    }
 #else
-#define MP_MUL_DxD(a, b, Phi, Plo) \
-  { mp_digit a0b1, a1b0; \
-    Plo = (a & MP_HALF_DIGIT_MAX) * (b & MP_HALF_DIGIT_MAX); \
-    Phi = (a >> MP_HALF_DIGIT_BIT) * (b >> MP_HALF_DIGIT_BIT); \
-    a0b1 = (a & MP_HALF_DIGIT_MAX) * (b >> MP_HALF_DIGIT_BIT); \
-    a1b0 = (a >> MP_HALF_DIGIT_BIT) * (b & MP_HALF_DIGIT_MAX); \
-    a1b0 += a0b1; \
-    Phi += a1b0 >> MP_HALF_DIGIT_BIT; \
-    if (a1b0 < a0b1)  \
-      Phi += MP_HALF_RADIX; \
-    a1b0 <<= MP_HALF_DIGIT_BIT; \
-    Plo += a1b0; \
-    if (Plo < a1b0) \
-      ++Phi; \
-  }
+#define MP_MUL_DxD(a, b, Phi, Plo)                                 \
+    {                                                              \
+        mp_digit a0b1, a1b0;                                       \
+        Plo = (a & MP_HALF_DIGIT_MAX) * (b & MP_HALF_DIGIT_MAX);   \
+        Phi = (a >> MP_HALF_DIGIT_BIT) * (b >> MP_HALF_DIGIT_BIT); \
+        a0b1 = (a & MP_HALF_DIGIT_MAX) * (b >> MP_HALF_DIGIT_BIT); \
+        a1b0 = (a >> MP_HALF_DIGIT_BIT) * (b & MP_HALF_DIGIT_MAX); \
+        a1b0 += a0b1;                                              \
+        Phi += a1b0 >> MP_HALF_DIGIT_BIT;                          \
+        if (a1b0 < a0b1)                                           \
+            Phi += MP_HALF_RADIX;                                  \
+        a1b0 <<= MP_HALF_DIGIT_BIT;                                \
+        Plo += a1b0;                                               \
+        if (Plo < a1b0)                                            \
+            ++Phi;                                                 \
+    }
 #endif
 
 #if !defined(MP_ASSEMBLY_MULTIPLY)
 /* c = a * b */
-void s_mpv_mul_d(const mp_digit *a, mp_size a_len, mp_digit b, mp_digit *c)
+void
+s_mpv_mul_d(const mp_digit *a, mp_size a_len, mp_digit b, mp_digit *c)
 {
 #if !defined(MP_NO_MP_WORD) && !defined(MP_NO_MUL_WORD)
-  mp_digit   d = 0;
-
-  /* Inner product:  Digits of a */
-  while (a_len--) {
-    mp_word w = ((mp_word)b * *a++) + d;
-    *c++ = ACCUM(w);
-    d = CARRYOUT(w);
-  }
-  *c = d;
+    mp_digit d = 0;
+
+    /* Inner product:  Digits of a */
+    while (a_len--) {
+        mp_word w = ((mp_word)b * *a++) + d;
+        *c++ = ACCUM(w);
+        d = CARRYOUT(w);
+    }
+    *c = d;
 #else
-  mp_digit carry = 0;
-  while (a_len--) {
-    mp_digit a_i = *a++;
-    mp_digit a0b0, a1b1;
-
-    MP_MUL_DxD(a_i, b, a1b1, a0b0);
-
-    a0b0 += carry;
-    if (a0b0 < carry)
-      ++a1b1;
-    *c++ = a0b0;
-    carry = a1b1;
-  }
-  *c = carry;
+    mp_digit carry = 0;
+    while (a_len--) {
+        mp_digit a_i = *a++;
+        mp_digit a0b0, a1b1;
+
+        MP_MUL_DxD(a_i, b, a1b1, a0b0);
+
+        a0b0 += carry;
+        if (a0b0 < carry)
+            ++a1b1;
+        *c++ = a0b0;
+        carry = a1b1;
+    }
+    *c = carry;
 #endif
 }
 
 /* c += a * b */
-void s_mpv_mul_d_add(const mp_digit *a, mp_size a_len, mp_digit b, 
-			      mp_digit *c)
+void
+s_mpv_mul_d_add(const mp_digit *a, mp_size a_len, mp_digit b,
+                mp_digit *c)
 {
 #if !defined(MP_NO_MP_WORD) && !defined(MP_NO_MUL_WORD)
-  mp_digit   d = 0;
-
-  /* Inner product:  Digits of a */
-  while (a_len--) {
-    mp_word w = ((mp_word)b * *a++) + *c + d;
-    *c++ = ACCUM(w);
-    d = CARRYOUT(w);
-  }
-  *c = d;
+    mp_digit d = 0;
+
+    /* Inner product:  Digits of a */
+    while (a_len--) {
+        mp_word w = ((mp_word)b * *a++) + *c + d;
+        *c++ = ACCUM(w);
+        d = CARRYOUT(w);
+    }
+    *c = d;
 #else
-  mp_digit carry = 0;
-  while (a_len--) {
-    mp_digit a_i = *a++;
-    mp_digit a0b0, a1b1;
-
-    MP_MUL_DxD(a_i, b, a1b1, a0b0);
-
-    a0b0 += carry;
-    if (a0b0 < carry)
-      ++a1b1;
-    a0b0 += a_i = *c;
-    if (a0b0 < a_i)
-      ++a1b1;
-    *c++ = a0b0;
-    carry = a1b1;
-  }
-  *c = carry;
+    mp_digit carry = 0;
+    while (a_len--) {
+        mp_digit a_i = *a++;
+        mp_digit a0b0, a1b1;
+
+        MP_MUL_DxD(a_i, b, a1b1, a0b0);
+
+        a0b0 += carry;
+        if (a0b0 < carry)
+            ++a1b1;
+        a0b0 += a_i = *c;
+        if (a0b0 < a_i)
+            ++a1b1;
+        *c++ = a0b0;
+        carry = a1b1;
+    }
+    *c = carry;
 #endif
 }
 
 /* Presently, this is only used by the Montgomery arithmetic code. */
 /* c += a * b */
-void s_mpv_mul_d_add_prop(const mp_digit *a, mp_size a_len, mp_digit b, mp_digit *c)
+void
+s_mpv_mul_d_add_prop(const mp_digit *a, mp_size a_len, mp_digit b, mp_digit *c)
 {
 #if !defined(MP_NO_MP_WORD) && !defined(MP_NO_MUL_WORD)
-  mp_digit   d = 0;
-
-  /* Inner product:  Digits of a */
-  while (a_len--) {
-    mp_word w = ((mp_word)b * *a++) + *c + d;
-    *c++ = ACCUM(w);
-    d = CARRYOUT(w);
-  }
-
-  while (d) {
-    mp_word w = (mp_word)*c + d;
-    *c++ = ACCUM(w);
-    d = CARRYOUT(w);
-  }
+    mp_digit d = 0;
+
+    /* Inner product:  Digits of a */
+    while (a_len--) {
+        mp_word w = ((mp_word)b * *a++) + *c + d;
+        *c++ = ACCUM(w);
+        d = CARRYOUT(w);
+    }
+
+    while (d) {
+        mp_word w = (mp_word)*c + d;
+        *c++ = ACCUM(w);
+        d = CARRYOUT(w);
+    }
 #else
-  mp_digit carry = 0;
-  while (a_len--) {
-    mp_digit a_i = *a++;
-    mp_digit a0b0, a1b1;
-
-    MP_MUL_DxD(a_i, b, a1b1, a0b0);
-
-    a0b0 += carry;
-    if (a0b0 < carry)
-      ++a1b1;
-
-    a0b0 += a_i = *c;
-    if (a0b0 < a_i)
-      ++a1b1;
-
-    *c++ = a0b0;
-    carry = a1b1;
-  }
-  while (carry) {
-    mp_digit c_i = *c;
-    carry += c_i;
-    *c++ = carry;
-    carry = carry < c_i;
-  }
+    mp_digit carry = 0;
+    while (a_len--) {
+        mp_digit a_i = *a++;
+        mp_digit a0b0, a1b1;
+
+        MP_MUL_DxD(a_i, b, a1b1, a0b0);
+
+        a0b0 += carry;
+        if (a0b0 < carry)
+            ++a1b1;
+
+        a0b0 += a_i = *c;
+        if (a0b0 < a_i)
+            ++a1b1;
+
+        *c++ = a0b0;
+        carry = a1b1;
+    }
+    while (carry) {
+        mp_digit c_i = *c;
+        carry += c_i;
+        *c++ = carry;
+        carry = carry < c_i;
+    }
 #endif
 }
 #endif
 
 #if defined(MP_USE_UINT_DIGIT) && defined(MP_USE_LONG_LONG_MULTIPLY)
 /* This trick works on Sparc V8 CPUs with the Workshop compilers. */
-#define MP_SQR_D(a, Phi, Plo) \
-  { unsigned long long square = (unsigned long long)a * a; \
-    Plo = (mp_digit)square; \
-    Phi = (mp_digit)(square >> MP_DIGIT_BIT); }
+#define MP_SQR_D(a, Phi, Plo)                                  \
+    {                                                          \
+        unsigned long long square = (unsigned long long)a * a; \
+        Plo = (mp_digit)square;                                \
+        Phi = (mp_digit)(square >> MP_DIGIT_BIT);              \
+    }
 #elif defined(OSF1)
-#define MP_SQR_D(a, Phi, Plo) \
-  { Plo = asm ("mulq  %a0, %a0, %v0", a);\
-    Phi = asm ("umulh %a0, %a0, %v0", a); }
+#define MP_SQR_D(a, Phi, Plo)                \
+    {                                        \
+        Plo = asm("mulq  %a0, %a0, %v0", a); \
+        Phi = asm("umulh %a0, %a0, %v0", a); \
+    }
 #else
-#define MP_SQR_D(a, Phi, Plo) \
-  { mp_digit Pmid; \
-    Plo  = (a  & MP_HALF_DIGIT_MAX) * (a  & MP_HALF_DIGIT_MAX); \
-    Phi  = (a >> MP_HALF_DIGIT_BIT) * (a >> MP_HALF_DIGIT_BIT); \
-    Pmid = (a  & MP_HALF_DIGIT_MAX) * (a >> MP_HALF_DIGIT_BIT); \
-    Phi += Pmid >> (MP_HALF_DIGIT_BIT - 1);  \
-    Pmid <<= (MP_HALF_DIGIT_BIT + 1);  \
-    Plo += Pmid;  \
-    if (Plo < Pmid)  \
-      ++Phi;  \
-  }
+#define MP_SQR_D(a, Phi, Plo)                                      \
+    {                                                              \
+        mp_digit Pmid;                                             \
+        Plo = (a & MP_HALF_DIGIT_MAX) * (a & MP_HALF_DIGIT_MAX);   \
+        Phi = (a >> MP_HALF_DIGIT_BIT) * (a >> MP_HALF_DIGIT_BIT); \
+        Pmid = (a & MP_HALF_DIGIT_MAX) * (a >> MP_HALF_DIGIT_BIT); \
+        Phi += Pmid >> (MP_HALF_DIGIT_BIT - 1);                    \
+        Pmid <<= (MP_HALF_DIGIT_BIT + 1);                          \
+        Plo += Pmid;                                               \
+        if (Plo < Pmid)                                            \
+            ++Phi;                                                 \
+    }
 #endif
 
 #if !defined(MP_ASSEMBLY_SQUARE)
 /* Add the squares of the digits of a to the digits of b. */
-void s_mpv_sqr_add_prop(const mp_digit *pa, mp_size a_len, mp_digit *ps)
+void
+s_mpv_sqr_add_prop(const mp_digit *pa, mp_size a_len, mp_digit *ps)
 {
 #if !defined(MP_NO_MP_WORD) && !defined(MP_NO_MUL_WORD)
-  mp_word  w;
-  mp_digit d;
-  mp_size  ix;
-
-  w  = 0;
-#define ADD_SQUARE(n) \
-    d = pa[n]; \
-    w += (d * (mp_word)d) + ps[2*n]; \
-    ps[2*n] = ACCUM(w); \
-    w = (w >> DIGIT_BIT) + ps[2*n+1]; \
-    ps[2*n+1] = ACCUM(w); \
+    mp_word w;
+    mp_digit d;
+    mp_size ix;
+
+    w = 0;
+#define ADD_SQUARE(n)                     \
+    d = pa[n];                            \
+    w += (d * (mp_word)d) + ps[2 * n];    \
+    ps[2 * n] = ACCUM(w);                 \
+    w = (w >> DIGIT_BIT) + ps[2 * n + 1]; \
+    ps[2 * n + 1] = ACCUM(w);             \
     w = (w >> DIGIT_BIT)
 
-  for (ix = a_len; ix >= 4; ix -= 4) {
-    ADD_SQUARE(0);
-    ADD_SQUARE(1);
-    ADD_SQUARE(2);
-    ADD_SQUARE(3);
-    pa += 4;
-    ps += 8;
-  }
-  if (ix) {
-    ps += 2*ix;
-    pa += ix;
-    switch (ix) {
-    case 3: ADD_SQUARE(-3); /* FALLTHRU */
-    case 2: ADD_SQUARE(-2); /* FALLTHRU */
-    case 1: ADD_SQUARE(-1); /* FALLTHRU */
-    case 0: break;
-    }
-  }
-  while (w) {
-    w += *ps;
-    *ps++ = ACCUM(w);
-    w = (w >> DIGIT_BIT);
-  }
+    for (ix = a_len; ix >= 4; ix -= 4) {
+        ADD_SQUARE(0);
+        ADD_SQUARE(1);
+        ADD_SQUARE(2);
+        ADD_SQUARE(3);
+        pa += 4;
+        ps += 8;
+    }
+    if (ix) {
+        ps += 2 * ix;
+        pa += ix;
+        switch (ix) {
+            case 3:
+                ADD_SQUARE(-3); /* FALLTHRU */
+            case 2:
+                ADD_SQUARE(-2); /* FALLTHRU */
+            case 1:
+                ADD_SQUARE(-1); /* FALLTHRU */
+            case 0:
+                break;
+        }
+    }
+    while (w) {
+        w += *ps;
+        *ps++ = ACCUM(w);
+        w = (w >> DIGIT_BIT);
+    }
 #else
-  mp_digit carry = 0;
-  while (a_len--) {
-    mp_digit a_i = *pa++;
-    mp_digit a0a0, a1a1;
-
-    MP_SQR_D(a_i, a1a1, a0a0);
-
-    /* here a1a1 and a0a0 constitute a_i ** 2 */
-    a0a0 += carry;
-    if (a0a0 < carry)
-      ++a1a1;
-
-    /* now add to ps */
-    a0a0 += a_i = *ps;
-    if (a0a0 < a_i)
-      ++a1a1;
-    *ps++ = a0a0;
-    a1a1 += a_i = *ps;
-    carry = (a1a1 < a_i);
-    *ps++ = a1a1;
-  }
-  while (carry) {
-    mp_digit s_i = *ps;
-    carry += s_i;
-    *ps++ = carry;
-    carry = carry < s_i;
-  }
+    mp_digit carry = 0;
+    while (a_len--) {
+        mp_digit a_i = *pa++;
+        mp_digit a0a0, a1a1;
+
+        MP_SQR_D(a_i, a1a1, a0a0);
+
+        /* here a1a1 and a0a0 constitute a_i ** 2 */
+        a0a0 += carry;
+        if (a0a0 < carry)
+            ++a1a1;
+
+        /* now add to ps */
+        a0a0 += a_i = *ps;
+        if (a0a0 < a_i)
+            ++a1a1;
+        *ps++ = a0a0;
+        a1a1 += a_i = *ps;
+        carry = (a1a1 < a_i);
+        *ps++ = a1a1;
+    }
+    while (carry) {
+        mp_digit s_i = *ps;
+        carry += s_i;
+        *ps++ = carry;
+        carry = carry < s_i;
+    }
 #endif
 }
 #endif
 
-#if (defined(MP_NO_MP_WORD) || defined(MP_NO_DIV_WORD)) \
-&& !defined(MP_ASSEMBLY_DIV_2DX1D)
+#if (defined(MP_NO_MP_WORD) || defined(MP_NO_DIV_WORD)) && !defined(MP_ASSEMBLY_DIV_2DX1D)
 /*
-** Divide 64-bit (Nhi,Nlo) by 32-bit divisor, which must be normalized 
+** Divide 64-bit (Nhi,Nlo) by 32-bit divisor, which must be normalized
 ** so its high bit is 1.   This code is from NSPR.
 */
-mp_err s_mpv_div_2dx1d(mp_digit Nhi, mp_digit Nlo, mp_digit divisor, 
-		       mp_digit *qp, mp_digit *rp)
+mp_err
+s_mpv_div_2dx1d(mp_digit Nhi, mp_digit Nlo, mp_digit divisor,
+                mp_digit *qp, mp_digit *rp)
 {
     mp_digit d1, d0, q1, q0;
     mp_digit r1, r0, m;
@@ -4069,8 +4171,8 @@ mp_err s_mpv_div_2dx1d(mp_digit Nhi, mp_digit Nlo, mp_digit divisor,
     if (r1 < m) {
         q1--, r1 += divisor;
         if (r1 >= divisor && r1 < m) {
-	    q1--, r1 += divisor;
-	}
+            q1--, r1 += divisor;
+        }
     }
     r1 -= m;
     r0 = r1 % d1;
@@ -4080,13 +4182,13 @@ mp_err s_mpv_div_2dx1d(mp_digit Nhi, mp_digit Nlo, mp_digit divisor,
     if (r0 < m) {
         q0--, r0 += divisor;
         if (r0 >= divisor && r0 < m) {
-	    q0--, r0 += divisor;
-	}
+            q0--, r0 += divisor;
+        }
     }
     if (qp)
-	*qp = (q1 << MP_HALF_DIGIT_BIT) | q0;
+        *qp = (q1 << MP_HALF_DIGIT_BIT) | q0;
     if (rp)
-	*rp = r0 - m;
+        *rp = r0 - m;
     return MP_OKAY;
 }
 #endif
@@ -4094,19 +4196,20 @@ mp_err s_mpv_div_2dx1d(mp_digit Nhi, mp_digit Nlo, mp_digit divisor,
 #if MP_SQUARE
 /* {{{ s_mp_sqr(a) */
 
-mp_err   s_mp_sqr(mp_int *a)
+mp_err
+s_mp_sqr(mp_int *a)
 {
-  mp_err   res;
-  mp_int   tmp;
+    mp_err res;
+    mp_int tmp;
 
-  if((res = mp_init_size(&tmp, 2 * USED(a))) != MP_OKAY)
+    if ((res = mp_init_size(&tmp, 2 * USED(a))) != MP_OKAY)
+        return res;
+    res = mp_sqr(a, &tmp);
+    if (res == MP_OKAY) {
+        s_mp_exch(&tmp, a);
+    }
+    mp_clear(&tmp);
     return res;
-  res = mp_sqr(a, &tmp);
-  if (res == MP_OKAY) {
-    s_mp_exch(&tmp, a);
-  }
-  mp_clear(&tmp);
-  return res;
 }
 
 /* }}} */
@@ -4120,170 +4223,170 @@ mp_err   s_mp_sqr(mp_int *a)
   Compute a = a / b and b = a mod b.  Assumes b > a.
  */
 
-mp_err   s_mp_div(mp_int *rem, 	/* i: dividend, o: remainder */
-                  mp_int *div, 	/* i: divisor                */
-		  mp_int *quot)	/* i: 0;        o: quotient  */
+mp_err s_mp_div(mp_int *rem,  /* i: dividend, o: remainder */
+                mp_int *div,  /* i: divisor                */
+                mp_int *quot) /* i: 0;        o: quotient  */
 {
-  mp_int   part, t;
+    mp_int part, t;
 #if !defined(MP_NO_MP_WORD) && !defined(MP_NO_DIV_WORD)
-  mp_word  q_msd;
+    mp_word q_msd;
 #else
-  mp_digit q_msd;
+    mp_digit q_msd;
 #endif
-  mp_err   res;
-  mp_digit d;
-  mp_digit div_msd;
-  int      ix;
-
-  if(mp_cmp_z(div) == 0)
-    return MP_RANGE;
-
-  DIGITS(&t) = 0;
-  /* Shortcut if divisor is power of two */
-  if((ix = s_mp_ispow2(div)) >= 0) {
-    MP_CHECKOK( mp_copy(rem, quot) );
-    s_mp_div_2d(quot, (mp_digit)ix);
-    s_mp_mod_2d(rem,  (mp_digit)ix);
-
-    return MP_OKAY;
-  }
+    mp_err res;
+    mp_digit d;
+    mp_digit div_msd;
+    int ix;
+
+    if (mp_cmp_z(div) == 0)
+        return MP_RANGE;
+
+    DIGITS(&t) = 0;
+    /* Shortcut if divisor is power of two */
+    if ((ix = s_mp_ispow2(div)) >= 0) {
+        MP_CHECKOK(mp_copy(rem, quot));
+        s_mp_div_2d(quot, (mp_digit)ix);
+        s_mp_mod_2d(rem, (mp_digit)ix);
+
+        return MP_OKAY;
+    }
 
-  MP_SIGN(rem) = ZPOS;
-  MP_SIGN(div) = ZPOS;
-  MP_SIGN(&part) = ZPOS;
+    MP_SIGN(rem) = ZPOS;
+    MP_SIGN(div) = ZPOS;
+    MP_SIGN(&part) = ZPOS;
 
-  /* A working temporary for division     */
-  MP_CHECKOK( mp_init_size(&t, MP_ALLOC(rem)));
+    /* A working temporary for division     */
+    MP_CHECKOK(mp_init_size(&t, MP_ALLOC(rem)));
 
-  /* Normalize to optimize guessing       */
-  MP_CHECKOK( s_mp_norm(rem, div, &d) );
+    /* Normalize to optimize guessing       */
+    MP_CHECKOK(s_mp_norm(rem, div, &d));
 
-  /* Perform the division itself...woo!   */
-  MP_USED(quot) = MP_ALLOC(quot);
+    /* Perform the division itself...woo!   */
+    MP_USED(quot) = MP_ALLOC(quot);
 
-  /* Find a partial substring of rem which is at least div */
-  /* If we didn't find one, we're finished dividing    */
-  while (MP_USED(rem) > MP_USED(div) || s_mp_cmp(rem, div) >= 0) {
-    int i;
-    int unusedRem;
-    int partExtended = 0;  /* set to true if we need to extend part */
+    /* Find a partial substring of rem which is at least div */
+    /* If we didn't find one, we're finished dividing    */
+    while (MP_USED(rem) > MP_USED(div) || s_mp_cmp(rem, div) >= 0) {
+        int i;
+        int unusedRem;
+        int partExtended = 0; /* set to true if we need to extend part */
 
-    unusedRem = MP_USED(rem) - MP_USED(div);
-    MP_DIGITS(&part) = MP_DIGITS(rem) + unusedRem;
-    MP_ALLOC(&part)  = MP_ALLOC(rem)  - unusedRem;
-    MP_USED(&part)   = MP_USED(div);
+        unusedRem = MP_USED(rem) - MP_USED(div);
+        MP_DIGITS(&part) = MP_DIGITS(rem) + unusedRem;
+        MP_ALLOC(&part) = MP_ALLOC(rem) - unusedRem;
+        MP_USED(&part) = MP_USED(div);
 
-    /* We have now truncated the part of the remainder to the same length as
+        /* We have now truncated the part of the remainder to the same length as
      * the divisor. If part is smaller than div, extend part by one digit. */
-    if (s_mp_cmp(&part, div) < 0) {
-      -- unusedRem;
+        if (s_mp_cmp(&part, div) < 0) {
+            --unusedRem;
 #if MP_ARGCHK == 2
-      assert(unusedRem >= 0);
+            assert(unusedRem >= 0);
 #endif
-      -- MP_DIGITS(&part);
-      ++ MP_USED(&part);
-      ++ MP_ALLOC(&part);
-      partExtended = 1;
-    }
-
-    /* Compute a guess for the next quotient digit       */
-    q_msd = MP_DIGIT(&part, MP_USED(&part) - 1);
-    div_msd = MP_DIGIT(div, MP_USED(div) - 1);
-    if (!partExtended) {
-      /* In this case, q_msd /= div_msd is always 1. First, since div_msd is
+            --MP_DIGITS(&part);
+            ++MP_USED(&part);
+            ++MP_ALLOC(&part);
+            partExtended = 1;
+        }
+
+        /* Compute a guess for the next quotient digit       */
+        q_msd = MP_DIGIT(&part, MP_USED(&part) - 1);
+        div_msd = MP_DIGIT(div, MP_USED(div) - 1);
+        if (!partExtended) {
+            /* In this case, q_msd /= div_msd is always 1. First, since div_msd is
        * normalized to have the high bit set, 2*div_msd > MP_DIGIT_MAX. Since
        * we didn't extend part, q_msd >= div_msd. Therefore we know that
        * div_msd <= q_msd <= MP_DIGIT_MAX < 2*div_msd. Dividing by div_msd we
        * get 1 <= q_msd/div_msd < 2. So q_msd /= div_msd must be 1. */
-      q_msd = 1;
-    } else {
+            q_msd = 1;
+        } else {
 #if !defined(MP_NO_MP_WORD) && !defined(MP_NO_DIV_WORD)
-      q_msd = (q_msd << MP_DIGIT_BIT) | MP_DIGIT(&part, MP_USED(&part) - 2);
-      q_msd /= div_msd;
-      if (q_msd == RADIX)
-        --q_msd;
+            q_msd = (q_msd << MP_DIGIT_BIT) | MP_DIGIT(&part, MP_USED(&part) - 2);
+            q_msd /= div_msd;
+            if (q_msd == RADIX)
+                --q_msd;
 #else
-      if (q_msd == div_msd) {
-        q_msd = MP_DIGIT_MAX;
-      } else {
-        mp_digit r;
-        MP_CHECKOK( s_mpv_div_2dx1d(q_msd, MP_DIGIT(&part, MP_USED(&part) - 2),
-				    div_msd, &q_msd, &r) );
-      }
+            if (q_msd == div_msd) {
+                q_msd = MP_DIGIT_MAX;
+            } else {
+                mp_digit r;
+                MP_CHECKOK(s_mpv_div_2dx1d(q_msd, MP_DIGIT(&part, MP_USED(&part) - 2),
+                                           div_msd, &q_msd, &r));
+            }
 #endif
-    }
+        }
 #if MP_ARGCHK == 2
-    assert(q_msd > 0); /* This case should never occur any more. */
+        assert(q_msd > 0); /* This case should never occur any more. */
 #endif
-    if (q_msd <= 0)
-      break;
+        if (q_msd <= 0)
+            break;
 
-    /* See what that multiplies out to                   */
-    mp_copy(div, &t);
-    MP_CHECKOK( s_mp_mul_d(&t, (mp_digit)q_msd) );
+        /* See what that multiplies out to                   */
+        mp_copy(div, &t);
+        MP_CHECKOK(s_mp_mul_d(&t, (mp_digit)q_msd));
 
-    /* 
+        /*
        If it's too big, back it off.  We should not have to do this
        more than once, or, in rare cases, twice.  Knuth describes a
        method by which this could be reduced to a maximum of once, but
        I didn't implement that here.
      * When using s_mpv_div_2dx1d, we may have to do this 3 times.
      */
-    for (i = 4; s_mp_cmp(&t, &part) > 0 && i > 0; --i) {
-      --q_msd;
-      MP_CHECKOK(s_mp_sub(&t, div));	/* t -= div */
-    }
-    if (i < 0) {
-      res = MP_RANGE;
-      goto CLEANUP;
-    }
-
-    /* At this point, q_msd should be the right next digit   */
-    MP_CHECKOK( s_mp_sub(&part, &t) );	/* part -= t */
-    s_mp_clamp(rem);
-
-    /*
+        for (i = 4; s_mp_cmp(&t, &part) > 0 && i > 0; --i) {
+            --q_msd;
+            MP_CHECKOK(s_mp_sub(&t, div)); /* t -= div */
+        }
+        if (i < 0) {
+            res = MP_RANGE;
+            goto CLEANUP;
+        }
+
+        /* At this point, q_msd should be the right next digit   */
+        MP_CHECKOK(s_mp_sub(&part, &t)); /* part -= t */
+        s_mp_clamp(rem);
+
+        /*
       Include the digit in the quotient.  We allocated enough memory
       for any quotient we could ever possibly get, so we should not
       have to check for failures here
      */
-    MP_DIGIT(quot, unusedRem) = (mp_digit)q_msd;
-  }
+        MP_DIGIT(quot, unusedRem) = (mp_digit)q_msd;
+    }
 
-  /* Denormalize remainder                */
-  if (d) {
-    s_mp_div_2d(rem, d);
-  }
+    /* Denormalize remainder                */
+    if (d) {
+        s_mp_div_2d(rem, d);
+    }
 
-  s_mp_clamp(quot);
+    s_mp_clamp(quot);
 
 CLEANUP:
-  mp_clear(&t);
+    mp_clear(&t);
 
-  return res;
+    return res;
 
 } /* end s_mp_div() */
 
-
 /* }}} */
 
 /* {{{ s_mp_2expt(a, k) */
 
-mp_err   s_mp_2expt(mp_int *a, mp_digit k)
+mp_err
+s_mp_2expt(mp_int *a, mp_digit k)
 {
-  mp_err    res;
-  mp_size   dig, bit;
+    mp_err res;
+    mp_size dig, bit;
 
-  dig = k / DIGIT_BIT;
-  bit = k % DIGIT_BIT;
+    dig = k / DIGIT_BIT;
+    bit = k % DIGIT_BIT;
 
-  mp_zero(a);
-  if((res = s_mp_pad(a, dig + 1)) != MP_OKAY)
-    return res;
-  
-  DIGIT(a, dig) |= ((mp_digit)1 << bit);
+    mp_zero(a);
+    if ((res = s_mp_pad(a, dig + 1)) != MP_OKAY)
+        return res;
+
+    DIGIT(a, dig) |= ((mp_digit)1 << bit);
 
-  return MP_OKAY;
+    return MP_OKAY;
 
 } /* end s_mp_2expt() */
 
@@ -4301,51 +4404,52 @@ mp_err   s_mp_2expt(mp_int *a, mp_digit k)
 
   This algorithm was derived from the _Handbook of Applied
   Cryptography_ by Menezes, Oorschot and VanStone, Ch. 14,
-  pp. 603-604.  
+  pp. 603-604.
  */
 
-mp_err   s_mp_reduce(mp_int *x, const mp_int *m, const mp_int *mu)
+mp_err
+s_mp_reduce(mp_int *x, const mp_int *m, const mp_int *mu)
 {
-  mp_int   q;
-  mp_err   res;
+    mp_int q;
+    mp_err res;
 
-  if((res = mp_init_copy(&q, x)) != MP_OKAY)
-    return res;
+    if ((res = mp_init_copy(&q, x)) != MP_OKAY)
+        return res;
 
-  s_mp_rshd(&q, USED(m) - 1);  /* q1 = x / b^(k-1)  */
-  s_mp_mul(&q, mu);            /* q2 = q1 * mu      */
-  s_mp_rshd(&q, USED(m) + 1);  /* q3 = q2 / b^(k+1) */
+    s_mp_rshd(&q, USED(m) - 1); /* q1 = x / b^(k-1)  */
+    s_mp_mul(&q, mu);           /* q2 = q1 * mu      */
+    s_mp_rshd(&q, USED(m) + 1); /* q3 = q2 / b^(k+1) */
 
-  /* x = x mod b^(k+1), quick (no division) */
-  s_mp_mod_2d(x, DIGIT_BIT * (USED(m) + 1));
+    /* x = x mod b^(k+1), quick (no division) */
+    s_mp_mod_2d(x, DIGIT_BIT * (USED(m) + 1));
 
-  /* q = q * m mod b^(k+1), quick (no division) */
-  s_mp_mul(&q, m);
-  s_mp_mod_2d(&q, DIGIT_BIT * (USED(m) + 1));
+    /* q = q * m mod b^(k+1), quick (no division) */
+    s_mp_mul(&q, m);
+    s_mp_mod_2d(&q, DIGIT_BIT * (USED(m) + 1));
 
-  /* x = x - q */
-  if((res = mp_sub(x, &q, x)) != MP_OKAY)
-    goto CLEANUP;
+    /* x = x - q */
+    if ((res = mp_sub(x, &q, x)) != MP_OKAY)
+        goto CLEANUP;
 
-  /* If x < 0, add b^(k+1) to it */
-  if(mp_cmp_z(x) < 0) {
-    mp_set(&q, 1);
-    if((res = s_mp_lshd(&q, USED(m) + 1)) != MP_OKAY)
-      goto CLEANUP;
-    if((res = mp_add(x, &q, x)) != MP_OKAY)
-      goto CLEANUP;
-  }
+    /* If x < 0, add b^(k+1) to it */
+    if (mp_cmp_z(x) < 0) {
+        mp_set(&q, 1);
+        if ((res = s_mp_lshd(&q, USED(m) + 1)) != MP_OKAY)
+            goto CLEANUP;
+        if ((res = mp_add(x, &q, x)) != MP_OKAY)
+            goto CLEANUP;
+    }
 
-  /* Back off if it's too big */
-  while(mp_cmp(x, m) >= 0) {
-    if((res = s_mp_sub(x, m)) != MP_OKAY)
-      break;
-  }
+    /* Back off if it's too big */
+    while (mp_cmp(x, m) >= 0) {
+        if ((res = s_mp_sub(x, m)) != MP_OKAY)
+            break;
+    }
 
- CLEANUP:
-  mp_clear(&q);
+CLEANUP:
+    mp_clear(&q);
 
-  return res;
+    return res;
 
 } /* end s_mp_reduce() */
 
@@ -4358,47 +4462,50 @@ mp_err   s_mp_reduce(mp_int *x, const mp_int *m, const mp_int *mu)
 /* {{{ s_mp_cmp(a, b) */
 
 /* Compare |a| <=> |b|, return 0 if equal, <0 if a<b, >0 if a>b           */
-int      s_mp_cmp(const mp_int *a, const mp_int *b)
+int
+s_mp_cmp(const mp_int *a, const mp_int *b)
 {
-  mp_size used_a = MP_USED(a);
-  {
-    mp_size used_b = MP_USED(b);
-
-    if (used_a > used_b)
-      goto IS_GT;
-    if (used_a < used_b)
-      goto IS_LT;
-  }
-  {
-    mp_digit *pa, *pb;
-    mp_digit da = 0, db = 0;
-
-#define CMP_AB(n) if ((da = pa[n]) != (db = pb[n])) goto done
-
-    pa = MP_DIGITS(a) + used_a;
-    pb = MP_DIGITS(b) + used_a;
-    while (used_a >= 4) {
-      pa     -= 4;
-      pb     -= 4;
-      used_a -= 4;
-      CMP_AB(3);
-      CMP_AB(2);
-      CMP_AB(1);
-      CMP_AB(0);
-    }
-    while (used_a-- > 0 && ((da = *--pa) == (db = *--pb))) 
-      /* do nothing */;
-done:
-    if (da > db)
-      goto IS_GT;
-    if (da < db) 
-      goto IS_LT;
-  }
-  return MP_EQ;
+    mp_size used_a = MP_USED(a);
+    {
+        mp_size used_b = MP_USED(b);
+
+        if (used_a > used_b)
+            goto IS_GT;
+        if (used_a < used_b)
+            goto IS_LT;
+    }
+    {
+        mp_digit *pa, *pb;
+        mp_digit da = 0, db = 0;
+
+#define CMP_AB(n)                     \
+    if ((da = pa[n]) != (db = pb[n])) \
+    goto done
+
+        pa = MP_DIGITS(a) + used_a;
+        pb = MP_DIGITS(b) + used_a;
+        while (used_a >= 4) {
+            pa -= 4;
+            pb -= 4;
+            used_a -= 4;
+            CMP_AB(3);
+            CMP_AB(2);
+            CMP_AB(1);
+            CMP_AB(0);
+        }
+        while (used_a-- > 0 && ((da = *--pa) == (db = *--pb)))
+            /* do nothing */;
+    done:
+        if (da > db)
+            goto IS_GT;
+        if (da < db)
+            goto IS_LT;
+    }
+    return MP_EQ;
 IS_LT:
-  return MP_LT;
+    return MP_LT;
 IS_GT:
-  return MP_GT;
+    return MP_GT;
 } /* end s_mp_cmp() */
 
 /* }}} */
@@ -4406,17 +4513,18 @@ IS_GT:
 /* {{{ s_mp_cmp_d(a, d) */
 
 /* Compare |a| <=> d, return 0 if equal, <0 if a<d, >0 if a>d             */
-int      s_mp_cmp_d(const mp_int *a, mp_digit d)
+int
+s_mp_cmp_d(const mp_int *a, mp_digit d)
 {
-  if(USED(a) > 1)
-    return MP_GT;
+    if (USED(a) > 1)
+        return MP_GT;
 
-  if(DIGIT(a, 0) < d)
-    return MP_LT;
-  else if(DIGIT(a, 0) > d)
-    return MP_GT;
-  else
-    return MP_EQ;
+    if (DIGIT(a, 0) < d)
+        return MP_LT;
+    else if (DIGIT(a, 0) > d)
+        return MP_GT;
+    else
+        return MP_EQ;
 
 } /* end s_mp_cmp_d() */
 
@@ -4428,25 +4536,26 @@ int      s_mp_cmp_d(const mp_int *a, mp_digit d)
   Returns -1 if the value is not a power of two; otherwise, it returns
   k such that v = 2^k, i.e. lg(v).
  */
-int      s_mp_ispow2(const mp_int *v)
+int
+s_mp_ispow2(const mp_int *v)
 {
-  mp_digit d;
-  int      extra = 0, ix;
+    mp_digit d;
+    int extra = 0, ix;
 
-  ix = MP_USED(v) - 1;
-  d = MP_DIGIT(v, ix); /* most significant digit of v */
+    ix = MP_USED(v) - 1;
+    d = MP_DIGIT(v, ix); /* most significant digit of v */
 
-  extra = s_mp_ispow2d(d);
-  if (extra < 0 || ix == 0)
-    return extra;
+    extra = s_mp_ispow2d(d);
+    if (extra < 0 || ix == 0)
+        return extra;
 
-  while (--ix >= 0) {
-    if (DIGIT(v, ix) != 0)
-      return -1; /* not a power of two */
-    extra += MP_DIGIT_BIT;
-  }
+    while (--ix >= 0) {
+        if (DIGIT(v, ix) != 0)
+            return -1; /* not a power of two */
+        extra += MP_DIGIT_BIT;
+    }
 
-  return extra;
+    return extra;
 
 } /* end s_mp_ispow2() */
 
@@ -4454,53 +4563,54 @@ int      s_mp_ispow2(const mp_int *v)
 
 /* {{{ s_mp_ispow2d(d) */
 
-int      s_mp_ispow2d(mp_digit d)
+int
+s_mp_ispow2d(mp_digit d)
 {
-  if ((d != 0) && ((d & (d-1)) == 0)) { /* d is a power of 2 */
-    int pow = 0;
-#if defined (MP_USE_UINT_DIGIT)
-    if (d & 0xffff0000U)
-      pow += 16;
-    if (d & 0xff00ff00U)
-      pow += 8;
-    if (d & 0xf0f0f0f0U)
-      pow += 4;
-    if (d & 0xccccccccU)
-      pow += 2;
-    if (d & 0xaaaaaaaaU)
-      pow += 1;
+    if ((d != 0) && ((d & (d - 1)) == 0)) { /* d is a power of 2 */
+        int pow = 0;
+#if defined(MP_USE_UINT_DIGIT)
+        if (d & 0xffff0000U)
+            pow += 16;
+        if (d & 0xff00ff00U)
+            pow += 8;
+        if (d & 0xf0f0f0f0U)
+            pow += 4;
+        if (d & 0xccccccccU)
+            pow += 2;
+        if (d & 0xaaaaaaaaU)
+            pow += 1;
 #elif defined(MP_USE_LONG_LONG_DIGIT)
-    if (d & 0xffffffff00000000ULL)
-      pow += 32;
-    if (d & 0xffff0000ffff0000ULL)
-      pow += 16;
-    if (d & 0xff00ff00ff00ff00ULL)
-      pow += 8;
-    if (d & 0xf0f0f0f0f0f0f0f0ULL)
-      pow += 4;
-    if (d & 0xccccccccccccccccULL)
-      pow += 2;
-    if (d & 0xaaaaaaaaaaaaaaaaULL)
-      pow += 1;
+        if (d & 0xffffffff00000000ULL)
+            pow += 32;
+        if (d & 0xffff0000ffff0000ULL)
+            pow += 16;
+        if (d & 0xff00ff00ff00ff00ULL)
+            pow += 8;
+        if (d & 0xf0f0f0f0f0f0f0f0ULL)
+            pow += 4;
+        if (d & 0xccccccccccccccccULL)
+            pow += 2;
+        if (d & 0xaaaaaaaaaaaaaaaaULL)
+            pow += 1;
 #elif defined(MP_USE_LONG_DIGIT)
-    if (d & 0xffffffff00000000UL)
-      pow += 32;
-    if (d & 0xffff0000ffff0000UL)
-      pow += 16;
-    if (d & 0xff00ff00ff00ff00UL)
-      pow += 8;
-    if (d & 0xf0f0f0f0f0f0f0f0UL)
-      pow += 4;
-    if (d & 0xccccccccccccccccUL)
-      pow += 2;
-    if (d & 0xaaaaaaaaaaaaaaaaUL)
-      pow += 1;
+        if (d & 0xffffffff00000000UL)
+            pow += 32;
+        if (d & 0xffff0000ffff0000UL)
+            pow += 16;
+        if (d & 0xff00ff00ff00ff00UL)
+            pow += 8;
+        if (d & 0xf0f0f0f0f0f0f0f0UL)
+            pow += 4;
+        if (d & 0xccccccccccccccccUL)
+            pow += 2;
+        if (d & 0xaaaaaaaaaaaaaaaaUL)
+            pow += 1;
 #else
 #error "unknown type for mp_digit"
 #endif
-    return pow;
-  }
-  return -1;
+        return pow;
+    }
+    return -1;
 
 } /* end s_mp_ispow2d() */
 
@@ -4520,32 +4630,33 @@ int      s_mp_ispow2d(mp_digit d)
   The results will be odd if you use a radix < 2 or > 62, you are
   expected to know what you're up to.
  */
-int      s_mp_tovalue(char ch, int r)
+int
+s_mp_tovalue(char ch, int r)
 {
-  int    val, xch;
-  
-  if(r > 36)
-    xch = ch;
-  else
-    xch = toupper(ch);
-
-  if(isdigit(xch))
-    val = xch - '0';
-  else if(isupper(xch))
-    val = xch - 'A' + 10;
-  else if(islower(xch))
-    val = xch - 'a' + 36;
-  else if(xch == '+')
-    val = 62;
-  else if(xch == '/')
-    val = 63;
-  else 
-    return -1;
+    int val, xch;
 
-  if(val < 0 || val >= r)
-    return -1;
+    if (r > 36)
+        xch = ch;
+    else
+        xch = toupper(ch);
+
+    if (isdigit(xch))
+        val = xch - '0';
+    else if (isupper(xch))
+        val = xch - 'A' + 10;
+    else if (islower(xch))
+        val = xch - 'a' + 36;
+    else if (xch == '+')
+        val = 62;
+    else if (xch == '/')
+        val = 63;
+    else
+        return -1;
+
+    if (val < 0 || val >= r)
+        return -1;
 
-  return val;
+    return val;
 
 } /* end s_mp_tovalue() */
 
@@ -4561,20 +4672,21 @@ int      s_mp_tovalue(char ch, int r)
   The results may be odd if you use a radix < 2 or > 64, you are
   expected to know what you're doing.
  */
-  
-char     s_mp_todigit(mp_digit val, int r, int low)
+
+char
+s_mp_todigit(mp_digit val, int r, int low)
 {
-  char   ch;
+    char ch;
 
-  if(val >= r)
-    return 0;
+    if (val >= r)
+        return 0;
 
-  ch = s_dmap_1[val];
+    ch = s_dmap_1[val];
 
-  if(r <= 36 && low)
-    ch = tolower(ch);
+    if (r <= 36 && low)
+        ch = tolower(ch);
 
-  return ch;
+    return ch;
 
 } /* end s_mp_todigit() */
 
@@ -4582,14 +4694,15 @@ char     s_mp_todigit(mp_digit val, int r, int low)
 
 /* {{{ s_mp_outlen(bits, radix) */
 
-/* 
+/*
    Return an estimate for how long a string is needed to hold a radix
    r representation of a number with 'bits' significant bits, plus an
    extra for a zero terminator (assuming C style strings here)
  */
-int      s_mp_outlen(int bits, int r)
+int
+s_mp_outlen(int bits, int r)
 {
-  return (int)((double)bits * LOG_V_2(r) + 1.5) + 1;
+    return (int)((double)bits * LOG_V_2(r) + 1.5) + 1;
 
 } /* end s_mp_outlen() */
 
@@ -4603,40 +4716,40 @@ int      s_mp_outlen(int bits, int r)
    No sign bit, number is positive.  Leading zeros ignored.
  */
 
-mp_err  
+mp_err
 mp_read_unsigned_octets(mp_int *mp, const unsigned char *str, mp_size len)
 {
-  int            count;
-  mp_err         res;
-  mp_digit       d;
+    int count;
+    mp_err res;
+    mp_digit d;
 
-  ARGCHK(mp != NULL && str != NULL && len > 0, MP_BADARG);
+    ARGCHK(mp != NULL && str != NULL && len > 0, MP_BADARG);
 
-  mp_zero(mp);
+    mp_zero(mp);
 
-  count = len % sizeof(mp_digit);
-  if (count) {
-    for (d = 0; count-- > 0; --len) {
-      d = (d << 8) | *str++;
+    count = len % sizeof(mp_digit);
+    if (count) {
+        for (d = 0; count-- > 0; --len) {
+            d = (d << 8) | *str++;
+        }
+        MP_DIGIT(mp, 0) = d;
     }
-    MP_DIGIT(mp, 0) = d;
-  }
 
-  /* Read the rest of the digits */
-  for(; len > 0; len -= sizeof(mp_digit)) {
-    for (d = 0, count = sizeof(mp_digit); count > 0; --count) {
-      d = (d << 8) | *str++;
-    }
-    if (MP_EQ == mp_cmp_z(mp)) {
-      if (!d)
-	continue;
-    } else {
-      if((res = s_mp_lshd(mp, 1)) != MP_OKAY)
-	return res;
+    /* Read the rest of the digits */
+    for (; len > 0; len -= sizeof(mp_digit)) {
+        for (d = 0, count = sizeof(mp_digit); count > 0; --count) {
+            d = (d << 8) | *str++;
+        }
+        if (MP_EQ == mp_cmp_z(mp)) {
+            if (!d)
+                continue;
+        } else {
+            if ((res = s_mp_lshd(mp, 1)) != MP_OKAY)
+                return res;
+        }
+        MP_DIGIT(mp, 0) = d;
     }
-    MP_DIGIT(mp, 0) = d;
-  }
-  return MP_OKAY;
+    return MP_OKAY;
 } /* end mp_read_unsigned_octets() */
 /* }}} */
 
index 9776d4949..3cc87a6fa 100644
--- a/nss/lib/freebl/mpi/mpi.h
+++ b/nss/lib/freebl/mpi/mpi.h
@@ -30,25 +30,25 @@
 
 #include <sys/types.h>
 
-#define  MP_NEG    1
-#define  MP_ZPOS   0
-
-#define  MP_OKAY          0 /* no error, all is well */
-#define  MP_YES           0 /* yes (boolean result)  */
-#define  MP_NO           -1 /* no (boolean result)   */
-#define  MP_MEM          -2 /* out of memory         */
-#define  MP_RANGE        -3 /* argument out of range */
-#define  MP_BADARG       -4 /* invalid parameter     */
-#define  MP_UNDEF        -5 /* answer is undefined   */
-#define  MP_LAST_CODE    MP_UNDEF
-
-typedef unsigned int      mp_sign;
-typedef unsigned int      mp_size;
-typedef int               mp_err;
+#define MP_NEG 1
+#define MP_ZPOS 0
+
+#define MP_OKAY 0    /* no error, all is well */
+#define MP_YES 0     /* yes (boolean result)  */
+#define MP_NO -1     /* no (boolean result)   */
+#define MP_MEM -2    /* out of memory         */
+#define MP_RANGE -3  /* argument out of range */
+#define MP_BADARG -4 /* invalid parameter     */
+#define MP_UNDEF -5  /* answer is undefined   */
+#define MP_LAST_CODE MP_UNDEF
+
+typedef unsigned int mp_sign;
+typedef unsigned int mp_size;
+typedef int mp_err;
 
 #define MP_32BIT_MAX 4294967295U
 
-#if !defined(ULONG_MAX) 
+#if !defined(ULONG_MAX)
 #error "ULONG_MAX not defined"
 #elif !defined(UINT_MAX)
 #error "UINT_MAX not defined"
@@ -216,12 +215,12 @@ mp_err mp_exptmod_d(const mp_int *a, mp_digit d, const mp_int *m, mp_int *c);
 #endif /* MP_MODARITH */
 
 /* Comparisons             */
-int    mp_cmp_z(const mp_int *a);
-int    mp_cmp_d(const mp_int *a, mp_digit d);
-int    mp_cmp(const mp_int *a, const mp_int *b);
-int    mp_cmp_mag(const mp_int *a, const mp_int *b);
-int    mp_isodd(const mp_int *a);
-int    mp_iseven(const mp_int *a);
+int mp_cmp_z(const mp_int *a);
+int mp_cmp_d(const mp_int *a, mp_digit d);
+int mp_cmp(const mp_int *a, const mp_int *b);
+int mp_cmp_mag(const mp_int *a, const mp_int *b);
+int mp_isodd(const mp_int *a);
+int mp_iseven(const mp_int *a);
 
 /* Number theoretic        */
 #if MP_NUMTH
@@ -234,26 +233,26 @@ mp_err mp_invmod_xgcd(const mp_int *a, const mp_int *m, mp_int *c);
 
 /* Input and output        */
 #if MP_IOFUNC
-void   mp_print(mp_int *mp, FILE *ofp);
+void mp_print(mp_int *mp, FILE *ofp);
 #endif /* end MP_IOFUNC */
 
 /* Base conversion         */
 mp_err mp_read_raw(mp_int *mp, char *str, int len);
-int    mp_raw_size(mp_int *mp);
+int mp_raw_size(mp_int *mp);
 mp_err mp_toraw(mp_int *mp, char *str);
 mp_err mp_read_radix(mp_int *mp, const char *str, int radix);
-mp_err mp_read_variable_radix(mp_int *a, const char * str, int default_radix);
-int    mp_radix_size(mp_int *mp, int radix);
+mp_err mp_read_variable_radix(mp_int *a, const char *str, int default_radix);
+int mp_radix_size(mp_int *mp, int radix);
 mp_err mp_toradix(mp_int *mp, char *str, int radix);
-int    mp_tovalue(char ch, int r);
+int mp_tovalue(char ch, int r);
 
-#define mp_tobinary(M, S)  mp_toradix((M), (S), 2)
-#define mp_tooctal(M, S)   mp_toradix((M), (S), 8)
+#define mp_tobinary(M, S) mp_toradix((M), (S), 2)
+#define mp_tooctal(M, S) mp_toradix((M), (S), 8)
 #define mp_todecimal(M, S) mp_toradix((M), (S), 10)
-#define mp_tohex(M, S)     mp_toradix((M), (S), 16)
+#define mp_tohex(M, S) mp_toradix((M), (S), 16)
 
 /* Error strings           */
-const  char  *mp_strerror(mp_err ec);
+const char *mp_strerror(mp_err ec);
 
 /* Octet string conversion functions */
 mp_err mp_read_unsigned_octets(mp_int *mp, const unsigned char *str, mp_size len);
@@ -265,34 +264,42 @@ mp_err mp_to_fixlen_octets(const mp_int *mp, unsigned char *str, mp_size len);
 /* Miscellaneous */
 mp_size mp_trailing_zeros(const mp_int *mp);
 void freebl_cpuid(unsigned long op, unsigned long *eax,
-                         unsigned long *ebx, unsigned long *ecx,
-                         unsigned long *edx);
-
+                  unsigned long *ebx, unsigned long *ecx,
+                  unsigned long *edx);
 
-#define MP_CHECKOK(x)  if (MP_OKAY > (res = (x))) goto CLEANUP
-#define MP_CHECKERR(x) if (MP_OKAY > (res = (x))) goto CLEANUP
+#define MP_CHECKOK(x)          \
+    if (MP_OKAY > (res = (x))) \
+    goto CLEANUP
+#define MP_CHECKERR(x)         \
+    if (MP_OKAY > (res = (x))) \
+    goto CLEANUP
 
 #if defined(MP_API_COMPATIBLE)
-#define NEG             MP_NEG
-#define ZPOS            MP_ZPOS
-#define DIGIT_MAX       MP_DIGIT_MAX
-#define DIGIT_BIT       MP_DIGIT_BIT
-#define DIGIT_FMT       MP_DIGIT_FMT
-#define RADIX           MP_RADIX
-#define MAX_RADIX       MP_MAX_RADIX
-#define SIGN(MP)        MP_SIGN(MP)
-#define USED(MP)        MP_USED(MP)
-#define ALLOC(MP)       MP_ALLOC(MP)
-#define DIGITS(MP)      MP_DIGITS(MP)
-#define DIGIT(MP,N)     MP_DIGIT(MP,N)
+#define NEG MP_NEG
+#define ZPOS MP_ZPOS
+#define DIGIT_MAX MP_DIGIT_MAX
+#define DIGIT_BIT MP_DIGIT_BIT
+#define DIGIT_FMT MP_DIGIT_FMT
+#define RADIX MP_RADIX
+#define MAX_RADIX MP_MAX_RADIX
+#define SIGN(MP) MP_SIGN(MP)
+#define USED(MP) MP_USED(MP)
+#define ALLOC(MP) MP_ALLOC(MP)
+#define DIGITS(MP) MP_DIGITS(MP)
+#define DIGIT(MP, N) MP_DIGIT(MP, N)
 
 #if MP_ARGCHK == 1
-#define  ARGCHK(X,Y)  {if(!(X)){return (Y);}}
+#define ARGCHK(X, Y)    \
+    {                   \
+        if (!(X)) {     \
+            return (Y); \
+        }               \
+    }
 #elif MP_ARGCHK == 2
 #include <assert.h>
-#define  ARGCHK(X,Y)  assert(X)
+#define ARGCHK(X, Y) assert(X)
 #else
-#define  ARGCHK(X,Y)  /*  */
+#define ARGCHK(X, Y) /*  */
 #endif
 #endif /* defined MP_API_COMPATIBLE */
 
index 65f504e15..89fd03ae8 100644
--- a/nss/lib/freebl/mpi/mplogic.c
+++ b/nss/lib/freebl/mpi/mplogic.c
@@ -13,22 +13,22 @@
 /* {{{ Lookup table for population count */
 
 static unsigned char bitc[] = {
-   0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 
-   1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
-   1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
-   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
-   1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
-   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
-   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
-   3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
-   1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
-   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
-   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
-   3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
-   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
-   3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
-   3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
-   4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
+    0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
+    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+    4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
 };
 
 /* }}} */
@@ -43,23 +43,24 @@ static unsigned char bitc[] = {
 
 /* {{{ mpl_not(a, b) */
 
-mp_err mpl_not(mp_int *a, mp_int *b)
+mp_err
+mpl_not(mp_int *a, mp_int *b)
 {
-  mp_err   res;
-  unsigned int      ix;
+    mp_err res;
+    unsigned int ix;
 
-  ARGCHK(a != NULL && b != NULL, MP_BADARG);
+    ARGCHK(a != NULL && b != NULL, MP_BADARG);
 
-  if((res = mp_copy(a, b)) != MP_OKAY)
-    return res;
+    if ((res = mp_copy(a, b)) != MP_OKAY)
+        return res;
 
-  /* This relies on the fact that the digit type is unsigned */
-  for(ix = 0; ix < USED(b); ix++) 
-    DIGIT(b, ix) = ~DIGIT(b, ix);
+    /* This relies on the fact that the digit type is unsigned */
+    for (ix = 0; ix < USED(b); ix++)
+        DIGIT(b, ix) = ~DIGIT(b, ix);
 
-  s_mp_clamp(b);
+    s_mp_clamp(b);
 
-  return MP_OKAY;
+    return MP_OKAY;
 
 } /* end mpl_not() */
 
@@ -67,31 +68,32 @@ mp_err mpl_not(mp_int *a, mp_int *b)
 
 /* {{{ mpl_and(a, b, c) */
 
-mp_err mpl_and(mp_int *a, mp_int *b, mp_int *c)
+mp_err
+mpl_and(mp_int *a, mp_int *b, mp_int *c)
 {
-  mp_int  *which, *other;
-  mp_err   res;
-  unsigned int      ix;
-
-  ARGCHK(a != NULL && b != NULL && c != NULL, MP_BADARG);
-
-  if(USED(a) <= USED(b)) {
-    which = a;
-    other = b;
-  } else {
-    which = b;
-    other = a;
-  }
+    mp_int *which, *other;
+    mp_err res;
+    unsigned int ix;
+
+    ARGCHK(a != NULL && b != NULL && c != NULL, MP_BADARG);
+
+    if (USED(a) <= USED(b)) {
+        which = a;
+        other = b;
+    } else {
+        which = b;
+        other = a;
+    }
 
-  if((res = mp_copy(which, c)) != MP_OKAY)
-    return res;
+    if ((res = mp_copy(which, c)) != MP_OKAY)
+        return res;
 
-  for(ix = 0; ix < USED(which); ix++)
-    DIGIT(c, ix) &= DIGIT(other, ix);
+    for (ix = 0; ix < USED(which); ix++)
+        DIGIT(c, ix) &= DIGIT(other, ix);
 
-  s_mp_clamp(c);
+    s_mp_clamp(c);
 
-  return MP_OKAY;
+    return MP_OKAY;
 
 } /* end mpl_and() */
 
@@ -99,29 +101,30 @@ mp_err mpl_and(mp_int *a, mp_int *b, mp_int *c)
 
 /* {{{ mpl_or(a, b, c) */
 
-mp_err mpl_or(mp_int *a, mp_int *b, mp_int *c)
+mp_err
+mpl_or(mp_int *a, mp_int *b, mp_int *c)
 {
-  mp_int  *which, *other;
-  mp_err   res;
-  unsigned int      ix;
-
-  ARGCHK(a != NULL && b != NULL && c != NULL, MP_BADARG);
-
-  if(USED(a) >= USED(b)) {
-    which = a;
-    other = b;
-  } else {
-    which = b;
-    other = a;
-  }
+    mp_int *which, *other;
+    mp_err res;
+    unsigned int ix;
+
+    ARGCHK(a != NULL && b != NULL && c != NULL, MP_BADARG);
+
+    if (USED(a) >= USED(b)) {
+        which = a;
+        other = b;
+    } else {
+        which = b;
+        other = a;
+    }
 
-  if((res = mp_copy(which, c)) != MP_OKAY)
-    return res;
+    if ((res = mp_copy(which, c)) != MP_OKAY)
+        return res;
 
-  for(ix = 0; ix < USED(which); ix++)
-    DIGIT(c, ix) |= DIGIT(other, ix);
+    for (ix = 0; ix < USED(which); ix++)
+        DIGIT(c, ix) |= DIGIT(other, ix);
 
-  return MP_OKAY;
+    return MP_OKAY;
 
 } /* end mpl_or() */
 
@@ -129,31 +132,32 @@ mp_err mpl_or(mp_int *a, mp_int *b, mp_int *c)
 
 /* {{{ mpl_xor(a, b, c) */
 
-mp_err mpl_xor(mp_int *a, mp_int *b, mp_int *c)
+mp_err
+mpl_xor(mp_int *a, mp_int *b, mp_int *c)
 {
-  mp_int  *which, *other;
-  mp_err   res;
-  unsigned int      ix;
-
-  ARGCHK(a != NULL && b != NULL && c != NULL, MP_BADARG);
-
-  if(USED(a) >= USED(b)) {
-    which = a;
-    other = b;
-  } else {
-    which = b;
-    other = a;
-  }
+    mp_int *which, *other;
+    mp_err res;
+    unsigned int ix;
+
+    ARGCHK(a != NULL && b != NULL && c != NULL, MP_BADARG);
+
+    if (USED(a) >= USED(b)) {
+        which = a;
+        other = b;
+    } else {
+        which = b;
+        other = a;
+    }
 
-  if((res = mp_copy(which, c)) != MP_OKAY)
-    return res;
+    if ((res = mp_copy(which, c)) != MP_OKAY)
+        return res;
 
-  for(ix = 0; ix < USED(which); ix++)
-    DIGIT(c, ix) ^= DIGIT(other, ix);
+    for (ix = 0; ix < USED(which); ix++)
+        DIGIT(c, ix) ^= DIGIT(other, ix);
 
-  s_mp_clamp(c);
+    s_mp_clamp(c);
 
-  return MP_OKAY;
+    return MP_OKAY;
 
 } /* end mpl_xor() */
 
@@ -167,18 +171,19 @@ mp_err mpl_xor(mp_int *a, mp_int *b, mp_int *c)
 
 /* {{{ mpl_rsh(a, b, d) */
 
-mp_err mpl_rsh(const mp_int *a, mp_int *b, mp_digit d)
+mp_err
+mpl_rsh(const mp_int *a, mp_int *b, mp_digit d)
 {
-  mp_err   res;
+    mp_err res;
 
-  ARGCHK(a != NULL && b != NULL, MP_BADARG);
+    ARGCHK(a != NULL && b != NULL, MP_BADARG);
 
-  if((res = mp_copy(a, b)) != MP_OKAY)
-    return res;
+    if ((res = mp_copy(a, b)) != MP_OKAY)
+        return res;
 
-  s_mp_div_2d(b, d);
+    s_mp_div_2d(b, d);
 
-  return MP_OKAY;
+    return MP_OKAY;
 
 } /* end mpl_rsh() */
 
@@ -186,16 +191,17 @@ mp_err mpl_rsh(const mp_int *a, mp_int *b, mp_digit d)
 
 /* {{{ mpl_lsh(a, b, d) */
 
-mp_err mpl_lsh(const mp_int *a, mp_int *b, mp_digit d)
+mp_err
+mpl_lsh(const mp_int *a, mp_int *b, mp_digit d)
 {
-  mp_err   res;
+    mp_err res;
 
-  ARGCHK(a != NULL && b != NULL, MP_BADARG);
+    ARGCHK(a != NULL && b != NULL, MP_BADARG);
 
-  if((res = mp_copy(a, b)) != MP_OKAY)
-    return res;
+    if ((res = mp_copy(a, b)) != MP_OKAY)
+        return res;
 
-  return s_mp_mul_2d(b, d);
+    return s_mp_mul_2d(b, d);
 
 } /* end mpl_lsh() */
 
@@ -215,29 +221,30 @@ mp_err mpl_lsh(const mp_int *a, mp_int *b, mp_digit d)
 
 /* {{{ mpl_num_set(a, num) */
 
-mp_err mpl_num_set(mp_int *a, int *num)
+mp_err
+mpl_num_set(mp_int *a, int *num)
 {
-  unsigned int   ix;
-  int            db, nset = 0;
-  mp_digit       cur;
-  unsigned char  reg;
+    unsigned int ix;
+    int db, nset = 0;
+    mp_digit cur;
+    unsigned char reg;
+
+    ARGCHK(a != NULL, MP_BADARG);
 
-  ARGCHK(a != NULL, MP_BADARG);
+    for (ix = 0; ix < USED(a); ix++) {
+        cur = DIGIT(a, ix);
 
-  for(ix = 0; ix < USED(a); ix++) {
-    cur = DIGIT(a, ix);
-    
-    for(db = 0; db < sizeof(mp_digit); db++) {
-      reg = (unsigned char)(cur >> (CHAR_BIT * db));
+        for (db = 0; db < sizeof(mp_digit); db++) {
+            reg = (unsigned char)(cur >> (CHAR_BIT * db));
 
-      nset += bitc[reg];
+            nset += bitc[reg];
+        }
     }
-  }
 
-  if(num)
-    *num = nset;
+    if (num)
+        *num = nset;
 
-  return MP_OKAY;
+    return MP_OKAY;
 
 } /* end mpl_num_set() */
 
@@ -245,30 +252,30 @@ mp_err mpl_num_set(mp_int *a, int *num)
 
 /* {{{ mpl_num_clear(a, num) */
 
-mp_err mpl_num_clear(mp_int *a, int *num)
+mp_err
+mpl_num_clear(mp_int *a, int *num)
 {
-  unsigned int   ix;
-  int            db, nset = 0;
-  mp_digit       cur;
-  unsigned char  reg;
+    unsigned int ix;
+    int db, nset = 0;
+    mp_digit cur;
+    unsigned char reg;
 
-  ARGCHK(a != NULL, MP_BADARG);
+    ARGCHK(a != NULL, MP_BADARG);
 
-  for(ix = 0; ix < USED(a); ix++) {
-    cur = DIGIT(a, ix);
-    
-    for(db = 0; db < sizeof(mp_digit); db++) {
-      reg = (unsigned char)(cur >> (CHAR_BIT * db));
+    for (ix = 0; ix < USED(a); ix++) {
+        cur = DIGIT(a, ix);
 
-      nset += bitc[UCHAR_MAX - reg];
-    }
-  }
+        for (db = 0; db < sizeof(mp_digit); db++) {
+            reg = (unsigned char)(cur >> (CHAR_BIT * db));
 
-  if(num)
-    *num = nset;
+            nset += bitc[UCHAR_MAX - reg];
+        }
+    }
 
-  return MP_OKAY;
+    if (num)
+        *num = nset;
 
+    return MP_OKAY;
 
 } /* end mpl_num_clear() */
 
@@ -285,34 +292,35 @@ mp_err mpl_num_clear(mp_int *a, int *num)
 
 /* {{{ mpl_parity(a) */
 
-mp_err mpl_parity(mp_int *a)
+mp_err
+mpl_parity(mp_int *a)
 {
-  unsigned int ix;
-  int      par = 0;
-  mp_digit cur;
+    unsigned int ix;
+    int par = 0;
+    mp_digit cur;
 
-  ARGCHK(a != NULL, MP_BADARG);
+    ARGCHK(a != NULL, MP_BADARG);
 
-  for(ix = 0; ix < USED(a); ix++) {
-    int   shft = (sizeof(mp_digit) * CHAR_BIT) / 2;
+    for (ix = 0; ix < USED(a); ix++) {
+        int shft = (sizeof(mp_digit) * CHAR_BIT) / 2;
 
-    cur = DIGIT(a, ix);
+        cur = DIGIT(a, ix);
 
-    /* Compute parity for current digit */
-    while(shft != 0) {
-      cur ^= (cur >> shft);
-      shft >>= 1;
-    }
-    cur &= 1;
+        /* Compute parity for current digit */
+        while (shft != 0) {
+            cur ^= (cur >> shft);
+            shft >>= 1;
+        }
+        cur &= 1;
 
-    /* XOR with running parity so far   */
-    par ^= cur;
-  }
+        /* XOR with running parity so far   */
+        par ^= cur;
+    }
 
-  if(par)
-    return MP_ODD;
-  else
-    return MP_EVEN;
+    if (par)
+        return MP_ODD;
+    else
+        return MP_EVEN;
 
 } /* end mpl_parity() */
 
@@ -324,29 +332,30 @@ mp_err mpl_parity(mp_int *a)
   Returns MP_OKAY or some error code.
   Grows a if needed to set a bit to 1.
  */
-mp_err mpl_set_bit(mp_int *a, mp_size bitNum, mp_size value)
+mp_err
+mpl_set_bit(mp_int *a, mp_size bitNum, mp_size value)
 {
-  mp_size      ix;
-  mp_err       rv;
-  mp_digit     mask;
-
-  ARGCHK(a != NULL, MP_BADARG);
-
-  ix = bitNum / MP_DIGIT_BIT;
-  if (ix + 1 > MP_USED(a)) {
-    rv = s_mp_pad(a, ix + 1);
-    if (rv != MP_OKAY)
-      return rv;
-  }
-
-  bitNum = bitNum % MP_DIGIT_BIT;
-  mask = (mp_digit)1 << bitNum;
-  if (value)
-    MP_DIGIT(a,ix) |= mask;
-  else
-    MP_DIGIT(a,ix) &= ~mask;
-  s_mp_clamp(a);
-  return MP_OKAY;
+    mp_size ix;
+    mp_err rv;
+    mp_digit mask;
+
+    ARGCHK(a != NULL, MP_BADARG);
+
+    ix = bitNum / MP_DIGIT_BIT;
+    if (ix + 1 > MP_USED(a)) {
+        rv = s_mp_pad(a, ix + 1);
+        if (rv != MP_OKAY)
+            return rv;
+    }
+
+    bitNum = bitNum % MP_DIGIT_BIT;
+    mask = (mp_digit)1 << bitNum;
+    if (value)
+        MP_DIGIT(a, ix) |= mask;
+    else
+        MP_DIGIT(a, ix) &= ~mask;
+    s_mp_clamp(a);
+    return MP_OKAY;
 }
 
 /*
@@ -354,48 +363,50 @@ mp_err mpl_set_bit(mp_int *a, mp_size bitNum, mp_size value)
 
   returns 0 or 1 or some (negative) error code.
  */
-mp_err mpl_get_bit(const mp_int *a, mp_size bitNum)
+mp_err
+mpl_get_bit(const mp_int *a, mp_size bitNum)
 {
-  mp_size      bit, ix;
-  mp_err       rv;
+    mp_size bit, ix;
+    mp_err rv;
 
-  ARGCHK(a != NULL, MP_BADARG);
+    ARGCHK(a != NULL, MP_BADARG);
 
-  ix = bitNum / MP_DIGIT_BIT;
-  ARGCHK(ix <= MP_USED(a) - 1, MP_RANGE);
+    ix = bitNum / MP_DIGIT_BIT;
+    ARGCHK(ix <= MP_USED(a) - 1, MP_RANGE);
 
-  bit   = bitNum % MP_DIGIT_BIT;
-  rv = (mp_err)(MP_DIGIT(a, ix) >> bit) & 1;
-  return rv;
+    bit = bitNum % MP_DIGIT_BIT;
+    rv = (mp_err)(MP_DIGIT(a, ix) >> bit) & 1;
+    return rv;
 }
 
 /*
   mpl_get_bits
   - Extracts numBits bits from a, where the least significant extracted bit
   is bit lsbNum.  Returns a negative value if error occurs.
-  - Because sign bit is used to indicate error, maximum number of bits to 
+  - Because sign bit is used to indicate error, maximum number of bits to
   be returned is the lesser of (a) the number of bits in an mp_digit, or
   (b) one less than the number of bits in an mp_err.
   - lsbNum + numbits can be greater than the number of significant bits in
   integer a, as long as bit lsbNum is in the high order digit of a.
  */
-mp_err mpl_get_bits(const mp_int *a, mp_size lsbNum, mp_size numBits) 
+mp_err
+mpl_get_bits(const mp_int *a, mp_size lsbNum, mp_size numBits)
 {
-  mp_size    rshift = (lsbNum % MP_DIGIT_BIT);
-  mp_size    lsWndx = (lsbNum / MP_DIGIT_BIT);
-  mp_digit * digit  = MP_DIGITS(a) + lsWndx;
-  mp_digit   mask   = ((1 << numBits) - 1);
-
-  ARGCHK(numBits < CHAR_BIT * sizeof mask, MP_BADARG);
-  ARGCHK(MP_HOWMANY(lsbNum, MP_DIGIT_BIT) <= MP_USED(a), MP_RANGE);
-
-  if ((numBits + lsbNum % MP_DIGIT_BIT <= MP_DIGIT_BIT) ||
-      (lsWndx + 1 >= MP_USED(a))) {
-    mask &= (digit[0] >> rshift);
-  } else {
-    mask &= ((digit[0] >> rshift) | (digit[1] << (MP_DIGIT_BIT - rshift)));
-  }
-  return (mp_err)mask;
+    mp_size rshift = (lsbNum % MP_DIGIT_BIT);
+    mp_size lsWndx = (lsbNum / MP_DIGIT_BIT);
+    mp_digit *digit = MP_DIGITS(a) + lsWndx;
+    mp_digit mask = ((1 << numBits) - 1);
+
+    ARGCHK(numBits < CHAR_BIT * sizeof mask, MP_BADARG);
+    ARGCHK(MP_HOWMANY(lsbNum, MP_DIGIT_BIT) <= MP_USED(a), MP_RANGE);
+
+    if ((numBits + lsbNum % MP_DIGIT_BIT <= MP_DIGIT_BIT) ||
+        (lsWndx + 1 >= MP_USED(a))) {
+        mask &= (digit[0] >> rshift);
+    } else {
+        mask &= ((digit[0] >> rshift) | (digit[1] << (MP_DIGIT_BIT - rshift)));
+    }
+    return (mp_err)mask;
 }
 
 /*
@@ -403,28 +414,29 @@ mp_err mpl_get_bits(const mp_int *a, mp_size lsbNum, mp_size numBits)
   returns number of significnant bits in abs(a).
   returns 1 if value is zero.
  */
-mp_size mpl_significant_bits(const mp_int *a)
+mp_size
+mpl_significant_bits(const mp_int *a)
 {
-  mp_size bits = 0;
-  int    ix;
-
-  ARGCHK(a != NULL, MP_BADARG);
-
-  for (ix = MP_USED(a); ix > 0; ) {
-    mp_digit d;
-    d = MP_DIGIT(a, --ix);
-    if (d) {
-      while (d) {
-	++bits;
-	d >>= 1;
-      }
-      break;
+    mp_size bits = 0;
+    int ix;
+
+    ARGCHK(a != NULL, MP_BADARG);
+
+    for (ix = MP_USED(a); ix > 0;) {
+        mp_digit d;
+        d = MP_DIGIT(a, --ix);
+        if (d) {
+            while (d) {
+                ++bits;
+                d >>= 1;
+            }
+            break;
+        }
     }
-  }
-  bits += ix * MP_DIGIT_BIT;
-  if (!bits)
-    bits = 1;
-  return bits;
+    bits += ix * MP_DIGIT_BIT;
+    if (!bits)
+        bits = 1;
+    return bits;
 }
 
 /*------------------------------------------------------------------------*/
-- 
2.20.1

