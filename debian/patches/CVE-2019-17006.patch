From: Markus Koschany <apo@debian.org>
Date: Sat, 4 Jan 2020 17:57:47 +0100
Subject: CVE-2019-17006

Origin: https://hg.mozilla.org/projects/nss/rev/dfd6996fe7425eb0437346d11a01082f16fcfe34
Origin: https://hg.mozilla.org/projects/nss/rev/9d1f5e71773d4e3146524096d74cb96c8df51abe
---
 nss/lib/freebl/chacha20poly1305.c |  6 ++++++
 nss/lib/freebl/ctr.c              | 12 ++++++++++++
 nss/lib/freebl/gcm.c              |  6 ++++++
 nss/lib/freebl/intel-gcm-wrap.c   | 23 +++++++++++++++++++++++
 nss/lib/freebl/rsapkcs.c          | 20 +++++++++++---------
 5 files changed, 58 insertions(+), 9 deletions(-)

diff --git a/nss/lib/freebl/chacha20poly1305.c b/nss/lib/freebl/chacha20poly1305.c
index cd265e1..fb231f2 100644
--- a/nss/lib/freebl/chacha20poly1305.c
+++ b/nss/lib/freebl/chacha20poly1305.c
@@ -180,6 +180,12 @@ ChaCha20Poly1305_Open(const ChaCha20Poly1305Context *ctx, unsigned char *output,
         PORT_SetError(SEC_ERROR_OUTPUT_LEN);
         return SECFailure;
     }
+    // ChaCha has a 64 octet block, with a 32-bit block counter.
+    if (inputLen >= (1ULL << (6 + 32)) + ctx->tagLen) {
+        PORT_SetError(SEC_ERROR_INPUT_LEN);
+        return SECFailure;
+    }
+
 
     PORT_Memset(block, 0, sizeof(block));
     // Generate a block of keystream. The first 32 bytes will be the poly1305
diff --git a/nss/lib/freebl/ctr.c b/nss/lib/freebl/ctr.c
index accd55b..9ba6a17 100644
--- a/nss/lib/freebl/ctr.c
+++ b/nss/lib/freebl/ctr.c
@@ -128,6 +128,12 @@ CTR_Update(CTRContext *ctr, unsigned char *outbuf,
     unsigned int tmp;
     SECStatus rv;
 
+    // Limit block count to 2^counterBits - 2
+    if (ctr->counterBits < (sizeof(unsigned int) * 8) &&
+        inlen > ((1 << ctr->counterBits) - 2) * AES_BLOCK_SIZE) {
+        PORT_SetError(SEC_ERROR_INPUT_LEN);
+        return SECFailure;
+    }
     if (maxout < inlen) {
 	*outlen = inlen;
 	PORT_SetError(SEC_ERROR_OUTPUT_LEN);
@@ -199,6 +205,12 @@ CTR_Update_HW_AES(CTRContext *ctr, unsigned char *outbuf,
     unsigned int tmp;
     SECStatus rv;
 
+    // Limit block count to 2^counterBits - 2
+    if (ctr->counterBits < (sizeof(unsigned int) * 8) &&
+        inlen > ((1 << ctr->counterBits) - 2) * AES_BLOCK_SIZE) {
+        PORT_SetError(SEC_ERROR_INPUT_LEN);
+        return SECFailure;
+    }
     if (maxout < inlen) {
 	*outlen = inlen;
 	PORT_SetError(SEC_ERROR_OUTPUT_LEN);
diff --git a/nss/lib/freebl/gcm.c b/nss/lib/freebl/gcm.c
index da97245..871596e 100644
--- a/nss/lib/freebl/gcm.c
+++ b/nss/lib/freebl/gcm.c
@@ -571,6 +571,12 @@ gcmHash_Reset(gcmHashContext *ghash, const unsigned char *AAD,
 {
     SECStatus rv;
 
+    // Limit AADLen in accordance with SP800-38D
+    if (sizeof(AADLen) >= 8 && AADLen > (1ULL << 61) - 1) {
+        PORT_SetError(SEC_ERROR_INPUT_LEN);
+        return SECFailure;
+    }
+
     ghash->cLen = 0;
     PORT_Memset(ghash->counterBuf, 0, GCM_HASH_LEN_LEN*2);
     ghash->bufLen = 0;
diff --git a/nss/lib/freebl/intel-gcm-wrap.c b/nss/lib/freebl/intel-gcm-wrap.c
index 1287474..c4663bf 100644
--- a/nss/lib/freebl/intel-gcm-wrap.c
+++ b/nss/lib/freebl/intel-gcm-wrap.c
@@ -63,6 +63,13 @@ intel_AES_GCMContext *intel_AES_GCM_CreateContext(void *context,
       PORT_SetError(SEC_ERROR_LIBRARY_FAILURE);
       return NULL;
     }
+
+    // Limit AADLen in accordance with SP800-38D
+    if (sizeof(AAD_whole_len) >= 8 && AAD_whole_len > (1ULL << 61) - 1) {
+        PORT_SetError(SEC_ERROR_INPUT_LEN);
+        return NULL;
+    }
+
     gcm = PORT_ZNew(intel_AES_GCMContext);
 
     if (gcm == NULL) {
@@ -159,6 +166,14 @@ SECStatus intel_AES_GCM_EncryptUpdate(intel_AES_GCMContext *gcm,
     unsigned char T[AES_BLOCK_SIZE];
     unsigned int j;
 
+    // GCM has a 16 octet block, with a 32-bit block counter
+    // Limit in accordance with SP800-38D
+    if (sizeof(inlen) > 4 &&
+        inlen >= ((1ULL << 32) - 2) * AES_BLOCK_SIZE) {
+        PORT_SetError(SEC_ERROR_INPUT_LEN);
+        return SECFailure;
+    }
+
     tagBytes = (gcm->tagBits + (PR_BITS_PER_BYTE - 1)) / PR_BITS_PER_BYTE;
     if (UINT_MAX - inlen < tagBytes) {
         PORT_SetError(SEC_ERROR_INPUT_LEN);
@@ -215,6 +230,14 @@ SECStatus intel_AES_GCM_DecryptUpdate(intel_AES_GCMContext *gcm,
     inlen -= tagBytes;
     intag = inbuf + inlen;
 
+    // GCM has a 16 octet block, with a 32-bit block counter
+    // Limit in accordance with SP800-38D
+    if (sizeof(inlen) > 4 &&
+        inlen >= ((1ULL << 32) - 2) * AES_BLOCK_SIZE) {
+        PORT_SetError(SEC_ERROR_INPUT_LEN);
+        return SECFailure;
+    }
+
     if (maxout < inlen) {
         *outlen = inlen;
         PORT_SetError(SEC_ERROR_OUTPUT_LEN);
diff --git a/nss/lib/freebl/rsapkcs.c b/nss/lib/freebl/rsapkcs.c
index d366b6c..40b28d6 100644
--- a/nss/lib/freebl/rsapkcs.c
+++ b/nss/lib/freebl/rsapkcs.c
@@ -91,7 +91,7 @@ rsa_FormatOneBlock(unsigned modulusLen,
 {
     unsigned char *block;
     unsigned char *bp;
-    int padLen;
+    unsigned int padLen;
     int i, j;
     SECStatus rv;
 
@@ -114,11 +114,12 @@ rsa_FormatOneBlock(unsigned modulusLen,
        * Blocks intended for private-key operation.
        */
       case RSA_BlockPrivate:	 /* preferred method */
-        /*
-         * 0x00 || BT || Pad || 0x00 || ActualData
-         *   1      1   padLen    1      data->len
-         * Pad is either all 0x00 or all 0xff bytes, depending on blockType.
-         */
+          /*
+           * 0x00 || BT || Pad || 0x00 || ActualData
+           *   1      1   padLen    1      data->len
+           * padLen must be at least RSA_BLOCK_MIN_PAD_LEN (8) bytes.
+           * Pad is either all 0x00 or all 0xff bytes, depending on blockType.
+           */
         padLen = modulusLen - data->len - 3;
         PORT_Assert(padLen >= RSA_BLOCK_MIN_PAD_LEN);
         if (padLen < RSA_BLOCK_MIN_PAD_LEN) {
@@ -138,7 +139,7 @@ rsa_FormatOneBlock(unsigned modulusLen,
         /*
          * 0x00 || BT || Pad || 0x00 || ActualData
          *   1      1   padLen    1      data->len
-         * Pad is all non-zero random bytes.
+         * Pad is 8 or more non-zero random bytes.
          *
          * Build the block left to right.
          * Fill the entire block from Pad to the end with random bytes.
@@ -212,8 +213,9 @@ rsa_FormatBlock(SECItem * result,
          * The "3" below is the first octet + the second octet + the 0x00
          * octet that always comes just before the ActualData.
          */
-        PORT_Assert(data->len <= (modulusLen - (3 + RSA_BLOCK_MIN_PAD_LEN)));
-
+        if (data->len > (modulusLen - (3 + RSA_BLOCK_MIN_PAD_LEN))) {
+            return SECFailure;
+        }
         result->data = rsa_FormatOneBlock(modulusLen, blockType, data);
         if (result->data == NULL) {
             result->len = 0;
