Description: CVE-2017-7805: Potential use-after-free in TLS 1.2 server when verifying client authentication
Origin: backport, https://hg.mozilla.org/projects/nss/rev/839200ce0943166a079284bdf45dcc37bb672925
Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=1377618
Bug-RedHat: https://bugzilla.redhat.com/show_bug.cgi?id=1471171
Bug-SuSE: https://bugzilla.novell.com/show_bug.cgi?id=1061005
Bug-Debian-Security: https://security-tracker.debian.org/tracker/CVE-2017-7805
Forwarded: no
Author: Martin Thomson <martin.thomson@gmail.com>
Last-Update: 2017-10-07

--- a/nss/lib/ssl/ssl3con.c
+++ b/nss/lib/ssl/ssl3con.c
@@ -10566,23 +10566,20 @@ ssl3_HandleCertificateVerify(sslSocket *
             goto alert_loser;
         }
 
-        if (hashes->u.pointer_to_hash_input.data) {
+        /* Read from the message buffer, but we need to use only up to the end
+         * of the previous handshake message. The length of the transcript up to
+         * that point is saved in |hashes->u.transcriptLen|. */
 #ifndef NO_PKCS11_BYPASS
-            if (ss->opt.bypassPKCS11 && hashes->u.pointer_to_hash_input.data) {
-                rv = ssl3_ComputeBypassHandshakeHash(hashes->u.pointer_to_hash_input.data,
-                                                     hashes->u.pointer_to_hash_input.len,
-                                                     sigAndHash.hashAlg,
-                                                     &localHashes);
-            } else
+        if (ss->opt.bypassPKCS11) {
+            rv = ssl3_ComputeBypassHandshakeHash(ss->ssl3.hs.messages.buf,
+                                                 hashes->u.transcriptLen,
+                                                 sigAndHash.hashAlg, &localHashes);
+        } else
 #endif
-            {
-                rv = ssl3_ComputePkcs11HandshakeHash(hashes->u.pointer_to_hash_input.data,
-                                                     hashes->u.pointer_to_hash_input.len,
-                                                     sigAndHash.hashAlg,
-                                                     &localHashes);
-            }
-        } else {
-            rv = SECFailure;
+        {
+            rv = ssl3_ComputePkcs11HandshakeHash(ss->ssl3.hs.messages.buf,
+                                                 hashes->u.transcriptLen,
+                                                 sigAndHash.hashAlg, &localHashes);
         }
 
         if (rv == SECSuccess) {
@@ -12575,15 +12572,15 @@ ssl3_HandleHandshakeMessage(sslSocket *s
                  * additional handshake messages will have been added to the
                  * buffer, e.g. the certificate_verify message itself.)
                  *
-                 * Therefore, we use SSL3Hashes.u.pointer_to_hash_input
-                 * to signal the current state of the buffer.
+                 * Therefore, we use SSL3Hashes.u.transcriptLen to save how much
+                 * data there is and read directly from ss->ssl3.hs.messages
+                 * when calculating the hashes.
                  *
                  * ssl3_HandleCertificateVerify will detect
                  *     hashType == handshake_hash_record
                  * and use that information to calculate the hash.
                  */
-                hashes.u.pointer_to_hash_input.data = ss->ssl3.hs.messages.buf;
-                hashes.u.pointer_to_hash_input.len = ss->ssl3.hs.messages.len;
+                hashes.u.transcriptLen = ss->ssl3.hs.messages.len;
                 hashesPtr = &hashes;
             } else {
                 computeHashes = PR_TRUE;
--- a/nss/lib/ssl/ssl3prot.h
+++ b/nss/lib/ssl/ssl3prot.h
@@ -240,7 +240,7 @@ typedef struct {
     union {
         PRUint8 raw[64];
         SSL3HashesIndividually s;
-        SECItem pointer_to_hash_input;
+        unsigned int transcriptLen;
     } u;
 } SSL3Hashes;
 
