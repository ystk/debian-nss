# HG changeset patch
# User Martin Thomson <martin.thomson@gmail.com>
# Date 1543594048 -3600
#      Fri Nov 30 17:07:28 2018 +0100
# Branch NSS_3_36_BRANCH
# Node ID f550aef6074c43642bdecb0ce21c511c3fbf81eb
# Parent  2ac9939c87ccd681fab7bdbe20eaf092eb26e8ed
Bug 1485864 - Constant time mp_to_fixlen_octets, r=franziskus

Differential Revision: https://phabricator.services.mozilla.com/D11722

Origin: backport, https://hg.mozilla.org/projects/nss/rev/f550aef6074c
[rcs: Backported to jessie]
--- nss-jessie.git.orig/nss/lib/freebl/mpi/mpi.c
+++ nss-jessie.git/nss/lib/freebl/mpi/mpi.c
@@ -4748,38 +4748,61 @@
 /* }}} */
 
 /* {{{ mp_to_fixlen_octets(mp, str) */
-/* output a buffer of big endian octets exactly as long as requested. */
+/* output a buffer of big endian octets exactly as long as requested.
+   constant time on the value of mp. */
 mp_err 
 mp_to_fixlen_octets(const mp_int *mp, unsigned char *str, mp_size length)
 {
-  int  ix, pos = 0;
+  int ix, jx;
   unsigned int  bytes;
 
-  ARGCHK(mp != NULL && str != NULL && !SIGN(mp), MP_BADARG);
-
-  bytes = mp_unsigned_octet_size(mp);
-  ARGCHK(bytes <= length, MP_BADARG);
+  ARGCHK(mp != NULL, MP_BADARG);
+  ARGCHK(str != NULL, MP_BADARG);
+  ARGCHK(!SIGN(mp), MP_BADARG);
+  ARGCHK(length > 0, MP_BADARG);
+
+  /* Constant time on the value of mp.  Don't use mp_unsigned_octet_size. */
+  bytes = USED(mp) * MP_DIGIT_SIZE;
+
+  /* If the output is shorter than the native size of mp, then check that any
+   * bytes not written have zero values.  This check isn't constant time on
+   * the assumption that timing-sensitive callers can guarantee that mp fits
+   * in the allocated space. */
+  ix = USED(mp) - 1;
+  if (bytes > length) {
+    unsigned int zeros = bytes - length;
+
+    while (zeros >= MP_DIGIT_SIZE) {
+      ARGCHK(DIGIT(mp, ix) == 0, MP_BADARG);
+      zeros -= MP_DIGIT_SIZE;
+      ix--;
+    }
 
-  /* place any needed leading zeros */
-  for (;length > bytes; --length) {
-	*str++ = 0;
+    if (zeros > 0) {
+      mp_digit d = DIGIT(mp, ix);
+      mp_digit m = ~0ULL << ((MP_DIGIT_SIZE - zeros) * CHAR_BIT);
+      ARGCHK((d & m) == 0, MP_BADARG);
+      for (jx = MP_DIGIT_SIZE - zeros - 1; jx >= 0; jx--) {
+        *str++ = d >> (jx * CHAR_BIT);
+      }
+      ix--;
+    }
+  } else if (bytes < length) {
+    /* Place any needed leading zeros. */
+    unsigned int zeros = length - bytes;
+    memset(str, 0, zeros);
+    str += zeros;
   }
 
-  /* Iterate over each digit... */
-  for(ix = USED(mp) - 1; ix >= 0; ix--) {
+  /* Iterate over each whole digit... */
+  for (; ix >= 0; ix--) {
     mp_digit  d = DIGIT(mp, ix);
-    int       jx;
 
     /* Unpack digit bytes, high order first */
-    for(jx = sizeof(mp_digit) - 1; jx >= 0; jx--) {
-      unsigned char x = (unsigned char)(d >> (jx * CHAR_BIT));
-      if (!pos && !x)	/* suppress leading zeros */
-	continue;
-      str[pos++] = x;
+    for (jx = MP_DIGIT_SIZE - 1; jx >= 0; jx--) {
+      *str++ = d >> (jx * CHAR_BIT);
     }
   }
-  if (!pos)
-    str[pos++] = 0;
   return MP_OKAY;
 } /* end mp_to_fixlen_octets() */
 /* }}} */
--- nss-jessie.git.orig/nss/lib/freebl/mpi/mpi.h
+++ nss-jessie.git/nss/lib/freebl/mpi/mpi.h
@@ -125,7 +125,8 @@
 #define MP_WORD_MAX       UINT_MAX
 #endif
 
-#define MP_DIGIT_BIT      (CHAR_BIT*sizeof(mp_digit))
+#define MP_DIGIT_SIZE     sizeof(mp_digit)
+#define MP_DIGIT_BIT      (CHAR_BIT * MP_DIGIT_SIZE)
 #define MP_WORD_BIT       (CHAR_BIT*sizeof(mp_word))
 #define MP_RADIX          (1+(mp_word)MP_DIGIT_MAX)
 
